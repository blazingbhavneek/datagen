# SOURCE: /run/media/blazingbhavneek/Common/Code/datagen/parser/tests/input/test_docs_mini/intel.pdf
# TIMESTAMP: 2026-01-19T13:41:59Z
# FORMAT: .pdf
---
intel

# インル® oneAPI フロgr lamng·gaidid

Intel Corporation

www.intel.com (英語)

著作權と商標にて

# 注意事項:

ごの日本語マニアルは、インルコーリンのウズサイドで公開いたします『Intel®oneAPI Programming Guide』(バーニング2025.1、更新日2025/3/31)の日本語参考証です。原文は更新くださいます可能性のはんだ。原文と翻証文的内容が異な場合は原文を優先て(<)い。

# 目次

# 1 7

1.1 oneAPI 2015年版 2016年版 ..... 8  
1.2 I nnteloneAPIsulerkutofo配布中.. 9   
1.3 開連ドキムntト

# 2 oneAPI 11

# 2.1 SYCL* 使用た C++のデー夕並列处理 12

2.1.1 奎一拉夫参照使用了简单的sulcd 12  
2.1.2 開連情報 13

# 2.2 C/C++ 14

2.2.1 基本のOpenMP\*target構造 14  
2.2.2 map变数 15  
2.2.3 omp target 要使用的二元化  
2.2.4 OpenMP* 才Flö-1dの追加のリソー 17

# 2.3 德巴Iスの選択 18

2.3.1 木斯トコービドのDPC++デバイス選択 18  
2.3.2 德巴式選挙の例 19  
2.3.3 木斯トコアそのOpenMP* テバイスの確認と選挙 19

# 2.4 SYCL\*実行と×モリ一階層 20

2.4.1 实行階層 20   
2.4.2 MeroI-aKesの最適化 20  
2.4.3 21   
2.4.4 微末末末末末末末末末末末末末末末末末末末末末末末末末末末末末末末末末末末末末末末末末末末末末末末末末末末末末末末末

# 3 oneAPI開発環境の設定 23

3.1 IINSUTOUL·DEILOKTOI 23   
3.2 環境变数 24  
3.3 setvars、oneapi-vars 24   
3.4 GPU フライローはフローダンをインストーリル (才授予) 24  
3.5 羟捲ルフィル (Linux\*の) 25  
3.6 Windows* setvars およい oneapi-vars スケpritを使用 25

3.6.1 嚴不蒙一诺卜·德尔克トリ一·莱伊艾卜と統合徳尔克トリ一·莱伊艾卜の違い……25  
3.6.2 統合デレクトリーフレアウトの利点 26  
3.6.3 Visual Studio Code* 拓張 27   
3.6.4 嚴曼卡拉伊引数 27  
3.6.5 实行方法 28  
3.6.6 確認方法 28  
3.6.7 褒数の実行 29  
3.6.8 統合デレクトリーフレアウトの環境変数の初期化 30  
3.6.9 ONEAPIROOT環境變數 30  
3.6.10 Microsoft\*Visual Studio\*vcvarsall.bat構成スケリトの Respirant to 力斯マイズする 31  
3.6.11 VS2022INSTALLDIRとVS2019INSTALLDIR 環境変数 31  
3.6.12 Windows\* setvars.bat設定fraiIle为使用 33  
3.6.13 Microsoft\*Visual Studio\* setvars.bat スケpritを自動化 37

# 3.7 Linux* setvars およ oneapi-vars スケリトを使用 38

3.7.1 メンボーネnt・デイレクトリーニ・レイアウトと統合デイレクトリーニ・レイアウトの違い 38  
3.7.2 統合デレクトリーフレアウトの利点 39  
3.7.3 cromndlain引数 40  
3.7.4 实行方法 41  
3.7.5 褒数の実行 42  
3.7.6 統合デレクトリーフレアウトの環境変数の初期化 44  
3.7.7 ONEAPI_ROOT 環境变数 45  
3.7.8 Linux\* setvars.sh 設定アイルを使用 45  
3.7.9 Eclipse\* servars.sh スケリトを自動化 49  
3.7.10 SETVARS CONFIG 環境変数の状態 50  
3.7.11 SETVARS CONFIG 環境變数の定義 51

# 3.8 Linux\* 51

3.8.1 曼德拉尔菲尔自动口一  
3.8.2 54   
3.8.3 特定のモジロールフィルを口一ドする力スたム·モジロールフィルを作成 54  
3.8.4 玛德一尔法尔·斯克卜的場所 54  
3.8.5 modulefiles 德尔克トリの作成 55  
3.8.6 沙斯テムにTcl 毛ジーリルフィイル環境をインストーリル 56  
3.8.7 modulefiles-setup.sh スケリトの使用 57  
3.8.8 账户管理 58  
3.8.9 複数のモジフルフィiral 58  
3.8.10 oneAPI 58   
3.8.11 開連情報 59

# 3.9 oneAPI トリケーニンご CMake*を使用 59

# 4 oneAPI 165

4.1 单一のル． 61   
4.2 嚴尼尔一の起動 61  
4.3 1onTeloneAPI DPC++/C++ 62   
4.4 嚴尼尔例 62

4.4.1 API バースのコト 63  
4.4.2 御レクト・プロゲラ ミング 65

# 4.5 嚴尼尔的子顺 66

4.5.1 從来のル手順(木トののAPRJON) 66  
4.5.2 SYCL\*才F□一DコトのCONPVAIL手順 67   
4.5.3 JITのコンパル手順 68  
4.5.4 AOTのル手順 69   
4.5.5 69

# 4.6 CPU手順 70

4.6.1 從来のCPU向手順 71  
4.6.2 CPU才F□一Dの手順 71   
4.6.3 CPU $\text{一} _ { \text{一} }$ 一卡才F□一  
4.6.4 CPUコトの最適化 75  
4.6.5 CPUコマンドの例 75  
4.6.6 CPU 一卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡

4.6.7 複数のCPUコア上ご八イナリの実行をコトロル 76

4.7 GPU手順 79

4.7.1 GPU 才F□一Dの手順 80   
4.7.2 GPUコマンドの例 86  
4.7.3 GPU 一卡之卡一向的的事前 (AOT) ニンバイル

4.8 FPGA手順 87

4.8.1 FPGA向的二元八四尔的特殊之理  
4.8.2 SYCL*FPGAコンパウルの種別 88

5 API バースのプロガラミング 92

5.1 《INNTEL®oneAPI DPC++拉伊巴拉里一（INNTEL®oneDPL) 92

5.1.1 一onTeloneDPLLaiPraler之使方 93  
5.1.2 一onTeloneDPLsunPulco

5.2 一oneAPIMss-力一Nell-LiYIeRl (oneMKL) 93

5.2.1 I'oneloneMKLの使方 94   
5.2.2 I'en'teloneMKL sIunPulco

5.3 I nnteloneAPI SreLddinG·Bulnding·DoppK (I nnteloneTBB) 99

5.3.1 I'nteloneTBBの使方 99   
5.3.2 1nTBB 99

5.4 100

5.4.1 I'nel oneDALの使方 100   
5.4.2 101

5.5 101

5.5.1 I'ntel oneCCLの使方 101   
5.5.2 102

5.6 102

5.6.1 103   
5.6.2 105

5.7 105

6 トウア開発プロせス 106

6.1 SYCL\*DPC++のコトの移行 106

6.1.1 C++ 106   
6.1.2 一 oneAPI DPC++ ニンバイヤー使用た CUDA* かSYCL*の移行 106  
6.1.3 OpenCL* メートから SYCL* への移行 107  
6.1.4 CPU、GPU、およFPGA間の移行 107

6.2 110

6.2.1 C/C++ OpenMP* ortonSyCL* メンボーダリーニ ……………………………… 110  
6.2.2 OpenCL* メートの相互運用性 112

6.3 DPC++ 与 OpenMP* 才F□一D处理のデバム． 112

6.3.1 SYCL\* & OpenMP\* 開発向けの oneAPI 微トムル 113  
6.3.2 才F□-D处理のトレス 125  
6.3.3 才F□-D处理のデバム． 127  
6.3.4 才F□一Dの八Fof一MnSを最適化 144

6.4 八万欧元-人MONS·THU-二NGL·SAVILKUL 147

6.4.1 萬一斯拉伊の確定 147  
6.4.2 才F□一D的力一N的特定 148

6.4.3 力一儿を才□一卜 148   
6.4.4 SYCL\*APRlKeJShonn的最適化 148  
6.4.5 再コンパ铱ル、実行、プロフィ専ル、てて繰り返

6.5 oneAPI ロイランドリOneの互換性 151  
6.6 SYCL\* 拓張 151

7 用語集. 152   
8 著作權と商標に附近 155

二のガイドでは次の二とを学ふにこが Kg。

- oneAPI フロgrラーニングの概要: oneAPI、インル® oneAPI メールキット、お願い関連するリソーニスの基本を理解いたします。  
- oneAPI プロガラル・モDEL: C、C++、およんだ Fortranの SYCL* およんだ OpenMP* 才ロービド向けの oneAPI プロガラル・モDELにて紹介ります。  
- oneAPI開発環境の設定:oneAPIアリケーニンの開発環境の設定方法を説明いたします。  
- oneAPI プロガラムのコンパクトと実行：各種アクセラーダー（CPU、FPGA ）、向けのコトをCONPILする詳細を説明いたします。  
- API バースのプロGbムーニング：共通APIと関連ライフローの簡單な紹介、お願いパツフローの使用法の詳細を説明いたします。  
- ネフトウア開発プロセス：デバßガーネムーマンス・プロフィILAーナニ各種 oneAPI リルを使用たドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリドリド川。

# 1はじてに

現代のコンビューダー・アーマデクチヤーで高出計算ハフローマスを達成するには、最適化さ、電力効率に優た、スケーラルなコトが必要です。從来のハリフローマス・CONビューダーニング(HPC)を始てとてAI、ビデ才解析、デー解析にpineHILHITHINMNSの需要は增え統ていす。

中央处理装置(CPU)とガラフィックス处理ユニット(GPU)は、計算エンジン的基本,No算の需要が進化するにて、CPUとGPUの違いや、そのれに最適なローは必しぃも明確はあたません。

現代のロークローツの多樣性から、单一のアーテケチヤーですてのロークローツに対応るは困難にCNTて、アーテケチヤーも多樣化いたします。必要と用的ハフ0ーマンスを達成するはCPU、GPU、AI、おはFPGA、アケルレーナー配置くださたスカリ、デクトル、行列、おは空間(SVMS)アーテケチヤーの組み合わせが求むらます。

今日、CPU とアケセラレーナー (GPU な哪) 向けのコーダンダには、異な言語、ライランドリーツ、そのソルを利用する必要くださいます。こは、そquelの八一トウア・トレットフローは個別のソフウア資産を必要と、異なるターダット・ア一きテクチヤ一全体のはアリケーニヨン・コートの再利用が制限いたします。

oneAPI プロガラミング・モデルは、SYCL* と呼ばるプロガラミング言語と最新の C++ 機能を使用て並列処理表現するごによう、CPU とアケ塞尔ーダーのプロガラミングを簡素化いたします。SYCL*は、单一のソーニス言語で木戸(CPU等)とアケ塞尔ーダー(GPU等)のコトの再利用を可能にし、実行とモリOneの依存関係を明確にしります。SYCL*コト内的マツビング機能に好、ハートウアまたはハートウア・セットに最適化くださたフクロトを実行するたけアリケーニヨンが移行いたします。アケ塞尔ーダー使用くださないitraffloermも、木戸を利用するとでデバイスコトの開発とデバックを簡素化いたします。

oneAPIは、既存のC/C++またはFortranコーユOpenMP*才ロト機能を使用するCPUおよむアケ塞尔一。  
一のプロガラモサトして。

CPU と GPU 之称為使用するか決定する方法にたては、「CPU 和 GPU: 両方を最大限に活用する」(英語)を参照てにくだいたします。

oneAPI プロgrラーマング・モデルを理解くださ、『oneAPI GPU 最適化ガイド』でソフトウアの最適化方法を理解いたします。

注：surleのプロガラムにあて、InneloneAPIが提供する单一プロガラル・モダルの恩惠を得るわはは必い。プロガラムに適てい的かは、設計、実装、おはリロガラム使用するoneAPIプロガラル理解する必要かはみ。

oneapi.com (英語) ご oneAPI ニニシアチフとプロガラルの詳細を参照くださいます。そのサイドのは、oneAPI仕様、SYCL*言語ガイドとAPI リフRENス等诸多、その其他的リソーネが提供いたします。

# 1.1 oneAPI フロgr lamngの概要

oneAPI プロガラーニング・モデルは、複数のロークロード・ドメイングにまたがる広範圍の八eenthmanス・サイ布鲁リーを含む、ハーダフア・ターフット全体で利用uable開発者向けソルの包括的かつ統合さたリソスを提供します。 ライ布鲁リーには、ターフット・アーネテケチヤーごに力スダマイズさた闋数が含まていたて、同じ関数 Respirみ出しを使用て、サボーツるすばてのアーネテケチヤー最適な八eenthmanスを実現いたします。

oneAPI トロガラルンダ・モデル

# Optimized Applications

# Optimized Middleware & Frameworks

# DIRECT PROGRAMMING

Data Parallel C++ (DPC++)

# API-BASED PROGRAMMING

oneAPI Libraries

Analysis & Debug Tools

![](images/c9a25592fff34a53554ac9f886cfe92aeb96bd5b395af4af77f73fb08592e11c.jpg)  
SCALAR

![](images/977d2618a9ba8c964e6ba82e93b5f127e4b06dda1a4ed75dcc805905db0e9ba5.jpg)  
VECTOR

![](images/778e3a91223479339541aaf039fc6f076824438e1d618fb2506ca5ddab7c7bac.jpg)  
MATRIX

![](images/cbe38bef75e5c33042251771894430680fed7e8c58deb19d7ebb26abc9c662c0.jpg)  
SPATIAL

上の图に示すように、oneAPI プロガラモルを利用するアリケーニンは、CPUからFPGAまて複数のタ一格ト・ハーネドウエア・itraトフムで実行,No。Inテルは、一連のツルキット一部とてInneloneAPI製品を提供てい。InneloneAPI oneAPI バー・ツルキットとInnelHPCツルキット、おはこその他のツルキットは、特定の開発者的マクロト要件を満た補完のツルを備えて。例は、InneloneAPI バー・ツルキットには、InneloneoneAPI DPC++/C++ マンバイヤレ、InneloneDP++互換性ツル(InnelDPC)、拉伊straリ一、おはこ解析ツルが含まえ。

- 既存の CUDA* メートを DPC++ メンパイヤルでコンパクトするたけ SYCL* に移行いたしますと開発者は、インテル® DPC++ 互換性ツーリルを使用て既存のプロジックトを DPC++ 使用た SYCL* に移行いたします。  
- IINTEL® oneAPI DPC++/C++ ニンバイヤリーツは、アケセラレーダーをターダガットとするコトのダイレウド。プロガラモングをサボートします。デイレウド・プロガラモングは、EUーザーダーで使用くださるルガリズムでAPIが利用くださいます場合にハフローマスを向上するニーダイング手法です。CPUとGPUターダガット向けには才ノラインコンバイルと才法兰ツルがサボートいたします、FPGAターダガット向けには才法兰ツル広ルのみがサボートいたします。

- API バースのプロダラーニングは、最適化济りのサイフリーダーを介てサボーツiates。にテルoneAPI製品で提供いたします。サイフリーダーは、サボーツiatesるターダegt・ア一テケチヤ一向に事前チーニングくださいます。開発者的介入は必要お願いいたします。例えは、にテルoneAPI マス・カーナル・ライフローの BLAS ルーチングは、CPU ターダegtと同様に GPU ターダegtに最適化さります。  
- ）、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、、等のリルを使用て、ハフーマンス、安定性、電力効率の目標を達成するた。解析お願いいたします。

indeloneAPI テーメリ・ツル�は、indelテドローヒー・ツル(英語)から無料でダウロドです。

インテル® Parallel Studio XEやインテル® System Studioを利用いたします。」は、インテル® HPC リルキット(英語)に興味を堅持くださいます。

# 1.2 ナンル® oneAPI リルキットの配布にたて

インル®oneAPI リルキットは、複数の配布經路から入手いたします。

製品のロ一力ル・インストーリル：インテル® ダンロリバーニー (英語) からインテルoneAPI ミルキットをインストーリルいたします。特定のインストーリルに開る情報は、「インストーリル・ガイド」(英語)を参照くださいます。  
- メンテナまたはリボジトリーツーからインストーリル：サボートserratにomersテナまたはリボジトリーツーからインテル®oneAPI ダールキットをインストーリルします。その種の手順にpineは「インストーリル・ガイド」(英語)を参照てくだき。  
- 事前イングスローがたインル® Tiber™ AI イーラド:最新のイングル®ハートウアにアケセスする無料の開発サイドローリスを使用て、イングル® oneAPI リーリルを選択いたします。イングル® Tiber™ AI イーラドの詳細を確認してくださいます。

# 1.3 開連ドキュメト

次のドキムntは、こか5oneAPI プロジウトを導入する開発者向けの入門資料とて役立らま。

- 元宇宙 - 元宇宙 - 元宇宙

- プンテル® oneAPI バー・ツルキット導入ガイド Linux* 版 (英語)| Windows* 版 (英語)  
- プンテル® HPC リルキット導入ガイド (Linux* 版 (英語) | Windows* 版 (英語)

- ヨル oneAPI リルキットのリリーニト

- ネンテル® oneAPI バー・ソールキット  
- ネンテル® HPC リルキット

言語リフレンス

- Khronos SYCL* API リフアレnton (英語)  
- SYCL* 1.2.1 仕樣 PDF (英語)  
- SYCL* 2020仕樣PDF英語(Rev10) | 日本語(Rev6)  
James Reinders, Ben Ashbaugh, James Broadman, Michael Kinsner, John Pennycook, and Xinmin Tian 著『Data Parallel C++: Mastering DPC++ for Programming of Heterogeneous Systems using C++ and SYCL』(英語) — 本書の一部は、Creative CommonsのライSEPENS (英語)の下で再利用いたします。  
- LLVM/OpenMP* 開連のドキュmonton (英語)  
- OpenMP* 仕樣 (英語)

# 2 oneAPI フロgr lamng·モデル

ハテロジニアス·コンビューテインダのは、木SPORT・プロセSSF一是アケセラレーダー・デバイスの利点を活用て、コトを優効率良く実行いたします。

oneAPI トロガラーニング・モデルは、SYCL* によるデーア並列 C++ (DPC++) およむ OpenMP* (Fortran、C、C++)の2つのハテロジニアス・コンビューニング方式をサボートます。

# 2.1 SYCL*

SYCL*はケロスTPLTフアムの抽象化レイヤー、アリケーニンの木トと力一neaルのコトが同じノーフアILに含まる、ハテロジニアス·プロセSSF用のコトを標準的なISO C++を使用て記述するごが成長。DPC++才一PNSONS·PLOJCTは、LLVM C++ ハンバイヤラ—に SYCL*のサロトを追加ていま�。InneloneAPI DPC++/C++ ハンバイヤラ—は、Innelone®oneAPI ハンバイヤラ—に含ま�ていま�。

# 2.2 SYCL* 力一nellの互換性

SYCL* 2020 仕様に従て、DPC++は SYCL* 力一内科の才予言の力一内科機能の使用を検出いたします。力一内科は、デバイスが力一内科と互換性のはと見なた的是、デバイスが力一内科が要求するすばての側面にしぃ device::has() て true 東報告た場合にごは。つまり、特定のデバイスで作成た kernel Bundle には、デバイスがサボーツしおい要件持つ力一内科は含まむ、互換性のは的力一内科を起動しょうとりと、 sycl::exception がスロ一されま�。

力一専内の要件の起源を特定するごは困難な场合がるた、カ一専に sycl::device_has 属性を追加するごは可以。CONPILAR-は、力一専の sycl::device_has 属性に示得很好いアスcapeト要件が力一専に对て推定た的場合、一警告。。の動作は SYCL*2020仕樣で必須とてい。

# 2.3 OpenMP*

OpenMP*は20年以上に渡り標準化くださいますプロGPLーマング言語のは、インルはOpenMP*標準のバジフ5を実装いたします。OpenMP*の才ローブ機能をサボーパーするインル® oneAPI DPC++/C++ フンバイラーハは、インル® oneAPI バー・ツールキットお願いいたします。HPC ユールキットに含むります。OpenMP*才ロービーをサボーパーるインル® Fortran フンバイラーハは、インル® HPC ユールキットで提供いたします。

次のせクIJONは、它等它言語にて簡単に説明し詳細情報の参照先示し。

# 2.4 SYCL*を使用たC++のデーメ並列处理

C++ 生成性高的高一夕並列プロダラルを行うオーリフに、マルチデーに優州ケチヤの ラボーツは、SYCL*をサロトする標準 C++ によう実現いたします。SYCL*('シケル'と読みます)は、ロイヤルテイ・ フリOneのクロスプロドアモーツムの抽象化レイヤーで、アリケーニンの木ストと力一NEルのコトが同じソーナフ ダルに含むる、ハテロジニアス・プロセツサイ用のコトを標準的なISO C++を使用て記述する这句话ごきります。 DPC++ 才一脱ンソーメ・プロジュ兗は、LLVM C++ マンバイラーニに SYCL*のサボーツを追加,Thい)=(。

# 2.4.1 マυーラムダ参照を使用た簡單なサングルコード

SYCL*の導入を示す最良の方法は、簡單なSAN複ル使用すると这样做よ。SYCL*は最新のC++をバーメスにきるたて、その例のはラムダ式や一樣初期化んだ近年C++に追加くださいます、いっかの機能を使用いたします。開発者的機能に精通いたします。その意味と機能はSAN複ルのCONテキストから明確にCNTMを用む。SYCL*によるプロガラモングの經驗を積ります。、その新鮮C++機能は自然に受け,GL受害者。

次の�ルコは、a[0] = 0、a[1] = 1、...のように配列の各要素をそのインデクス価に設定いたします。

```cpp
1. #include <CL/sycl.hpp>
2. #include <iostream>
3.
4. constexpr int num=16;
5. using namespace sycl;
6.
7. int main()
8. auto r = range{num};
9. buffer<int> a{r};
10.
11. queue{}.submit(&)(handler& h) {
12. accessor out{a, h};
13. h_parallel_for(r, [=](item<1> idx) {
14. out[idx] = idx;
15. });
16. });
17.
18. host_accessor result{a};
19. for (int i=0; i<num; ++i)
20. std::cout << result[i] << "\n";
21. } 
```

最初に気付くごは、ソーナフアルが1つしおいごて。つり、木ストコーニと才ローニさるアケ塞尔一夕一コートの两方がごの单一のソーナフアルから生成さる。次に注目むき点は、構文が標準のC++でたうごて。並列处理を表現する新いキーユアドやプロダマは使用さていせん。代わに、並列处理はC++ケラスを介て表現さてい。例えは9行目にあ buffer イスはデバイスに才ローニさる徴一夕表し、11行目の queue イスは木ストからアケ塞尔一の接続を表じ。

□ドリクは次のうに動作ります。8行目と9行目、初期値を持た16個int要素のbufferを作成ります。そのbufferは配列のうに作用ります。11行目でアクSELレーダー・デバイスに接続するキュー(queue)を作成ます。その簡卍例は、SYCL* ランタムがデフィルトのアクSELレーダー・デバイスを選択いたしますか、APRILKERUNによては、システムのトロジーを調査て特定のアクSELREHERONを選択するごみごきます。キューが作成いたします。その例のはsubmit() メンバーニ闋数を用戶出し、アクSELレーダーにフローを送信します。そのsubmit() 開数の引数はラムダ関数のは、木戸上てむに実行いたします。ラムダ関数は次の2つの二を行います。1つは、12行目でアクSELSAER操作ります。アクSELSAERはバFFFAERの要素を書きむにが成長ます。次に、13行目でparallel_for() 開数を用戶出してコトはアクSELRAER一策実行ります。

parallel_for()の呼声出は2つの引数のは。1つはラums関数のは、もう1つはバフア一内之要素数を示規範围才総クトrです。SYCL*は、ラums関数がレンジ内的イデツスごに一度（ハフア一要素ごに1回）、アケ塞尔ーダーで呼声出さるように調整いたします。ラumsは、12行目で作成たoutアケ塞尔一使用てハフア一要素に值を割り当てるだけです。その簡單な例は、ラums呼吁出し間に依存関係がた的、SYCL*はアケ塞尔ーダーで最も効率良的方法自由に並行て実行くださいます。

parallel_for() 要素を読み取る host_accessor 作成するとです。SYCL*は、そのバフア一がアケ塞尔一によう書き+(\)=18行目)は、parallel_for() によう送信たわ一が完了するまてプロクさは米。アケ塞尔一のわ一が完了ると、木ストコドは18行目以降を統行し、outアケ塞尔一使用てバフア一から値を読み取りむ。

# 2.4.2 開連情報

ごのSYCL*の概要は、完全なチトリルを目指すたはなく、言語機能の一部分を紹介するだけです。ロカル×モリ一、バリア、SIMD等一般にアケセレーダー・ハートウエで使用たて学にきははほかにもたさん)”ありま。一度に複数のアケセレーダー・デバイスにわーを送信する機能もあり、1つのアリケーヨンが複数のデバイスで同時にわーを並行て実行するたともてきま。

以下のリソーナスは、oneAPI DPC++を使用てSYCL*を學習て習得るに役立与否。

- 「インルのサン格尔を使用たSYCL*の調査」(英語)は、GitHub*から入手成功的SAN格尔・アTPLKE-Jehon's紹介とリンクを示ていたします。  
- 「DPC++ 基礎SENPLBコトのウークスル」(英語)は、最初の一步%= HelloWorld!アリケーニンに相当な DPC++ バクトル加算のSENPLBコトを詳しく見てき)=(  
- Khronos*の「SYCL*リフレUNS」(英語)には、SYCL*ケラスのMXUN関数と使用例に閲る情報が含むていります。  
- 「DPC++ 工总承包・トレーニング・コス」(英語)は、インテル Tiber™ AI イラウドで Jupyter* Notebookを使用するガイド付けの学习コスです。iSUSから日本語ハリケジ提供いたします。  
- [Data Parallel C++: Mastering DPC++ for Programming of Heterogeneous Systems using C++ and SYCL* (デーナ並列 C++: C++ と SYCL* 東使用んだロジニアス・シラムのプロガラミング向に DPC++を習得)] (英語)は、SYCL* 和 ハテロジニアス・プロガラミングに関連するプロガラミングの概念と言語の詳細を紹介する書籍です。

# 2.5 C/C++ または Fortran と OpenMP* 才ロービ・プロガラムング・モデル

インル® oneAPI DPC++/C++ ニンバイヤーおよんだインル® Fortran ニンバイヤーを使用すると、OpenMP* ニンクバイアを使用してわくをインルのアケ塞尔ーダー・デバイスに才フロードし、アプロケーションのバフローマングを向上いたします。

ごのせクソルは、OpenMP* ダレ克テイを使用て計算をアケセラレー。デバイスに才ロ一達的方法にて説明いたします。OpenMP* ダレ克テイに慣得很好開発者は『インテルoneAPI DPC++/C++ メンハリーテフロー・ガイドおよリフロー・デバイス』(英語)や『インテルFortran メンハリーナ・デバイドおよリフロー・ガイドおよリフロー・デバイス』(英語)のOpenMP* サボートのせクソル基本的な使い方を参照てくだき。

注: OpenMP*はFPGA テバイスのははサボーツせん。

# 2.5.1 基本の openMP* target 構造

OpenMP* target 構造は、木戸からタ一��ットデバイス八制御を移行するたに使用いたします。変数は木戸とタ一��ットデバイスでマツbillngさります。木戸スレットは、才ロ一ドた計算が完了するまて待機します。ほかのOpenMP*夕スケは、木戸と非同期に実行,Noこは、nowait節を使用て、スレットがタ一��ット領域の完了を待機しおうにします。

```txt
C/C++ 
```

次のC++の客户端は、SAXPY計算をアケ塞尔一夕一に才ロ一ドします。

#pragma omp target map(tofrom:fa), map(to:fb,a) #pragma omp parallel for firstprivate(a) for $(k = 0$ . $k <   FLOPS\_ array\_ SIZE$ . $k + + )$ fa[k] $=$ a\* fa[k] $^+$ fb[k]

配列faは、計算の入力と出力の两方で使用くださいます、アクセラレーダーのtoとfromにマツついたします。配列fbと変数aは計算の入力のは変更いたします。その出力をコビ一する必要のはんだん。変数FLOPS_ARRAY_SIZEはアクセラレーダーに暗黒にマツついたします。ルーム・インデックスkは、OpenMP*仕様に從て暗黒のにTPLAVートです。

# Fortran

ごのFortranコーリドは、行列乘算をアクセラレータに才ロドします。

!\\(omp target map(to: a, b) map(tofrom: c)   
!\\)omp parallel do private(j,i,k) do $j = 1,n$ do i=1,n do k=1,n

$\mathrm{c(i,j) = c(i,j) + a(i,k)*b(k,j)}$ endo  
endo  
endo  
! $\mathbb{S}$ omp end parallel do  
! $\mathbb{S}$ omp end target

配列aとbはアクセラレーダーの入力にマツドさて、配列cはアクセラレーダーの入力と出力にマツドさて。変数nはアクセラレーダーに暗默にマツドさて。ルフ・インデックスはOpenMP*の仕様に従て自動のにprivate=}つるた、private節は才予説言です。

# 2.5.2 map 变数

木戸トとアケセレーナー間のデー共有最適化するた、target data ダイレクテYPは変数をアケセレーナーにマツリ、変数はその領域の範围内でタ一袋ットのデー領域に維持いたします。その機能は、複数のタ一袋ット領域にまてがて変数をマツリするに役立与否。

```txt
C/C++ 
```

```txt
pragma omp target data [節[[,] 節],...]構造化プロット
```

# Fortran

!\\(omp target data [節[,,, 節],...]構造化プロット
!\\)omp end target data

# 節の使用例

節には次の1つ以上を指定いたします。詳細は、TARGET DATA (英語)を参照てくだいたします。

- DEVICE (整数式)   
IF（[TARGETDATA：]斯力拉一論理式）  
MAP（[[マッチタイフ修飾子[，]］マッチタイフ： 1RISTb)

注: 麻酔夕伊蘋には以下を複数指定くださいます。

```txt
- alloc
- to
- from
- tofrom 
```

```txt
- delete
- release 
```

- SUBDEVICE ([整数定数,] 整数式[ : 整数式[ : 整数式])   
- USE_DEVICE_ADDR（リスト）// ifx そのみ利用可能  
USE_DEVICE_PTR (蒙古尔卡斯)

注:SUBDEVICE 節は以下のケスはは無視いたします。

- ZE FLAT DEVICE HIERARCHY が FLAT または COMBINED に設定いたします。  
LIBOMPTARGET_DEVICE 環境変数が SUBDEVICE/SUBSUBDEVICE に設定いたします。  
- ONEAPI_DEVICE_SELECTOR 環境変数を使用てデバイスを選択してる。

```txt
DEVICE（整数式）  
IF（[TARGET DATA：]スカラ一論理式)  
MAP（[[マツつタイフ修飾子[,]]マツつタイフ：alloc|to|from|tofrom|delete|release]リスト)  
SUBDEVICE（[整数定数，]整数式[：整数式[：整数式[：：INテル擴張]]])  
USE_DEVICE_ADDR（リスト）//ifxのみ利用可能  
USE_DEVICE_PTR(ロインターリスト)
```

target update ヨルクテイフムは、map 節で always マツフ修飾子を使用て、ほむトの変数をデバイスの対応する変数と同期するとが成長。

# 2.5.3 omp targetを使用するコンパクト

次のコマンドは、OpenMP* targetを使用するアプロkeeヨンをコンパイルする例を示いたします。

# C/C++

Linux*:

```txt
$ icx -fiopennp -fopenmp-targets=spir64 code.c 
```

- Windows* (icx または icpxx 東使用):

```txt
$ icx /Qiopenmp /Qopenmp-targets=spir64 code.c 
```

# Fortran

Linux*:

```txt
$ ifx -fiopenmp -fopenmp-targets=spir64 code.f90 
```

- Windows*:

```txt
$ ifx /Qiopenmp /Qopenmp-targets=spir64 code.f90 
```

# 2.5.4 OpenMP* 才Flö-の追加のリソ-ス

```
```c
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
``

- 行列乘算 (英語)は、2つ大的な行列を乘算て結果を検証する簡單なプロgramsです。そのプロgramsは、SYCL*んだはOpenMP*の2つ的方法で実装いたします。  
ISO3DFD(英語) プルは、等方性媒質に付ける3次元有限差分波伝搬を参照,Thいは。。3D等方性媒質を伝搬する波形をシチレトする3次元Stenloll地处、複雜なAPRkeshonOpenMP\*ArKeLRA-TeVAsToaIgUoTtoH。高人FMAmSto实现的一般的n課題とくかの手法を示ていは。  
openmp_reduction(英語)は円周率を求る簡單なプロダムです。そのプロダムは、インル®アーミデクチヤー・バーケのCPU的优点にケ塞尔一一向けのC++ およむOpenMP*に適用実装いたします。  
- LLVM/OpenMP* ランタイム (英語)は、利用可能な各種タイフのランタイムにて説明いたします、OpenMP*才フローテデバックする際に役立与否。  
- oneAPI GPU 最適化ガイド (英語 | 日本語) はは、oneAPI フロGRAMで最高の GPU ダフローマンスを実現するさまばまなヒCNTが提供いたします。  
- ビンテル® リールを使用た OpenMP* フリケーニングの才ロードと最適化 (英語)%=、OpenMP* フリケデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデイデい。  
openmp.orgの例題ドキュmontonのは、第4章でアケセラレーローtarget構造に焦点を当ていたします。https://www.openmp.org/wp-content/uploads/openmp-examples-4.5.0.pdf(英語)  
- OpenMP*に閲る役立つ書籍が数多くださいます。書籍のリストにpineは、https://www.openmp.org/resources/openmp-books(英語)を参照てんださい。  
- OpenMP* 才 fluoride 機能の導入 (英語) はは、サボーツる才予ヨンやサングルコト等、インル® ナンバイラーヤ OpenMP* 才 fluoride 使用する方法の詳細にしぃいは、インル® ナンバイラーヤのデバイロスバーリフレUNSLS》を参照てくだき。

- プンテル®oneAPI DPC++/C++ ニンバイヤレーニ・デバイドおよリフロー(英語)

- ネンテル® Fortran ニンハリーローダフロットバーニー・ガイドおよんだラフLENS (英語)

# 2.6 ヨバイスの選択

デバイス (CPU、GPU または FPGA 各样) へのコーナの才フローニは、DPC++ トリケーニンと OpenMP* トリケーニンの両方で利用くださいます。

# 2.6.1 木ストコトのDPC++デバイス選択

木ストコーリは明示のにデバイstsローを選択いたします。デバイスを選択のは、キフ一を選択て次のいズルかのデバイスを初期化いたします。

- default_selector   
cpu_selector   
-gpu_selector  
accelerator_selector

default_selectorが使用いたします。カーネルは利用可能性計算デバイス（surて、たはONEAPI_DEVICE_SELECTOR環境変数の值に基くサフSETト）から選択するヒューリスチックに基しぃて実行いたします。

特定のデバイstsイリド (cpu_selector サgpu_selector)を使用する场合、指定くださたデバイstsイリドがitraトフロー利用可能のはがONEAPI_DEVICE_SELECTOR て指定くださるフィルターリに含まえていけりばncy�ません。指定REAISが利用,No能い場合、LAN夕IMUNStEUMはデバイスが利用,No能いと表示例外をロ一します。ご工レは、事前CONPIL (AOT) ナリリ一、指定くださたデバイstsイリドを含まないitraトフロー実行得起場合にロ一さcludesむ。

注：DPC++ トーニーは、サボーツる任意のターダット・ハービフロー実行いたしますが、特定のターダット・ハービフロー最高のバフローマスを vigor出击にはチューニングが必要いたします。例えはCPU向にチューニングかけたコロは、変更なははGPUアケセレーテーは高速に実行くださいます可能性のは限ります。

ONEAPI_DEVICE_SELECTORは、DPC++ ランタイム使用くださるランタイム計算デバイsts代孕、計算デバイスIDを利用可能なてその組み合わせのサフツトに制御�能う複雑な環境変数です。計算デバイスIDは、SYCL*API、clinfo または sycl-1s (0から始まる番号)によう返うIDに対応し、そのIDを持つデバイスが特定のタプロのはか、特定のランタイムをサボーツするかは関係お願いいたします。プロダラムが特定のセレクター(gpu_selector等）を使用て、ONEAPI_DEVICE_SELECTORのフィルターダ以外くださ过的デバイスを要求いたします、例外がスロ一さります。使い方と設定可能な値の例にpineは、GitHub*の環境変数の説明を参照てくだい。

https://github.com/intel/llvm/blob/sycl/sycl/doc/ EnvironmentVariables.md (英語)

sycl-1s メーリルを使用て、ステムで利用可能性デバイスを確認いたします。SYCL* イDPC++ プロgr lamを実行する前に、そのリルでデバイスを確認いたします。scl-1sは、ONEAPI_DEVICE_SELECTORに設定いたします。い的文章列各デバイスのプロフィクスとて出力いたします。scl-1sの出力形式は、

[ONEAPI_DEVICE_SELECTOR] プラットシャーマ名、デバイス名、デバイスのバーケン [ド现代农业一のバーケン]です。次の例で各行の先頭の角にこ（[]）て围まけた文字符は、プロガラムが実行いたします特定のデバイスを指定する ONEAPI_DEVICE_SELECTOR 文字符です。

# 2.6.2 ヨバイス選択の例

```txt
$ sycl-1s
[opencl:acc:0] Intel® FPGA Emulation Platform for OpenCL™ software, Intel® FPGA Emulation Device 1.2 [2021.12.9.0.24_005321]
[opencl:gpu:1] Intel® OpenCL HD Graphics, Intel® UHD Graphics 630 [0x3e92] 3.0 [21.37.20939]
[opencl:cpu:2] Intel® OpenCL, Intel® Core™ i7-8700 CPU @ 3.20GHz 3.0 [2021.12.9.0.24_005321]
[level_zero:gpu:0] Intel® oneAPI Level-Zero, Intel® UHD Graphics 630 [0x3e92] 1.1 [1.2.20939]
[host:host:0] SYCL host platform, SYCL host device 1.2 [1.2] 
```

デバイス選択に開る詳い情報は、Khonos*の「SYCL*リフレUNS」(英語)を参照てくだいたします。

# 2.6.3 木ストコーユのOpenMP* ダバイスの確認と選択

OpenMP* はは、開発者がデバイス上ごコトを実行得起か確認およ設定する API が用意いたします。状状はリフローはリフローはリフローはリフローはリフローはリフローはリフローはリフローはリフローはリフローはリフローはリフローはリフローはリフローはリフローはリフローはリフローはリフローはリフローはリフローはリフローはリフローはリフローはリフローはリフローはリフ"— device 句を使用て、状状はリフローはリフローはリフローはリフローはリフローはリフローはリフローはリフローはリフローはリフローはリフローはリフローはリIF— device 句を使用。

- int omp_get_num_procs (void) APIは、デバイスで使用可能なプロルーナ数を返しいたします。  
- void omp_set_default_device(int device_num) APIは、コーダまはデ一夕を才フロ一ドするテフィルトのターダットデバイスを設定いたします。  
- int omp get default device(void) APIは、デ fasルトのターフットデバイスを返しります。  
- int omp_get_num/devices(void) APIは、コトんだはデーたを才フローツする木スト以外のデバイスの数を返しいたします。  
- int omp_get_device_num(void) APIは、呼声出たスレットが実行いたします。  
- int omp_is_init_device(int device_num) APIは、現在のタスケがトデバイスで実行いたします。  
- int omp_get_initializer_device(void) APIは、木戸トデバイスを表すデバイス番号を返しいたします。

開発者は、環境変数 LIBOMPTARGET_DEVICEETYPE = [ CPU | GPU ] て実行するデバイstsローを選択いたします。CPU 或 GPU のように特定のデバイスが指定いたします。そのデバイスがシャットシャムで利用可能のはんだごた求らります。指定するデバイスが利用:NO场合、LANタルシスローは環境変数 OMP_TARGET_OFFLOAD に從て動作いたします。OMP_TARGET_OFFLOAD=mandatory 的場合、要求くださiatedeバイスが利用:NOとむ意味のメソセーニジを出力いたします。そり以外の场合はバーケンデバイス (通常はCPU)でシャットシャム実行いたします。デバイスの選択に閲る追加機能は、OpenMP*5.2仕様で確認,No會言。

環境變數に閲る詳細は、以下のGitHub* バージを参照てくだせ。

https://github.com/intel/llvm/blob/sycl/sycl/doc/ EnvironmentVariables.md. (英語)

# 2.7 SYCL* 宜行とメモリ一階層

# 2.7.1 实行階層

SYCL* 实行モデルは、GPU 实行の抽象化くださいます。SYCL* 实行階層は、work-itemの1次元、2次元、た3次元のGPLドで構成いたします、work-groupと呼ばる同じサイズの格尔ーツに格尔ーツ化いたします。work-group内的work-itemはさらに、sub-groupと呼ばる同じサイズの格尔ーツに分割いたします。

![](images/4b0890ddc3f1c868fac017433c2d7178e7fc7b16c96ccd030e5b4edd312442e9.jpg)  
ND-Range

![](images/e83d8a2a0003b75bc2df2c1ec95e51dc5886b1b36abc743e0b86dbda80c54f0f.jpg)  
Work-group   
Sub-group   
Work-item

ごの階層がGPUはけはル®UHDガラフィックスを搭載するCPUでそのように機能するかは、『oneAPI GPU最適化ガイド』の「SYCL*スレットのマッチングとGPU占有率」を参照てくだせ。

# 2.7.2 マモリーフローの最適化

『Tune®VTune™』プロフィ亞拉一使用説和、八万欧元－のトルネクを特定くださいます。詳細にしぃては、『Tune®VTune™』プロフィ亞拉一のデーガイド』の「×毎リ一割り当てAPI」を参照てくだき。

問題の領域が特定くださいます、「インテル® oneAPI GPU 最適化ガイド」に記載いたします。カーナル内的work-item が同期てデーナを交換いたします、デーナを更新いたします、相互に連携てタスケを達成します方法を學習いたします。詳細に/Subはは、GPU 最適化ガイドの次のセクIJONを参照にしてくだい。

- 力一ル内的 work-item 間の同期  
共有口一力儿义毛贝一  
- 結合共有Mモリ一の割り当て

# 2.7.3 ×毛儿一階層

汙用GPU(GPGPU)計算モーテルは、1つ以上的計算デバイスに接続REAた木トで構成REAます。その計算デバイスは、実行ユニット(EU)まはXeバクルエンジn(XVE)と呼ばる多数のGPU計算ENZn(CE)て構成REAます。次の图に示すように、計算デバイスはは、チツ�広、共有ロ一力ルメモリ—SLM)、高帯域幅×モリ—(HBM)哪が含まるごともあらま�。APRLEJONは、木トのソフトウア(木ト・フレムローご)と、事前定義REAたテカリPLINGB·PIONTでVEで実行するたに木トか送信REAた力一NEルの組み合わせとて構築REAます。

![](images/0f4c16d3d921a0e147c26dfb951cae91256bae3158b3a07aae00c2649f335569.jpg)

SYCL* 2020 仕様で要求いたします動作を満たた、特定のデバイスで作成くださいます kernelbundleには互換性的oled力一neaルが含まない场合のはんだ。詳細にしぃは、SYCL*力一neaルの互换性をご覈くだい。

汛用GPU (GPGPU) 計算モDLL内のメモリ一階層の詳細は、『oneAPI GPU 最適化ガイド』の「実行モDLL概要」を参照てくだい。

# 2.7.4 ダーダ・フリフローを使用てGPUのメモロー・レイデンチ一を削減

デーナをプロフィットすると、ラートルの量とレイテングーが減少し、インテル® GPUのバフローマング向上につない。

oneAPI に付けるプロフィットの仕組みにては、「oneAPI GPU 最適化ガイド」の「プロフィット」の節を参照てください。

# 3 oneAPI開発環境の設定

```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
``

# 3.1 トル・デイクtor

Windows* プラルをは、インル® oneAPIリルキット (バーフ、HPC、レング等内容)は通常、コンボーネntsのデフィルト・デイレクトリーヤーのC:\Program Files(x86)\Intel\oneAPI\にインストーリルさります。ツルキットをインストーリルすると、統合デイレクトリーヤー作成いたします、C:\Program Files(x86)\Intel\oneAPI\<toolkit-version>内的那一枝のCONPIONTONTのDEILCTURERIINCRさります。

Linux* プスチムはは、インル® oneAPI リルキット (バーフ、HPC、レングケ等内容)は通常、コンパ-oneCNTのデフィルト・デイレクトリーダー)/opt/intel/oneapi/にインストールiatesます。ツルキットをインストールすると、統合デイレクトリーダー作成さ、/opt/intel/oneapi/<toolkit-version>/内的那一等它のCONPOneNTDのデイレクトリーダーにリンクiatesます。

CONPONNEINT·DILEKUTRIEのレイアウトと統合DILEKUTRIEのレイアウトの違いには、「Windows* て setvars.bat およんだoneapi-vars.bat スクILPTBを使用する」、または「Linux* て setvars およんだoneapi-vars スクILPTBを使用る」を参照てくだき。

注：2024.0 リリ奥斯以降は、macOS*はインル® oneAPI リルキットようお願い��一ネトでサボーツせをなうた。インル® oneAPI 斯レドイング・ビルデイング・プロック(インル® oneTBB)やインル® Implicit SPMD Program Compiler 各種、いっかの才一フソーニス・プロジウトは、引き続きApple リリCON上の macOS*をサボーツestrみ。他的ツルへのサボーツを拧大するたて、貢献者的方々と協力する機會を歡迎しります。

DFoIbU的INsToIUL先是INsToIUL中以变更能。

oneAPI ネンストーリル・デイレクtorリ一内には、開発ステムにインストーリルさてるCONPILRA、LIYPLAR一、解析ツル、およんだほかのツルを含むフルダ一が含まえま�。正確なフィルは、インストーリルさるツルキトとインストーリル中に選択する才PUNSON上て異なりま�。oneAPI ネンストーリル・デイレクtorl一內のほんWhich of the four-digit numbers are in the form of a single-digit number? oneMKL 1 $^ \text{念}$ 含ま�、ipp フルダ一にはINTEL® IPP フILPRA一が含ま�ま�。

# 3.2 環境变数

indeloneAPIsulull一部的山川是、次の環境変数に影響さる。

- メンパイヤルとリングク处理の制御 (PATH、CPATH、INCLUDE た)  
- ヨル、分析ローナリルルフの場所 (PATH、MANPATH と)  
- リル固有のハラメーた一動的(共有)リンク・ライランドリOne特定(LD.Library_PATH、CONDA* と)

# 3.3 setvars、oneapi-vars およvpars フアル

インストーリルaaSるすばてのインテル® oneAPI ダールギットには、親スケリ upt setvars と、ツール固有のスケリト varsが含まえま�(Linux* ては setvars.sh とenv/varssh、Windows* ては setvars.bat と vars.bat)。 这らのスケリトが実行(たはsource)さると、各インテル® oneAPI開発ツールに必要な口一カル環境変数が設定いたします。

統合デレクトリーチ・レイアウトは、2024.0から実装いたします。上位レBELのoneapi-vars スケpritと共通の環境変数を初期化し、オプロンのetc/*/vars.sh (Linux*) お願い etc\*\\vars.bat (Windows*) スケpritと、oneapi-vars スケpritで設定くださいますコンボーネnt固有の環境変数を初期化いたします。

次のセクIJONは、oneAPIのsetvars、oneapi-varsおよ�varsスリトを使用て、oneAPI開発環境を初期化する方法を詳く説明いたします。

- Windows* て setvars と oneapi-vars スケリトを使用  
Linux\* setvars  oneapi-vars SkrIePbT to 使用

# 3.4 GPU ローダイローはフラゲYNをインストーリル (才別)

C++ と SYCL* 東使用て、インル、AMD*、はは NVIDIA* GPU に実行いたします oneAPI フリケーニンを開発いたします。

特定のGPU向けのアTPLKEUNを開発て実行するには、対応するドライローやTPLGIDENをインストールする必要くださいます。

- フrenchen'shengs hengsheng  
- ダンテル® oneAPI DPC++ モンバイラーヤム* GPU 使用するには、Codeplay から oneAPI for AMD*GPU フラダイン (英語)を入手してインストーリュです (Linux*のみ)。日本語ガイドはこらをご覈くくださいます。

- ナンテル® oneAPI DPC++ ニンパイヤラーヤ NVIDIA* GPU と使用するには、Codeplay から oneAPI for NVIDIA* GPU フラゲイン (英語)を入手してんだスローしります (Linux* と Windows*)。日本語ガイドはこらをご覈くだいたします。

# 3.5 羟戸ルフアイル (Linux*のみ)

環境モジロー(英語)を利用するeerーは、インル®oneAPI ダールキットのインストーリル・バッチ一じに含むる modulefile フアイルを使用て、開発環境を初期化する这句话ごはま。modulefile スクIJトはLinux*環境のはんだサロトさており、setvars、oneapi- vars およこ vars スクIJトの代わに使用する这句话可以使用。 modulefile フアイルと setvars 環境スリフトを混在这种使用しぃいにくだき。

modulefile 要使用、inntel® oneAPI 开發環境到初期化辦法の詳細にしだは「Linux* modulefile 要使用」を参照てくた。

# 3.6 Windows*  setvars  oneapi-vars スケpritを使用

バーニュ 2024.0は、統合デレクトリーフレアウトが実装いたします。複数のソルキットのバーニュがインスローせてる场合、統合レルウトによる開発環境に特定のソルキットのバーニュの一部とてリーフ的支持をはまむるようお願い可能が実装いたします、PATH名がシャームカットて長いPATH名の問題の解決にも役立与否。

新い統合デルクトリ・レイアウは、共通モルダ一 (bin、lib、include、share と)にCONP一ネトがイストトルてるごが分かりま。こらの共通モルダ一は、ツルキットのバーニム番号に基つて命名さる最上位モルダ一にあらま。以下に例を示しま。

```txt
1. "C:\Program Files(x86)\Intel\oneAPI\2024.0\"  
2. |-- bin  
3. |-- lib  
4. |-- include  
5. ...etc... 
```

2024.0 原則前のバーニュンで使用くださいますデイレクトリーベイアウトは、新規お願いいたします。デイレクトリーベイアウトは、CONP-oneNT·デイレクトリーベイアウトと呼ばります。CONP-oneNT·デイレRCTRIE-LEYAWTはは統合DEILECTRIE-LEYAWTを使用する才PNSJONが追加いたします。

# 3.6.1 メンボーネnts・デイレクトリーフレアウトと統合デイレRCTリーフレアウトの違い

ほんとんだイングル® oneAPI メンボーネntsには、oneAPI開発作業をサボートする那一つはのトに必要な環境変数を設定するenv\vars.batスケリトが含ていま。例は、デフルトのインスト一ル

はは、Windows*のインル® IPPの varsスケリトは、C:\Program Files (x86)\Intel\oneAPI\ipp\latest\env\vars.batに配置いたします。そのハスは、env\vars 環境変数設定スケリトを含むお願いのインル® oneAPI フフローに共有いたします。

CONPONNEPTDILRELEWUTは、各CONPONNET向のenv\varsStKLRPは、直接たはまて用。中了呼出さてが成。末て呼出にはoneAPIINSTUL-DELKUT一にあsetvars.bat StKLRPを使用し。。。Windows*MarhsonのDFALUTのINSTULは、C:\\Program Files (x86)\\Intel\oneAPI\seYars.batに。統合DFALUT-LEIAWUTは、開発環境の初期化にenv\varsStKLRPを使用し。代わに、各CONPONNETは、CONPONNETに共通の共有FOLDA一に包括さ。末。各CONPONNETは、HSSFAILを单一の共通INKUL一·FOLDA一提供し、そのLIPLAR一·FAPILを单一の共通libFOLDA一に提供するにとに。

# 3.6.2 統合デイレクトリーフ现代农业トの利点

統合デイレクトリーニ・レイアウトを使用するとて setvars 設定フィ�ルを構成て維持た、複数のインテルoneAPI ダールキットをインストルて個別に環境を作成する必要なく、異なるソーツルキットのバーニュンの切り替えがはるかに容易にelizeまた。も、一部の Windows* 开発者によて厄介な問題くださる Windows* 开発ステムの環境変数、特に PATH 变数の長さを制限するにも役立らま�。

統合デイレクトリーベイアウトの環境変数は、一括のは設定,Th。環境変数を初期化するにはoneapi-vars.batスケリトを使用,Th。Windows\`上のデフィルトの統合デイレクトリーベイアウトのインストルは、スケリトはC:\\Program Files (x86)\\Intel\\oneAPI\\<toolkit-version>\oneapi-vars.batにご標む。<toolkit-version>は、インストルた oneAPI リルキットのバーケン番号に対応,Th（例:C:\\Program Files (x86)\\Intel\\oneAPI\\2024.0\\oneapi-vars.bat まは C:\\Program Files(x86)\\Intel\\oneAPI\\2024.1\\oneapi-vars.batと）。

引数不放 setvars.bat スクレットを実行すると、シスチムにインストーリさてるすばての <bonp-onevent> \latest\env\vars.bat スクレットが実行いたします。こらの環境変数設定スクレットを実行した後、Windows*の setコマンドを使用て環境変数を確認いたします。

引数なて oneapi-vars.bat スクレットを実行すると、スクレットが配置いたします。あ、統合デイレクトリーナのインストーベ一部oled才予言C:\\Program Files (x86)\\Intel\\oneAPI\\<toolkit-version>\etc\<component>\vars.sh 斯リトも実行いたします。ごスリトと変更くださ環境変数は、oneapi-vars.batスクレットの実行後のSetやenvコマンドで確認いたします。

oneapi-vars.bat スケリトの仕組みの詳細は、「統合デレクトリーベイアウトの環境変数の初期化」を参照てください。

# 3.6.3 Visual Studio Code* 拓張

Visual Studio Code* 開發者は、oneAPI 環境拝張機能をインストーリて、Visual Studio* Code に setvars.batを実行いたします。詳細にしぃいは、「Visual Studio* Code にインテル® oneAPI ダールcktを使用する」(英語)を参照てくだき。

注: setvars.bat、oneapi-vars.bat スクレット (または個別の vars.bat スクレット) にり変更くださいます環境は永続的地步はようお願いいたします。ごれらの変更是、setvars.bat、oneapi-vars.bat スクレットが実行くださいます cmd.exe サツドンのは有效です。

# 3.6.4 ペマンドライン引数

setvars.bat、oneapi-vars.bat スケリランドン引数をサボーツて的优点、--help 才紹言の引数の一観を表示いたします。

# CONBOP-NEINT·DEILECTRIE-LEYAWT

```batch
$ "C:\Program Files (x86)\Intel\oneAPI\setvars.bat" --help 
```

# 統合デイレクトリーロイアウト

```batch
\$ "C:\\Program Files (x86)\\Intel\\oneAPI\<toolkit-version>\oneapi-vars.bat" --help 
```

--config $\equiv$ file 引数和 setvars.bat、oneapi-vars.bat スケpritから呼声出る vars.bat スケpritハの追加引数をインクル一下用機能を使用て、環境設定を力スタマイズiates。--config $\equiv$ file 才予は、setvars.bat スケpritにuallyのみサボ一トさ得む。

--config=file 引数は、特定のイ�ルoneAPI ニンボーネntsの環境の初期化機能を提供するともに、特定のバーニムの環境を初期化するごとてきまむ。例えは、イ�ルIPPとイ�ルoneMKLの環境のみを設定るには、こら2つのイ�ルoneAPI ニンボーネntsの vars.bat 環境スケリトのみを Respirantly setvars.bat、oneapi-vars.bat スケリトに指示する設定フィ�ILを渡しまむ。詳細利用例にしだはは、「Windows* で setvars.batの設定フィ�IL使用」を参照てくださ。

setvars.bat、oneapi-vars.batのハルフメソーダジに記載いたします。そのまえ vars.batスケリトに渡ります。ently、setvars.bat、oneapi-vars.batスケリトが認識,Noな引数は、 フローネングの vars.batスケリトで使用くださるたと見なし、そのらの引数をすばてのフローネングの vars.batスケリトに渡ります。最初は使用くださる追加の引数はia32とintel64です。它らは、フローネル® フローネム、フローネル® IPP、フローネル® oneMKL、おはいフローネル® oneTBB フローネリローでアフローニーションのターフット・アーマデチヤーを指示するたに使用 ,(

ShstumI複数BauJOnnMscrooft*VisuaLStuo*gInnstU-尔cal在的场合、vs2017、vs2019 末はvs2022 引数を setvars.bat、oneapi-vars.batコマndlaiNに追加するとて、VisuaLStuo* 環境のいじ

かを oneAPI 環境の初期化に使用するかを指定いたします。デ fasルトのは、Visual Studio*の最新バーニングが使用いたします。

個々の vars.bat 斯ケリトを調て、受付出入るコマンドライIN引数がは或を決定し。

# 3.6.5 实行方法

CONBOP-NEINT·DEILKUTRIE-LEIAWU

```batch
<install-dir>\setvars.bat 
```

PowerShell* ユイドウで setvars.bat または vars.bat スケpritを実行するには、以下を使用いたします。

```powershell
$ cmd.exe "/K" "'C:\Program Files (x86)\Intel\oneAPI\setvars.bat" && powershell' 
```

統合デイレクトリーロアウト

```txt
<install-dir>\<tookit-version>\oneapi-vars.bat 
```

PowerShell* 戴尔卡夫·oneapi-vars.bat はリデリフを実行するには、以下使用いたします。

```powershell
$ cmd.exe "/K" "'C:\Program Files (x86)\Intel\oneAPI\< tookit-version >\oneapi-vars.bat" &&powershell' 
```

# 3.6.6 確認方法

setvars.bat、oneapi-vars.batを実行た後、SETVARS_COMPLETED環境変数で設定の成功を確認いたします。  
setvars.bat、oneapi-vars.batが成功いたします、SETVARS_COMPLETEDには1が設定いたします。

```shell
$ set | find "SETVARS COMPLETED" 
```

戸值:

```txt
SETVARS COMPLETED=1 
```

SETVARS_COMPLETED=1 以外の场合、setvars.bat、oneapi-vars.batは設定に失敗たとを意味いたします。

# 3.6.7 VS#####INSTALLDIR 環境变数为使用

Visual Studio* 要標準的場所以外にインストーリルた場合、たは Visual Studio* ビルドソルのみ（Visual Studio*IDE 全体のはんだ）をインストーリルた場合、setvars.bat スケリトが Visual Studio*の vcvarsall.bat スケリトを見つない問題が発生する可能性お願いいたします。そのううな场合は、VS####INSTALLDIR 環境変数を使用て適切な

Visual Studio*のインストーリ先を特定くださいます。例えは、Visual Studio* ビルドソーリのみがインストーリいたします。

```powershell
$ set "VS2022INSTALLDIR=%ProgramFiles(x86)%\Microsoft Visual Studio\2022\BuildTools" $ "%ProgramFiles(x86)%\Intel\oneAPI\setvars.bat" 
```

た、特に広ステムに複数バーニングのVisual Studio*がインストーリてい的场合は、VS###INSTALLDIR 環境変数を使用て、setvars.batに特定のVisual Studio* インストーリの環境を構成するごまきます。

# 3.6.8 複数の実行

各CONP一トのenv\vars.batスケリトの多は、PATH、CPATH、およそのほかの環境変数に変更を加て。た、最上位の setvars.bat、oneapi-vars.batスケリトは同じセソーニ同じ vars.batを複数回鳴出さはてきません。こは、特に%PATH% 環境変数が原因で環境変数の文字数が長なりすきないうにしま�。設定可能な文字数を超えと、ターミルセソーニで予期しぃ動作招くごがるた魅回避る必要かひみ。

ごを強制するには、setvars.bat、oneapi-vars.batに--force才紹広を指定いたします。ご例のは、eu一anzaが setvars.bat、oneapi-vars.batを2度実行いたします。setvars.bat、oneapi-vars.batがすに実行いたします。2回目の実行は停止いたします。

CONBOP-NEINT·DEILKUTRIE-LEIAWU   
```txt
$ <install-dir>\setvars.bat
initializing oneAPI environment ...
(SNIP: lot of output)
:: oneAPI environment initialized 
```

```txt
$ <install-dir>\setvars.bat
.. code-block:: WARNING: setvars.bat has already been run.Skipping re-execution.
To force a re-execution of setvars.bat, use the '-force' option.
Using '-force' can result in excessive use of your environment variables. 
```

次は、eu一が<install-dir>\setvars.bat --forceを実行し、初期化が成功た例です。

統合デイレクトリーロイアウト  
```txt
$ <install-dir>\setvars.bat --force
:: initializing environment ...
(SNIP: lot of output)
:: oneAPI environment initialized 
```

```txt
$ <install-dir>\<toolkit-version>oneapi-vars.bat
:: initializing oneAPI environment ...
(SNIP: lot of output)
:: oneAPI environment initialized 
```

```txt
$ <install-dir>\< toolkit-version>\oneapi-vars.bat
...
code-block:: WARNING: oneapi-vars.bat has already been run. Skipping re-execution.
To force a re-execution of oneapi-vars.bat, use the '-force' option. 
```

```txt
Using --force' can result in excessive use of your environment variables. 
```

3 番目のインスローは、デーローが <install-dir> \<toolkit-version> \oneapi- vars.bat --forceを実行すると、初期化が成功いたします。

```txt
$ <install-dir>\<toolkit-version>\oneapi-vars.bat --force
:: initializing oneAPI environment ...
(SNIP: lot of output)
:: oneAPI environment initialized 
```

# 3.6.9 統合デレクトリーフ现代农业の環境変数の初期化

統合デレクトリーニ・レイアウトの環境変数の初期化は、setvars.bat icanoneapi-vars.batスルトによて行わる。oneapi-varsはsetvarsと似ていま�が、微妙な違いがいつかあら。

setvars スケリトと oneapi-varsの主な違は、setvarsは環境変数(ONEAPI_ROOTを除く)を定義しませんが、oneapi-varsは共通の環境変数を定義いたします。

CONP-1NEINT·DILKUTRII·LEIAWUTは、各CONP-1NEINTが機能するたに必要な環境変数を定義いたします。例には、CONP-1NEINT·DILKUTRII·LEIAWUTはは、各CONP-1NEINTはリング可能なライPLARLI一·フルダをLD.Library_PATHに、て熱HSSDA一をCPATHに追加ります。CONP-1NEINTは、常に次の場所にあるvarsスリクリPBトを介てこを実行いたします。

```batch
$ %ONEAPI_ROOT%\<toolkit-version>\opt\<component-name>\latest\env\vars.bat 
```

統合デイレクトリーニ・レイアウトは、外部向けの include、lib、bin フオルダーを共有フオルダーに統合します。最上位レBELの oneapi-vars スケpritは、こらの共通フオルダーを検出るに必要な環境変数を定義ります。例えは、setvarsはLD.Library_PATHを$ONEAPI_ROOT\libとて定義し、CPATHを$ONEAPI_ROOT\includeと定義いたします。

# 3.6.10 ONEAPI_ROOT 環境变数

ONEAPI_ROOT 環境変数は、スケpritが実行いたしますとに上位の setvars.batとoneapi-vars.batにようて設定いたします。ONEAPI_ROOT 環境変数は設計得很好場合、setvars.batとoneapi-vars.batはスケpritを実行た cmd.exe サツドンを一時に上書ります。その変数は、oneapi-cli メンpluralプロウZRと Microsoft* Visual Studio* およ覈 Visual Studio* Code サンpluralプロウZRによう使用いたします、インテル* oneAPIツルとコンPORーネntの検出、およ覈 SETVARS_CONFIG 機能が有効くださる场合に setvars.batやoneapi-vars.batスケpritを検出いたします。SETVARS_CONFIG 機能の詳細にしだは、「Microsoft* Visual Studio* で setvars.batスケpritを自動化」を参照にして).(

2024.0 リリーベは、インストーラーハスを環境に追加しません。こをデフルト環境に追加するには、ロ一カルの初期化フィアルははシステム環境変数为变数を定義しま�。

# 3.6.11 Microsoft* Visual Studio* vcvarsall.bat 構成スケリトの鳴出しを力 スタマイズする

インテル® oneAPI開発環境には、コマンドプロンクトでVisual Studio* フロジックト操作するこが付けます。例えは、Windows スターマモニeer> [すばてのアリ] > [Visual Studio 2022] フオルダーには、通常、VS 2022のデバイロット・コマンドプロンクトのシャーミ効ット等诸多、複数の構成済み Visual Studio* イフトアツド・スケリトへのシャーミ効ットが含まえてります。ごれらのシャーミ効ットは、通常「%ProgramFiles%Microsoft Visual Studio\2022\Professional\VC\Auxiliary\Build\」デイクットーにあるvcvarsall.batとい名前の Microsoft* Visual Studio* 携成バチフアイルをIPH出ります。

commandsloanbdoinneloneAPI 環境settups.bat）呼出、oneAPI 環境settups.一部とVisualStudio\*vcvarsall.bat Stulptb的呼出。通常、vcvarsall.bat 環境settupsは、setvars.bat 環境settups和一致的上構成。例は、setvars.bat 64 パット oneAPI開発環境用にsettupsさてい的场合（dfoult）、Visual Studio\*vcvarsall.batが64 パット·アリケーニん開発向けにsettupsさていのと保証せ�。

setvars.bat (またはコンパイヤーのenv\\vars.bat)がVisual Studio\vcvarsall.batがすに実行いたします。るごを検出する、以降のvcvarsall.batは実行いたします。つまり、setvars.batスケリトは既存のVisual Studio\vcvarsall.bat環境を優先し、一致するよう構成いたします(64 ヒットは64 ヒット、32 ヒットは32 ヒット)。32 ヒットまたは64 ヒットの引数以外、setvars.batおよんだCONPUAER一のenv\\vars.batスケリトは、vcvarsall.batスケリトに引数を渡ります。Visual Studio\環境をさらに力stsマイズする场合は、setvars.bat またはCONPUAER一のenv\\vars.batスケリトを実行する前に力stsマイズする必要くださいます。

例：

- 必要の引数を指定てvcvarsall.batを直接実行する  
- setvars.bat(たははルハリーナのenv\vars.bat)スケリトを実行する

ごの時点で、コマンドプロンチ開発環境が構成ります。Visual Studio* 2022 Professionalのインストーリルで使用可能なvcvarsall.bat引数は、次のように入力て確認いたします。

```txt
> "ProgramFiles\Microsoft Visual Studio\2022\Professional\VC\Auxiliary\Build\vcvarsall.bat" help 
```

# 3.6.12 VS2022INSTALLDIRとVS2019INSTALLDIR環境変数

setvars.bat、oneapi-vars.bat、または compiler\<version>\env\vars.bat スケpritを実行いたします。

```txt
WARNING: Visual Studio was not found in a standard install location:
"ProgramFiles\Microsoft Visual Studio\Year>\\<Edition>" or
"ProgramFiles(x86)%\Microsoft Visual Studio\Year>\\<Edition>" Set the VS2019INSTALLDIR or VS2022INSTALLDIR
environment variable to point to your install location and try again. 
```

ごのメソーヨが表示た场合は、VS2019INSTALLDIRははVS2022INSTALLDIR環境変数がインストーリ場所を指すように設定て、う一度お試しだんだい。

ごの現象はおはらく、次のいじてかに該当ります。

- Microsoft* Visual Studio* がインストーリてきいません。  
- Microsoft* Visual Studio* が標準以外の場所にインストーリングいたします。  
- Microsoft* Build Tools のみがインストーリていたします。

最初の场合は、Microsoft* Visual Studio*をインストーリて、env スクルフトを再度実行ててくだい。

2 當目の场合、環境設定スケリトを実行する前に、VS2022INSTALLDIR 環境変数 (Visual Studio* 2019を使用くださいます場合はVS2019INSTALLDIR)がMicrosoft* Visual Studio* インストーリルの非標準の場所を指すように設定必須お願いいたします。例えは、Visual Studio* 2022 Professionalと setvars.batの非標準の場所は次のようお願いいたします。

```batch
> set "VS2022INSTALLDIR=C:\my\custom\install\path\Microsoft Visual Studio\2022\Professional"
> "%ProgramFiles(x86)%\Intel\oneAPI\setvars.bat" 
```

はVisual Studio* 2022 ビルドソルを標準の場所にインストーリルた場合はVS2022INSTALLDIRがそのインストーリル場所を指すように設定いたします。setvars.batを使用する场合の例を示ります。

```batch
> set "VS2022INSTALLDIR=%ProgramFiles(x86)%\Microsoft Visual Studio\2022\BuildTools"
> "%ProgramFiles(x86)%\Intel\oneAPI\setvars.bat" 
```

# 3.6.13 Windows* て setvars.bat 設定フィルを使用

setvars.bat スクレットは、そのOneAPI ヨーニルリローにる<install-dir>\latest\env\vars.bat  
スクレットを実行するとて、インル oneAPI ヨーニルキットの環境変数を設定いたします。setvars.bat スクレットを自動実行いたします Windows* プ斯塔ムを設定:NO限り、新いターミラウindsウを開くか Visual Studio*、Sublime Text*、またはそのほたの C/C++ 工デイチーを起動するたに setvars.bat スクレットが実行いたします。詳細は「シ斯塔ムの設定」(英語)を参照くださいます。

注：設定フィ�ルは、コンボーネnts・デレクtorリ・レイアウの setvars.bat そのみ使用くださいます。統合デレクtorリ・レイアウは、oneapi-vars.bat 使你能用はさ、它は設定フィ�ルをサボーツします。レイアウの詳細にしだは、「Windows* setvars およobi oneapi-vars スケpritを使用」を参照てくだき。

以下に設定フィ�ルを使用て環境変数を管理する方法を説明いたします。

# 3.6.13.1. バーローと構成

一部のイルoneAPI リルは複数バーニングのイnstト一ルがサロトさて。複数バーニンをサロトする リルのデレクトリ一構造は次のうにり標は(デフルトのイnstト一ルを想定し、例とてCONHILRA一を使用し ）。

```txt
\Program Files (x86) \Intel\oneAPI\compiler\  
|-- 2021.1.1  
|-- 2021.2.0  
-- latest -> 2021.2.0
```

例：

![](images/a6f311c62fdbfc16dd650d857d73350306bc64b934d65005a43b6579ae29777e.jpg)

surbのソルには、そのCONPOneNTの最新バーニングフロ先示すlatestと名前のシャト力ットのはる。latest\env\ ダレクトリーツにある vars.bat スケpritは、setvars.bat によて実行さます(デフィルト)。

必要に広て、設定フィ�ルを使用て特定のデレクトリ一を示すよう setvars.batを力スタマイズいたします。

# 3.6.13.2. --config ローマフー—

最上位の setvars.bat スケリ uptは、力スム config.txt フアルを指定する --config ダラメ一タ一を受け入れま。

```batch
$ <install-dir>\setvars.bat --config="path\to\your\config.txt" 
```

設定フィ�ルは任意の名前にするこがてきま�。複数の設定フィ�ルを作成て、さまばまな開発環境やテス卜環境を設定てきま�。例えは、最新バーニングのライランドリを古今バーニュンのCONバイヤーでテストしだいともあまむ。そのうな场合に、setvars設定フィ�ル使用て環境を管理てきま�。

# 3.6.13.3. 設定フィ�ルの例

以下簡单設定フィルの例を示いたします。

# 最新のコンボーネntsをすてローダ

```gitattributes
mk1=1.1  
dldt=exclude 
```

# ただし以下のCONP-onentは除外

default $\equiv$ exclude  
mk1=1.0  
ipp=latest

設定テキストフアルは次の要件に從う必要くださいます。

改行区切了的  
各行は、key=valueのアで構成いたします  
- key には、oneAPI ダイレクトリの最上位 (%ONEAPI_ROOT% ダイレクトリに有的フィルダー)のコンボーネト名を指定いたします。同じ key が設定フィルに複数定義いたしますと、最後の key が優先くださいます以外は無視いたします。  
- value には、コンパ-oneNT・デイレクトリOneの最上位にあるバーニン・デイレクトリ一名を指定いたします。こには、CONP-oneNT・DEILKTURIOneleルに存在する可能性のはヨト力ト (latest と)が含まえます。

- ）、valueはexcludeにたてごもてきま�。こは、指定たkeyのvars.batスリートをsetvars.batスリートで実行しだいとを意味しま�。

key=valueをdefault=excludeにする特別な意味を持ちます。こは、設定フィ�ルに定義いたします。と除き、その以外のsurdeのenv\vars.batスケpritの実行を除外いたします。以下に例所示いたします。

# 3.6.13.4. 設定フィ�ルの力スタマイス

設定FFFFFFL使用。特定のCONP-BNFILを除外た、特定のBUNIONを含った、特定のCONP-BNFILはBUNIONのみを含むとが成長。こには、設定FFFFFFLのdefault=exclude行を変更し。

```
徳オルトのは、setvars.batは最新(latest)のバーニングに対応するenv\vars.batスケリトを处理いたします。

例えは、2つのバーニン(2021.1.1と2021.2.0)のインルoneMKLがインストーリてきい和反定しお。最新のバーニンを示すシャトカットは2021.2.0這樣的た、デバイチはsetvars.batはmklデイク托运一の2021.2.0のvars.batスケpritを実行いたします。

# 2つのバーニングのoneMKLと設定フィ�ル

![](images/1e9ca8717e9b990d6f0080aea0c6182c462debbf190ec6bcffcdb357d64ed847.jpg)

# 特定のバーニンを指定

setvars.batに<install-dir>\mkl\2021.1.1\renv\vars.bat スケリットを実行するように直接記述するには、設定フィ�ルにmkl=2021.1.1を追加いたします。

ごにと、setvars.batは、mkl テルトリ一内の2021.1.1 フ oatルーニにるenv\vars.batスケリトを実行するようにelize。イストートルさてい的その其他コンローナntはは、setvars.batは最新バーニムのフ oatルーニにるenv\vars.batスケリトを実行いたします。

# 特定のコンパーネntsを除外

CONPONTOINTOO 1

```txt
<key>=exclude 
```

例元、INNTELPP 除外。2021.1.1 oneMKL 者次的

```batch
mk1=2021.1.1  
ipp=exclude 
```

二的例是次の上作用し。

- setvars.batは、インル®oneMKL 2021.1.1のenv\vars.batスケpritを実行いたします。  
- setvars.batは、インル® IPPのenv\vars.batスケpritを実行いたします。  
- setvars.batは、そのほたのコンローネnts最新バーニングenv\vars.batスケリトを実行いたします。

# 特定のコンパーネntsを含む

特定のコンボーネnts env\vars.bat スケリトを実行するには、最初にすてのコンボーネnts env\vars.bat スケリトを除外する必要くださいます。その後、setvars.bat 为実行するコンボーネntsを追加し直いたします。次の行動定義て、surdeのコンボーネnts env\vars.bat スケリトを実行から除外いたします。

default $\equiv$ exclude

setvars.bat 1oneMKL and 1Ppのenv/vars.bat SsKlptトのみ実行するには、次の行を追しおて。

default $\equiv$ exclude  
mk1 $= 2021.1.1$ ipp $\equiv$ latest

二的例は次のう作用いたします。

- setvars.batは、インル®oneMKL 2021.1.1のenv\vars.batスケリトを実行いたします  
- setvars.batは、インル® IPPの最新バーニングのenv\vars.batスケpritを実行いたします。

- setvars.batは、そのほかのコンボーネntsenv\vars.batスケpritを実行いたします。

# 3.6.14 Microsoft* Visual Studio* て setvars.bat スケpritを自動化

setvars.bat スケリトは、インル® oneAPI ダールキットを使用するたに必要な環境変数を設定いたします。そのスケリトは、COMANDラーニング开启了最新ターミラルウindsウを開たに実行する必要くださいます。setvars.bat スケリトはまえ、Microsoft* Visual Studio*の起動時に自動的に実行するとまえです。SETVARS_CONFIG 環境変数を使用て setvars.bat スケリトにインル® oneAPI ダール固有の設定を行うように指示いたします。

setvars.bat 为環境變数を設定する方法の詳細にしぃは「Windows* て setvars およこ oneapi-vars スケpritを使用」を参照にしてくだいたします。

# 3.6.14.1. SETVARS_CONFIG 環境变数の状態

SETVARS_CONFIG 環境变数使用、Microsoft* Visual Studio* 的INNSUS为起動にインルoneAPI開発環境を自動のに設定くださいます。環境変数には3つ条件と状態のはいたします。

- 未定義 (SETVARS CONFIG 環境變數が存在くださいます)  
定義さてい的が空(値を含まないか空白のは)  
- setvars.bat 設定フィ�ルを示すように定義

SETVARS_CONFIG が定義いたします、Visual Studio* 起動時に setvars.bat スケリランドは自動実行いたします。SETVARS_CONFIG 環境変数は、インル® oneAPI 元ストーリーにようて定義いたしますのた、こりがデバイ卜動作です。

SETVARS_CONFIG に値が設定いたします空白のみ含むる场合、Visual Studio*の起動時に setvars.bat スケリトは自動のに実行いたします。その场合、setvars.bat スケリトはシステムにインストーリてるすばてのoneAPI ダルの環境を初期化いたします。setvars.bat スケリトの実行の詳細に/Subドラインを使用たsan複ル・プロジUCTのビルドと実行」(英語)を参照てくだい。

SETVARS_CONFIGに setvars 設定フィ Adamの絶対ルが定義いたします。Visual Studio*の起動時にsetvars.bat スクリ uptは自動に実行いたします。その场合、setvars.bat スクリ uptは、setvars設定フィ Adamで定義いたします。 oneAPI ダルの enviの環境を初期化いたします。setvars設定フィ Adamを作成する方法の詳細は、「setvars.batの設定フィ Adamを使用」を参照くださいます。

setvars 設定フィアルは任意のフィアル名にごき、Visual Studio* がその場所とフィアルにアクsesて読み取り可能 REFERる限り、ハーニデスケ上の任意の場所に保存くださいます (Windows* プ斯塔ムにインテル® oneAPI リOneをインスローする際に、Visual Studio* に追加いたします。SETVARSCONFIGのアクsesを実行いたします。そのたわ、Visual Studio*は setvars 設定フィアルの場所にアクsesedium必要くださいます)。

setvars 設定フィ�ルを空のまえにしと、setvars.bat スケリトはステムにインストーリルさてのすばてのイングル® oneAPI ダルの環境を初期化いたします。こはは、SETVARS_CONFIG 变数に空の文字列を定義すると同じです。setvars 設定フィ�ルの定義の詳細にしだは、「setvars.batの設定フィ�ル使用」を参照てくだい。

# 3.6.14.2. SETVARS_CONFIG 環境变数の定義

SETVARS_CONFIG 環境变数は、インストーリル中に自動のに定義くださいます、Visual Studio* 起動する前に(上記の規則に從て)手動で環境変数を定義する必要,Noは Windows*のSETX ミマンド、または Windows* GUI ダルで Win + R キーを押て表示いたします。[rund1132.exe.sysdm.cpl,EditEnvironmentVariables]と入力て定義いたします。

# 3.7 Linux*  setvars  oneapi- vars スクリフトを使用

バーニュ 2024.0は、統合デイレクトリーフレアウトが実装いたします。複数のソルキットのバーニュはインスローせてる场合、統合レクトリーフレアウトに適用開発環境に特定のソルキットのバーニュの一部とてリーフ側さたCONBOTNEINTのバーニュが含むるようにす用機能が実装いたします。

新い統合デレクトリーフレアウは、共通フルダーダ（bin、lib、include、share等）にコンボーネntsがイストートてるごが分かりま。こらの共通フルダーダは、ツールキットのバーニム番号に基しぃて命名さる最上位フルダーダにあきま。以下に例を示しま。

```txt
1. /opt/intel/oneAPI/2024.0/  
2. |-- bin  
3. |-- lib  
4. |-- include  
5. ... 
```

2024.0 原屯前的八一用使用了的。以前的立立立立立立立立立立立立立立立立立立立立立立立立立立立立立立立立立立立立立立立立立

# 3.7.1 メンボーネnts・デレクトリーフレアウトと統合デレクトリーフレアウトの違い

ほんとのイルoneAPIコンボーネntsのモルダには、oneAPI開発作業をサトするそのるトに必要な環境変数を設定するenv/vars.shスケリトが含てては。例えは、デモルトのイストートは、Linux\*のイルIPPのvarsスケリトは、/opt/intel/oneapi/ipp/latest/env/vars.shに配置得很好。そのハスは、env/vars 環境変数設定スケリトを含むてのイルoneAPIコンボーネntsで共有得很好。

CONP-onevent-DFILKUTRI-LEIAWHTは、各CONP-onevent向けのenv/vars SQUEPTは、直接たはまてて鳴出さにかてきま�。まて鳴出さには、INTELoneAPI IINSUTUL-DFILKUTRI一にあるsetvars.sh SQUEPTを使用しま�。こは、Linux* MarshonのDFIUTURのINSTUBルは、/opt/intel/oneapi/setvars.shにありま�。

統合デレクトリ・レイアウは、開発環境の初期化にenv/varstスケリトを使用しません。代わに、各CONP一ネトは、CONP一ネトに共通の共有フツルダに包括さてま。つま、各CONP一ネトは、ハダーフツルを单一の共通インクル一ド・フツルダに提供し、そのライ布拉リ・フツルを单一の共通lib フツルダに提供するごにncyりま。

# 3.7.2 統合デイレクトリーローフ側の利点

統合デイレクトリーチ・レイアウトを使用するとて setvars 設定フィ�ルを構成て維持た、複数のインル®oneAPI メルキットをインストルて個別に環境を作成する必要かく、異なソルキットのバーニングの切り替えがはるかに容易に,GL。も、一部の Windows* 开発者にようて厄介な問題%= Windows* 开発ステムの環境変数、特にPATH変数の長さを制限するにも役立与否。

統合デイレクトリーダ・レイアウの環境変数は、一括のは設定くださいます。環境変数を初期化するには oneapi-vars.sh スクリ uptを使用いたします。Linux* 上のデフィルトの統合デイレクトリーダ・レイアウのインストーリは /opt/intel/oneapi/<toolkit-version>/oneapi-vars.sh に%=は。<toolkit-version>は、インストーリルしたインテル® oneAPI リルキットのバーニフフ番号に対応いたします。以下に例所示いたします。

```txt
/opt/intel/oneapi/2024.0/oneapi-vars.sh /opt/intel/oneapi/2024.1/oneapi-vars.sh 
```

引数不设 setvars.sh スクリ upt to source と、システムにインストーリさての <conp-onevent>/latest/environment/vars.sh スクリ upt to source さは。こらのスクリ upt to source 了後、env conmandを使用て環境変数を確認いたします。

引数なてoneapi-vars.sh スクレットを実行いたします、スクレットが配置いたします。た、統合デイレクトリーナのインストフOneAPI/ootkitversion>/etc/<component>/vars.sh スクレットもsource]{。。。一、oneapi-vars.sh スクレットの実行後のLinux*のenvコマンドで確認いたします。

注: setvars.sh/oneapi-vars スクレット (または個別の vars.sh スクレット) に vigor変更くださいます環境は永続的のはんだん。こりらの変更是、setvars.sh/oneapi-vars 環境スクレットが source たーナルセツドンのは有效です。

oneapi-vars.sh スケリトの仕組みの詳細は、「統合デレクtor一・レイアウの環境変数の初期化」を参照てくだいたします。

# 3.7.3 ペマンドライN引数

setvars.sh スケリPLEはいっかのコマンドライン引数をサボーツて的优点、--help 才預言に引数の一観を表示いたします。

例：

# CONBOP-NEINT·DEILECTRIE-LEYAWT

システム全体のインスロー。

```shell
$ ./opt/intel/oneapi/setvars.sh --help 
```

PLAIBABU环境のINSTUNEL

```txt
$ . ~/intel/oneapi/setvars.sh --help 
```

# 統合デイレクトリーロアウト

システム全体のはんだストOne

```scss
$ . /opt/intel/oneapi/<version>/oneapi-vars.sh --help 
```

PLAIBABET環境のINSTUNEL

```txt
$ . ~/intel/oneapi/<version>/oneapi-vars.sh --help 
```

--config=file 引数和 setvars.sh/oneapi-vars スクリ uptから呼声出さる vars.sh スクリ uptへの追加引数をインクルーニす機能を使用て、環境設定を力スタマイズにしてます。--config=file 才締junctionは、setvars.sh スクリ uptのはみサボーツせます。

--config=file 引数は、特定のインル® oneAPI ニンボーネntsの環境の初期化機能を提供するともに、特定のバーニングの環境を初期化するごまてきます。例えは、インル® IPP 和インル® oneMKLの環境のみを設定するには、こら2つのインル® oneAPI ニンボーネntsの vars.sh 環境スケリトのみを Respirantly setvars.sh/oneapi-vars 斯リトに指示する設定フィ�ルを渡ります。詳細利用例にしぃは、「Linux* たは macOS* で setvars.sh 设定フィ�ル使用」を参照てくだい。

setvars.sh/oneapi-varsのハルフメソーニジに記載いたします。コマンドライnton引数は、vars.shスケpritに渡ります。つまり、setvars.sh/oneapi-vars スケpritが認識:NOOK引数は、CONP一onentのvars.shスケpritで使用くださいますと見なし、その引数をすばてのCONP一onentのvars.shスケpritに渡ります。最初はく使用くださいます引数は、ia32とintel64です。它らは、INTEL®CONPバイヤー、INTEL®IPP、INTEL®oneMKL、およんだンテル®oneTBB ライランドリーダアリケーションのターフット·アーミテクチヤー指示するたけ使用ります。

個々の vars.sh 斯ケリトを調て、受けお願いるコマンドライIN引数のはんだを決定いたします。

# 3.7.4 实行方法

CONBOPENNT·DEILKUTRIE-LEIAWU

```scss
$ source <install-dir>/setvars.sh 
```

統合デイレクトリーロアウト

```txt
$ source <install-dir>/< toolkit-version>/oneapi-vars.sh 
```

注:csh なと非 POSIX* 小ルを使用する场合、次のコマンドを使用しります。

CONBOP-NEINT·DEILECTRIE-LEYAWT

```powershell
$ bash -c 'source <install-dir>/setvars.sh; exec csh' 
```

統合デイレクトリーロアウト

```shell
$ bash -c 'source <install-dir>/<toolkit-version>/oneapi-vars.sh ; exec csh' 
```

環境変数が正し設定いたします、次のよう確認MXSS一は表示いたします。

```batch
initializing oneAPI environment ...
bash: BASH_VERSION = 4.4.20(1)-release
advisor -- latest
ccl -- latest
compiler -- latest
dal -- latest
debugger -- latest
dev-utilities -- latest
dnl -- latest
dpcpp-ct -- latest
dpl -- latest
intelpython -- latest
ipp -- latest
ipcpp -- latest
ipp -- latest
mkl -- latest
mpi -- latest
tbb -- latest
vpl -- latest
vtune -- latest
oneAPI environment initialized :: 
```

工ラーマツーベが表示くださた场合は、インル® oneAPI ダールキットの診断ユーニテリデイを使用てトラTPLシューニングを行てくだき。そのユーニテリデイは、不足してる依存関係や權限工娘一を検出するたなステムチウクを行いま。詳細はこら(英語)を参照てくだき。

たは、modulefiles スクリットを使用て開発環境をセットアツます。modulefiles スクリットは、すてのLinux*シルで動作いたします。

CONP-oneintのリストとそのCONP-oneintのバーニムを調整する场合は、setvars設定フィ�ルを使用て開発環境をセットアフツします。

# 3.7.5 複数の実行

各CONP一派のenv/var.sh スケpritの多は、PATH、CPATH、およんだほたの環境変数に変更を加むた
え、最上位の setvars.sh/oneapi-vars スケpritは同じセソンで同じ vars.shを複数回鳴出さ上ごは成
きません。こはは、特に $PATH 環境変数が原因で環境変数の文字数が長くなすきないようお願いいたします。

ごを強制するには、setvars.sh/oneapi-varsに--force才pronを指定いたします。它的例は、eu一が setvars.sh/oneapi-varsを2回実行いたします。setvars.sh/oneapi-varsがてに実行いたします。2回目的実行は停止いたします。

# CONPONNT·DEILKUTRIE-LEIAWU

```txt
$ source <install-dir>/setvars.sh
initializing oneAPI environment ...
(SNIP: lot of output)
...
code-block:: oneAPI environment initialized .. 
```

```txt
$ source <install-dir>/setvars.sh
WARNING: setvars.sh has already been run. Skipping re-execution.
To force a re-execution of setvars.sh, use the '-force' option.
Using '-force' can result in excessive use of your environment variables 
```

次は、eu一anzaがsetvars.sh --forceを実行し、初期化が成功した例です。

```txt
$ source <install-dir>/setvars.sh --force
initializing environment ...
(SNIP: lot of output)
...
code-block:: oneAPI environment initialized .. 
```

setvars.shを-force引数でソーメすると、次に示すように、bashバーニン3.xおよ4.xで引数污染が発生る可能性のはろ。

```txt
$ source <install-dir>/setvars.sh --force
initializing oneAPI environment ...
(SNIP: lot of output)
oneAPI environment initialized :
$ echo ${@}
advisor=latest ccl=latest compiler=latest dal=latest debugger=latest dev-utilities=latest
dnnl=latest dpcpp-ct=latest dpl=latest app=latest ipcpp=latest mkl=latest mpi=latest
tbb=latest vtune=latest 
```

注: oneapi-vars.sh がbash バーニム 5.x、zsh、ksh、たは dash てソスローる场合、ごは問題にncyません。ご的问题を回避するには、SETVARS.ArgS 環境変数を介てシルのコマンドライン・才予予を渡しま�。

例:

```txt
$ SETVARS Arguments="--force" source <install-dir>/setvars.sh
initializing oneAPI environment ...
(SNIP: lot of output)
oneAPI environment initialized :
$ echo ${@} 
```

# 統合デイレクトリーロアウト

```txt
$ source <install-dir>/<version>/oneapi- vars.sh
.. code-block:: initializing oneAPI environment ...
(SNIP: lot of output)
.. code-block:: oneAPI environment initialized :: 
```

```scss
$ source <install-dir>/< toolkit-version>/oneapi-vars.sh
...
code-block:: WARNING: setvars.sh has already been run. Skipping re-execution.
To force a re-execution of setvars.sh, use the "--force' option.
Using "--force' can result in excessive use of your environment variables 
```

3番目のインスローは、eu一をoneapi- vars.sh --forceを実行すると、初期化が成功いたします。

```txt
$ source <install-dir>/ `oneapi-vars.sh` --force
...
code-block:: initializing oneAPI environment ...
(SNIP: lot of output)
...
code-block:: oneAPI environment initialized : 
```

--force 引数使用着 oneapi- vars.sh 来实行的、次に示うに、bash バーニフ 3.x おば 4.x 为引数污染が発生する可能性のは除外。

```txt
$ source <install-dir>/<toolkit-version>/oneapi-vars.sh --force
initializing oneAPI environment ...
(SNIP: lot of output)
oneAPI environment initialized :: 
$ echo ${@}
advisor=latest ccl=latest compiler=latest dal=latest debugger=latest dev-utilities=latest
dnnl=latest dpcpp-ct=latest dpl=latest IPP=latest ipcpp=latest mkl=latest mpi=latest
tbb=latest vtune=latest 
```

注：oneapi-vars.sh 5.x、zsh、ksh、たはdashでソーさてる场合、ごは問題にわません。ご的问题を回避するには、SETVARS.ArgS 環境変数を介てシルのコマンドライド・才予言を渡ります。

例:

```scss
$ SETVARS Arguments="--force" source <install-path>/<toolkit-version>/oneapi-vars.sh
.. code-block:: initializing oneAPI environment ...
(SNIP: lot of output)
.. code-block:: oneAPI environment initialized ...
$ echo ${@} 
```

# 3.7.6 統合デレクトリーフレアウの環境変数の初期化

統合デイレクトリーダイアウは、2024.0 リリOneapys用」を参照てくさ。

統合デイレクトリーピー・レイアウト環境の初期化は、setvars.sh スケリ uptははなくoneapi-varsスケリトにようて行わる。oneapi-varsの使い方はsetvarsとていま�が、微妙な違いが係む。

setvars スケリトと oneapi-varsの主な違は、setvarsは環境変数(ONEAPI_ROOTを除く)を定義しませなか、oneapi-varsは共通の環境変数を定義するとです。

CONP-NEINT·DILKUTRI·REIAWUTは、各CONP-NEINTが機能するたに必要な環境変数を定義しま。例えは、CONP-NEINT·DILKUTRI·REIAWUTはは、各CONP-NEINTはLIANT可能なLAIBLAR一·FOLDALEtoLD LIBRARY PATH に、ててハSSDALE to CPATH に追加しま。CONP-NEINTは、常に次の場所に有的vars StKlPTb to介てこ等を実行しま。

```shell
$ ONEAPI_ROOT%/<component-name >/<component-name>/env/vars.sh 
```

統合デイレクトリーベイアウトは、外部向けの include、lib、bin フオルダーを共有フツルダーに統合します。最上位レBELの oneapi-vars スケpritは、こらの共通フツルダーを検出るに必要な環境変数を定義ります。例には、setvarsはLD.Library_PATHを$ONEAPI_ROOT/libとて定義し、CPATHを$ONEAPI_ROOT/includeと定義いたします。

modulefileは2024.0リーリス付けきサボーパー、setvars.shを使用て環境設定を初期化する代わに使用くださいます。modulefileスケpritはLinux*のみサボーパーいたします。

# 3.7.7 ONEAPI_ROOT 環境变数

ONEAPI_ROOT 環境変数は、スケリトが実行いたしますときに上位の setvars.sh お願いoneapi- vars.sh にようて設定いたします。ONEAPI_ROOT 環境変数は設計得很好場合、setvars.sh または oneapi- vars.shスケリトはその上書いたします。その変数は、oneapi-cli サンpluralラウzfーと Eclipse* お願い Visual Studio* Code サンpluralラウzfーによて使用いたします、インテルoneAPI リルとコンボーネntsの検出、お願いSETVARS_CONFIG 機能が有効くださる场合に setvars.sh 斯ケリトを検出のはに役立与否。SETVARS_CONFIG 機能の詳細に/Subは「Eclipse* で setvars.sh 斯ケリトを自動化」を参照到这里くだいたします。

2024.0 リリーフードは、インストーラーは、インストーラーは ONEAPI_ROOT 環境変数を追加いたします。亿吨をデフルト環境に追加するには、ロ一カルシエルの初期化フィ�IL(.bashrc ）、たは /etc/environment フアAILで ONEAPI_ROOT 变数を定義いたします。

# 3.7.8 Linux* 为 setvars.sh 設定uallylを使用

注：2024 リリ奥斯以降のは、macOS*はインテルoneAPI リルキットお願いコンボーネntsでサボートいたします。インテルoneTBBやインテルImplicitSPMD Program Compilerない、いっかの才一フUNソス・プロジ乌克トは、引き続きAppleシリCON上の macOS*をサボートります。他的ツルへのサボートを擴大するた、貢献者的方々と協力する機會を歡迎しります。

Linux* 为環境設定的可以、次の2つ方法のはんだ。

- ごの亜一ジで示すように、setvars.sh設定フィ�ルを使用いたします。  
- modulefile 为使用以下。

注：設定ogueルは、CONP-NEINT·dELEKTRI-LEIAWUTの setvars.sh ての使用�能ま。統合dELEKTRI-LEIAWUTは、oneapi-vars.sh 使用しはが、它は設定fALILをsabootomset。REIAWUTの詳細についは「Linux* C setvars およ oneapi-vars sKlEETo使用」を参照てくさ。

setvars.sh スクリ uptは、そのOneAPI ヨルクットにある <install-dir>/latest/env/vars.sh スクリ upt to source 這一と、イデル oneAPI ダールキットで使用する環境変数を設定します。setvars.sh スクリ upt to 自動のに source しぃうに Linux* ラステムを設定ない限り、新いターニーマルウindsウを開くか Eclipse* またはそのほらかの C/C++ IDE もエデイターニを起動する前に source しぃる必要くださいます。詳細は、「システムの設定」(英語)を参照てくだいたします。

次に設定フィ�ルを使用て環境変数を管理する方法を説明いたします。

# 3.7.8.1. バーヨンと構成

一部のイ�ntル® oneAPI リールは複数バーニングのイストートがサポトelizeます。複数バーニングのサポトするツルのデレクトリ一構造は次のようにelizeます。

```txt
intel/oneapi/compiler/  
|-- 2021.1.1  
|-- 2021.2.0  
`-- latest -> 2021.2.0
```

# 例：複数Bayon与環境變數

```txt
$ ls -l intel/oneapi/compiler/
total 8
drwxr-xr-x 8ubuntuubuntu 4096 Nov 9 2020 2021.1.1/
drwxrwxr-x 8ubuntuubuntu 4096 Apr 9 10:06 2021.2.0/
lrwxrwxrwx 1ubuntuubuntu 8 Apr 9 10:06 latest -> 2021.2.0/
$ 
```

surbellofouerlには、そのconnofo一neintofo最新八一的instol先示s latestと名前のsonboIck-1nKがあま。latest/environment/ DrelkTl一有者 var.s.sh StkLrptb=setvars.sh に去t source

必要に広て、設定フィ�ルを使用て特定のデレクトリ一を示すようsetvars.sh 力スタマイズ你能ま。

# 3.7.8.2. --config パラメータ一

最上位の setvars.sh スケリトは、力stsム config.txt フアルを指定する --config バラメーローを受け录入 MSR。

```powershell
$ source <install-dir>/setvars.sh --config="full/path/to/your(config.txt"
```

設定フィ�ルは任意の名前にするこがてきま�。複数の設定フィ�ルを作成て、さまばまな開発環境やテス卜環境を設定てきま�。例えは、最新バーニュンのライランドリーを古今バーニュンのCONNハーナーでテストしだいともありま�。そのうな场合に、setvars設定フィ�ル使用て環境を管理てきま�。

# 3.7.8.3. 設定フィ�ルの例

以下簡单設定フィルの例を示いたします。

# 最新のコンボーネntsをすてローダ

```gitattributes
mk1=1.1  
dldt=exclude 
```

# ただし以下のCONP一ネトは除外

default $\equiv$ exclude  
mk1=1.0  
ipp $\equiv$ latest

設定テキストフアルは次の要件に徃う必要くださいます。

改行区切了的  
各行は、key=valueのアで構成いたします  
·keyには、oneAPI ヨレクトリの最上位（$ONEAPI_ROOT ヨレクトリにあるフィルダー）のコンボーナ卜名を指定いたします。同じkeyが設定フィルに複数定義いたします。最後のkeyが優先いたします。  
- value には、コンパーネnts・デレクtor一の上位にるバジヨン・デレクtor一名を指定いたします。こには、CONPOMINCTLEKUTERIのレルに存在する可能性のはト力ト（latest）が含まれります。

- ）、valueはexcludeにするとも成長。こは、指定たkeyの環境変数Stvrtbsetvars.shStvrtbforsourceいを意味し。

key=valueをdefault=excludeにする特別な意味を持ります。这也、設定フィ�ルに定義いたしますのを除き、その以外のsurdeのenv/vars.shスケpritのsourceを除外いたします。以下例を示いたします。

# 3.7.8.4. 設定フアルの力スタマイズ

設定フィ�ルを使用て、特定のコンパーネntsを除外た、特定のバーニューニを含った、特定のCONPPOーネntsのバーニューニのみを含む或いはごはう。こには、設定フィ�ルのdefault=exclude行を変更しま。

defolut=、setvars.sh|是最新(latest)のバーニンに対応するenv/vars.shStkrlptbto处理。

例えは、2つのバーニン2021.1.1と2021.2.0)のイングルoneMKLがイングスローは和定しま。最新のバーニンを示すsymlinkは2021.2.0earingた、デフィルトはsetvars.shはmkl ダレクットーの2021.2.0のvars.shスケpritは実行,Th。

# 2つのバーニングのoneMKLがインストーリてる场合

```shell
$ /usr/bin/tree -dL 2 --subset=ascii intel/oneapi/mkl/intel/oneapi/mkl/
-- 2021.1.1
| -- benchmarks
| -- bin
| -- documentation
| -- env
| -- examples
| -- include
| -- interfaces
| -- lib
| -- licensing
| -- modulefiles
| -- tools
-- 2021.2.0
| -- benchmarks
| -- bin
| -- documentation
| -- env
| -- examples
| -- include
| -- interfaces
| -- lib
| -- licensing
| -- modulefiles
| -- tools
-- latest -> 2021.2.0 
```

# 特定のバーニンを指定

setvars.sh |<install-dir>/mk1/2021.1.1/env スケリットを source するよう直接記述するには、設定 フAIRILにmk1=2021.1.1を追しぎいたします。

这样一来、setvars.shは、mk1 ヨルクトリーリ内部の2021.1.1 フオルダにあ源env/vars.shスケリトをsourceするようお願いいたします。インストーリて出来的mk1以外のコンパーネntsはは、setvars.shは最新バーニングのフィルダにあ源env/vars.shスケリトをsourceします。

# 特定のコンパーネntsを除外

CONP一不卜を除外する構文は次のうになま。

<key $z =$ exclude

例えは、インル® IPPを除外て、2021.1.1のインル®oneMKLを含むには次のようお願いいたします。

```batch
Mkl=2021.1.1  
ipp=exclude 
```

它的例是次的上作用。

- setvars.shは、イnton®oneMKL2021.1.1のenv/vars.shスケリトをsourceにまむ。  
- setvars.shは、イデル®IPPのenv/vars.sh スケpritをsourceにません。  
- setvars.shは、そのほたのルト最新バーニンのenv/vars.shスケpritをsourceに。

# 特定のコンパーネntsを含む

特定のコンボーネntsのenv/vars.sh スクリ uptをsourceは、最初にすてのコンボーネntsのenv/vars.sh スクリ uptを除外する必要くださいます。その後、setvars.shでsourceるコンボーネntsを追しぃ直しります。次の行を定義て、すばてのコンボーネntsのenv/vars.sh スクリ uptをsourceから除外いたします。

default $\equiv$ exclude

例えは、setvars.sh がイングル® oneMKL 和イングル® IPP フローにの env/vars.sh スケpritのみを source するようお願いいたします。

default $\equiv$ exclude  
mk1 $= 2021.1.1$ ipp $\equiv$ latest

它的例是次的上作用。

- setvars.shは、インテルoneMKL2021.1.1のenv/vars.shスケpritをsourceにいたします。  
- setvars.shは、インル®IPPの最新バーニングのenv/varsshスケリトsourceとります。  
- setvars.shは、そのほたのコンボーネnts env/vars.sh スケpritをsourceにません。

# 3.7.9 Eclipse* て servars.sh スケpritを自動化

setvars.sh スクリPLEは、インル® oneAPI リルキットを使用するたに必要な環境変数を設定いたします。そのスクリPLEは、コマンドラーニン開発向けに新いターマルウindsわ开くたに実行する必要くださいます。setvars.sh スクリPLEは、Eclipse*の起動時に自動のに実行するご本文き).(SETVARSCONFIG 環境変数を使用て、setvars.sh スクリPLEは、インル® oneAPI リル固有の設定を行うように指示いたします。

setvars.sh 为環境變数を設定する方法の詳細は「Linux* 为 setvars 予約 oneapi- vars スケリフット使用」を参照てくだいたします。

# 3.7.10 SETVARS_CONFIG 環境变数の状態

SETVARS_CONFIG 環境変数を使用て、C/C++ 开発者向けの Eclipse* IDE 元stansを起動たきにイnteloneAPI開発環境を自動的に設定,No3つ条件と状態のはむ。

- 未定義 (SETVARS_CONFIG 環境變數是否存在’)  
定義さてい的が空(值を含まないか空白くださ)  
- setvars.sh 設定フィ�ルを示すように定義

SETVARS_CONFIG に值が設定くださいます (空白のみが含むる) 場合、Eclipse* 的起動時に setvars.sh スケリ公益活动は自動的に実行いたします。その场合、setvars.sh スケリ公益活动はステムにインストーリングするすばての oneAPI ダルの環境を初期化いたします。setvars.sh スケリ公益活动は詳細に付けは「Eclipse* 使用したサングル・プロジックのビルドと実行」(英語)を参照にしてくださいます。

SETVARS_CONFIG | setvars 設定フィAMILへの絶対バスが定義いたします。Eclipse*の起動時にsetvars.sh スTriviaは自動のに実行いたします。その场合、setvars.sh スTriviaは、setvars 設定フィAMILで定義いたします。['Linux*で setvars.sh お願い oneapi-vars スTriviaは使用」を参照くださいます。

注：Eclipse* そのデバイルの SETVARS_CONFIGの動作は、Windows*のVisual Studio*で説明いたします。Eclipse*を起動いたします、setvars.sh スケpritは常に自動のに実行いたします。Windows*でVisual Studio*を起動いたします、SETVARS_CONFIG環境変数が定義いたします。场合にごsetvars.bat スケpritは自動のに実行いたします。

setvars 設定フィアルは任意の名前で作成 Kg、そのフィアルが Eclipse* からアクsesおよこむ取か可能のは限りハーニデスム上ごにても保存 Kgま� (Linux* プ斯塔ムにイ�ntル® oneAPI リルをイングトートしときにEclipse* に追加さた的テガSETVARS_CONFIGのアクschonを実行するた、Eclipse*は setvars設定フィアルにアクsesを必要かた。

setvars 設定フィ�ルを空のまえにすると、setvars.sh スケpritはシスチムにインストーリルのはんだ領域のイングル® oneAPI メルの環境を初期化いたします。这一年は、SETVARS_CONFIG 变数に空の文字符を定義すると同時お願いいたします。setvars 設定フィ�ルの作成方法に/Subは「Linux* 为 setvars.sh 予約 oneapi-vars スケpritを使用」を参照してくださいます。

# 3.7.11 SETVARS_CONFIG 環境变数の定義

SETVARS_CONFIG 環境変数はインストーリル中に自動のに定義くださいます、Eclipse*を起動する前に(前述の方法で)環境変数を追加する必要,Noは、SETVARS_CONFIG 環境変数は以下を含むさまごま場所を定義いたします。

```txt
/etc/environment /etc/profile \~/.bashrc 
```

上記の例は、Linux* プ斯塔ムで環境変数を定義する一般的場所です。SETVARS_CONFIG 環境変数に定義する場所は、ロ斯塔ムとニーフにようお願いいたします。

# 3.8 Linux* 为毎日ルフ�川使用

modulefile 为環境を設定する、使用するコンパ{-NEINTの的確なバーニンを指定いたします。

Linux* 为環境を設定するには、次の2つ方法のはんだ。

- ごの亜一地説明てい的状に modulefileを使用いたします。  
- setvars.sh 設定フィ�ルを使用いたします。

ほんんだのインル® oneAPI ニンボーネntsのフィルダーには、そのるのCONPIONトに必要な環境変数を設定する modulefileのスケリトが含まてご。modulefileを使用て、setvars.sh スケリトに代わて開発環境を設定elize。modulefileは引数がサロトさていた。複数の設定(32 ビットや64 ビットの設定吃什么)をサロトするインル® oneAPI メOneItおよじライフリーツはは複数のmodulefileを使用し。

注: プンテル® oneAPI メーリルキットで提供いたします modulefileは、Tcl 環境モジュール(Tmod)的优点 Lua 環境モジュール(Lmod)と互換性のは、次のバーケンがサボートいたします。

Tmod 4.2   
Tcl 萬一 8.4  
Lmod 菜一 8.7.44

次のコマンドを使用て、ステムにインストーリートるバーグフンを確認いたします。

```powershell
$ module --version 
```

各 modulefileは、実行時にシステムのTclバーニンが適切くださいますか自動のに確認いたします。

```txt
$ tclsh
$ puts $tcl_version
8.6
$ exit 
```

各 modulefile 是、実行時にシステムの Tc1 バーニュンを自動的に検出来が、Tmodの バーニュンは確認いたします。

modulefileのバーニュンがサボーツセ不出来場合(4.2以前)、回避策のはんだ。詳細にては「インテル開発ツルに付ける環境モジュルの利用」(英語)を参照てくだい。

インル® C/C++ ニンバイヤー・ケラシック (icc)はインル® oneAPI 2024.0 リリローが廢止いたします、iccの modulefileは削除いたします。代替とて、インル® oneAPI C/C++ ニンバイヤー・ (icx お願い ifx)を使用くださいます。インル® Fortran ニンバイヤー・ケラシック (ifort)はインル® oneAPI 2025.0 リリローが廢止 ,(1)了下来。代替とて、インル® Fortran ニンバイヤー・ (ifx)を使用くださいます。

# 3.8.1 毛ジーフルフバイル自動口一ド

環境モジュル(Tmod)の「自動ローリ」機能は、modulefiles バeer�4.2の実験の機能と導入いたしますが、5.0リリーベスで標準機能なります。インテルoneAPI ダルキット 2024.0 バeeriousは、依存モジュルフィ��ルの自動ローリは自動ローリ機能に依存するようお願いいたします。環境モジュルのバeer�4.xを使用くださいます场合、依存モジュルフィ��ル(prereqコマンドで参照くださるフィ��ル)の自動ローリ機能はデモルトで無効に,Noethます。バeer�5.xは、依存モジュルの自動ローリがデモルト有效です。

oneAPIのmodulefile スクレットは、その態のコンパーネnt・デバイ克莱リにある modulefiles フィルダにごります(個々のvarsスクレットの配置と同様)。例えは、インル® oneAPI メールルキット2024.0以降のデバイルのインスローは、コンパイヤラの modulefile スクレットは、/opt/intel/company/<component-version>/etc/modulefiles/デバイ克莱リにごります。インル® oneAPI メールルキット2023以前のは、CONPVAIラの modulefile スクレットは/opt/intel/company/<component-version>/modulefiles/デバイ克莱リにごります。

自動口一、機能を制御するには、MODULES_AUTO_HANDLING環境変数を使用て、参照くださいます前提条件モジフーリルフィルを自動口一、用上にモジフーリルフィルに指示いたします。その動作は、--auto フマンドライフクフフフフフフフフフフフフフフフフフフフフフフフフフフフフフフフフフフフフフフフフフフフフFTFFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTFTA

- MODULES_AUTO_HANDLING=1は、prerequisiteコマンドによる自動口一を有効にいたします。  
- MODULES_AUTO_HANDLING=0は、prerequisiteコマンドによる自動口一ドを無効にしります。

「HINT: the following module must be loaded first (ヒnst: 次のモジローを最初にローダする必要が)”」とエラーマツロー表示くださた场合、前提条件コマンドの自動ローダを有効にするた、MODULES_AUTO_HANDLING=1 環境変数を追加するか、モジロー環境を設定て auto_handleng 构成を「1」に設定必須のはんだ。

```txt
1. $ module -V
2. Modules Release 4.4.1 (2020-01-03)
3.
4. $ module use /opt/intel/oneapi/2024.1/etc/modulefiles/
5. $ module load compiler
6. Loading compiler/2024.1.0
7. ERROR: compiler/2024.1.0 cannot be loaded due to missing prerequisite.
8. HINT: the following module must be loaded first: tbb 
```

ごの問題は、以下のいりかの方法で解決いたします。

auto_handleing 1. 设定的コマンドを実行いたします。

```txt
1. $ module config auto_handle 1
2. $ module load compiler
3. Loading compiler/2024.1.0
4. Loading requirement: tbb/2021.12 compiler-rt/2024.1.0 oclfpsa/2024.1.0 
```

MODULES_AUTO_HANDLING=1を設定お願い。

```txt
1. $ export MODULES_AUTO_HANDLING=1
2. module load compiler
3. Loading compiler/2024.1.0
4. Loading requirement: tbb/2021.12 compiler-rt/2024.1.0 oclfpsa/2024.1.0 
```

依存関係を手動で口一ドします。

```shell
1. $ module load tbb compiler-rt oclfpsa compiler --verbose
2. Loading tbb/2021.12
3. Loading compiler-rt/2024.1.0
4. Loading oclfpsa/2024.1.0
5. Loading compiler/2024.1.0 
```

詳細にしだは、MODULES_AUTO_HANDLINGを参照てくた。

# 3.8.2 テVeてのモジ�ルフィルを口一卜する

2024.0 リリ奥斯の時点のは、intel/oneapi/2024.0に oneapi 這個名前の「すばてをローダする」モジュルフィアルありがとう。oneapi ミジュルフィアルは、使用可能性をもてのモジュルフィアルをローダし、前述のMODULES_AUTO_HANDLING=1 環境変数に依存sezに、すばての前提条件モジュルも正い順序でローダするようにしおる。こは、Lmod ミジュルフィアル・システム使用いたします。インストーツに intel/oneapi/2024.0デイレクトリ一が含まえない场合は、インテルoneAPI バー・ツルキットやインテルHPC ミルキット等诸多ツルキットのインストーツー使用て製品をインストーツします(ツルキット全体をインストーツし場合は、力スタマイズ・オプロDHONを選択します)。oneapi ミジュルフィアルの主な機能は、ツルキット・バーダヨNに固有關モジュルフィアIL(例:intel/oneapi/2024.0或intel/oneapi/2024.1等)のみをローダするごてです。

# 3.8.3 特定のモジロールフィiralを口一ドする力stsム·モジロールフィiralを作成

□一卜さるモジヨルフィAILをさに制御するには、特定のモジヨルフィAIL·せット(およんだ前提条件）を□一卜説「×夕」モジヨルフィAILを作成ります。例えは、インテル® フンハーリラのみをせットアフリする環境が必要な场合は、次のうなフィAILを作成ります。

```txt
1. module load tbb  
2. module load compiler-rt  
3. module load oclfpga  
4. module load compiler 
```

# 3.8.4 毛ジヨルフAIMル・スケリトの場所

oneAPI 毛ジロー菲尔・スケリトは、各コンポーネnts フオルダー内分泌modulefiles ダレクットリーリローにあらます(個々の varsスケリトが配置くださいます場所と同様)。例えは、インル® oneAPI メルキット2024.0以降のデフィルトのインスケリルは、CONBAILAR-modulefiles スケリトは/opt/intel/compiler/<component-version>/etc/modulefiles/ ダレクットリーリローにあらます。インル® oneAPI メルキット2023以前のは、CONBAILAR-modulefiles 斯ケリトは/opt/intel/compiler/<component-version>/<modulefiles/ ダレクットリーリローにあらます。

注：<component-version>は、コンパーネnts(ライランドリーマ)(はル)のバジフ番号です。開発ステム上に複数のCONP一トが同時にインストールせてる场合のはんだ(例えは、compiler/2023.1、compiler/2023.2、compiler/2024.0等)。CONP一トが含むるツルキットのバジフは、そのツルキット所提供给你们CONP一トのバジフは異なとお願いいたします。

```
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
``}
```
```
```
```
```
```
```
``}
``}
``}
``}
``}
``}
``}
``}
``}
``}
``}
``}
``}
``)
``}
``}
``}
``}
``}
``}
``}
``}
``}
``}
``}
``}
``}
``}
``}
``}
``}
``}
``}
``}
``}
``}
``}
``}
``}
``}
``}
``}
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``)
``>
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
```cpp
`'
`'
`'
`'
`'
`'
`'
`'
`'
`'
`'
`'
`'
`'
`'
`'
`'
`'
`'
`'
`'
`'
`'
`'
`'
`'
`'
`'
`'
`'
`'
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`"
`")
.
{
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    */
    ;
    */
    ;
    */
    ;
    */
    ;
    */
    ;
    */
    ;
    */
    ;
    */
    ;
    */
    ;
    */
    ;
    */
    ;
    */
    ;
    */
    ;
    */
    ;
    */
    ;
    */
    ;
    */
    ;
    */
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
    ;
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
;
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
;
.
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
?
;
;
;
>
;
>
;
>
;
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
?
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
\...
		\...
		\...
		\...
		\...
		\...
		\...
		\...
		\...
		\...
		\...
		\...
		\...
		\...
		\...
		\...
		\...
		\...
		\...
		\...
		\...
		\...
		\...
		\...
		\...
		\...
	\/opt/intel/
			oneapi/modulefiles-setup.sh に配置得很好。
			/opt/intel/
			oneapi/modulefiles-setup.sh に配置得很好。

modulefiles-setup.sh スケリットは、インル® oneAPIのインストーリに含むるすばての modulefile スケリットを検索し、その方面的フィルダを单一デバイクUTリに保存いたします。

ごれらのバーニューベ管理くださ的高度 modulefile スクリ uptは、它那 modulefiles-setup.sh スクリ uptで配置さが modulefileを指すシングロリク・リングケです。各CONP一onent・フルダーには、少なくとまlatest(最新)バーニューニのmodulefileが含まえ、バーニューニを指定しおてもデフィルトで最新のCONP一onentをローツてきま�。modulefiles-setup.shスクリ uptの実行時に--ignore-latest才予予用説或、module_loadコマンドでバーニューニが指定せてい場合、最也高いsemverバーニューニのmodulefileが口一ドさま。

インル® oneAPI メルキット 2024.0 以降のインストロー・レイアウト内にツルキットのバーニューニ中央空调るすばてのコンボーネntsのモジゲルフアイルを含む modulefiles フオルダー持ちます。例えは、インル® oneAPI メス・ツルキット 2024.0 言DFOLトの場所にインストロー・事前構成くださいますかに利用uable イNTEL® oneAPI メス・ツルキット 2024.0のモジゲルフアイルのコレクschonが/opt/intel/oneapi/2024.0/etc/modulefiles フオルダー配置いたします。こはは、そのフィルダーをMODULEPATH 環境変数に追加いたします。module useコマンド使用て事前構成くださ过的 modulefile フオルダー指定て、modulefilesに追加,No)=(2024.0をインストロー・2つのツルキットのバーニューニ中央空调るたわ(ごはは2024.0)、追加のモジゲルフアイルは同じ場所に配置いたします。

事前構成了一ルクトの modulefiles フオルダー内には、そのルクトのバーニンに含てる64 ビット・コンボーナntドのモジヨルフアイルをローダするoneapi とい名前のモジヨルフアイルのはんだ。oneapi ボジヨルフアイルを使用すると、個別のモジヨルフアイルを使用する必要はあらません。た、oneapi ボジヨルフアイルは、modulefiles-setup.sh スケリトで作成了一ルクト内は期待するように動作しぃせん。

# 3.8.5 modulefiles ヨレクトリの作成

modulefiles-setup.sh スケpritを実行いたします。

```
デ fasルトのは、modulefiles-setup.sh スケリ uptは、インテル® oneAPI ダルキットのインストーリル・ fasルダロー modulefiles 這個名前の fasルダロー作成ります。インストーリル・ fasルダローが書きお願い可能,No対応場に、--outputdir=<fasルダローのバス> 才予言を使用て、書きお願い可能性場所に modulefiles・fasルダロー作成ります。modulefiles-setup.sh スケリ uptの詳細にしだは、modulefiles-setup.sh -helpを入力して確認いたします。

modulefiles-setup.sh スケリランドが実行いたします。、次のような階層が最上位の modulefiles フoorルダに作成いたします (modulefilesの正確なリスはインストーリルによる異なります)。その例のは、インテル® Advisor環境を設定する1つの modulefileと、コンパloyer一環境を設定する2つの modulefileくださいます(CONPILAROne modulefileは、surdeのInnelcur・CONPILAROneの環境を設定ります)。最新のSONPOMLACK-LLINKをたedlyし、semverの規則に従て最上位バーエンのmodulefileを指いたします。

```txt
-- advisor
| -- 2021.2.0 -> /home/ubuntu/intel/oneapi/advisor/2021.2.0/modulefiles/advisor
| -- latest -> /home/ubuntu/intel/oneapi/advisor/latest/modulefiles/advisor
| -- ccl
| -- 2021.1.1 -> /home/ubuntu/intel/oneapi/ccl/2021.1.1/modulefiles/ccl
| -- 2021.2.0 -> /home/ubuntu/intel/oneapi/ccl/2021.2.0/modulefiles/ccl
| -- latest -> /home/ubuntu/intel/oneapi/ccl/latest/modulefiles/ccl
| -- clkck
| -- 2021.1.1 -> /home/ubuntu/intel/oneapi/clck/2021.1.1/modulefiles/clck
| -- latest -> /home/ubuntu/intel/oneapi/clck/latest/modulefiles/clck
| -- compiler
| -- 2021.1.1 -> /home/ubuntu/intel/oneapi/modifier/2021.1.1/modulefiles/modifier
| -- 2021.2.0 -> /home/ubuntu/intel/oneapi/modifier/2021.2.0/modulefiles/modifier
| -- latest -> /home/ubuntu/intel/oneapi/modifier/latest/modulefiles/modifier
| -- compiler-rt
| -- 2021.1.1 -> /home/ubuntu/intel/oneapi/modifier/2021.1.1/modulefiles/modifier-rt
| -- 2021.2.0 -> /home/ubuntu/intel/oneapi/modifier/2021.2.0/modulefiles/modifier-rt
| -- latest -> /home/ubuntu/intel/oneapi/modifier/latest/modulefiles/modifier-rt
| -- compiler-rt32
| -- 2021.1.1 -> /home/ubuntu/intel/oneapi/modifier/2021.1.1/modulefiles/modifier-rt32
| -- 2021.2.0 -> /home/ubuntu/intel/oneapi/modifier/2021.2.0/modulefiles/modifier-rt32
| -- latest -> /home/ubuntu/intel/oneapi/modifier/latest/modulefiles/modifier-rt32
| -- compiler32
| -- 2021.1.1 -> /home/ubuntu/intel/oneapi/modifier/2021.1.1/modulefiles/modifier32
| -- 2021.2.0 -> /home/ubuntu/intel/oneapi/modifier/2021.2.0/modulefiles/modifier32
| -- latest -> /home/ubuntu/intel/oneapi/modifier/latest/modulefiles/modifier32 
```

ごこ、MODULEFILESPATHを更新て、modulefiles-setup.sh スケリットで作成た新い modulefiles フィルダ一に含るか、moduleuse <folder_name>コマンドを実行いたします。

# 3.8.6 プステムにTclモジュールフアル環境をインストーリ

次の手順は、Ubuntu* 为環境モジュール·ユーダリテイ一を実行する例を示いたします。module フーテリテイ一のインストーリルと設定の詳細にしだはは、http://modules.sourceforge.net/ (英語)を参照くださいます。

環境在設定にま�。

```txt
$ sudo apt update
$ sudo apt install tcl
$ sudo apt install environment-modules 
```

tclshのロ一力ルコビ一が新いものoledこを確認しま�(サボトさてるバーニンにては、そのバーニジの最初を参照てくだ)”。

```shell
$ echo 'puts [info patchlevel] ; exit 0' | TCLsh 8.6.8 
```

moduleのインストーリルをデスするには、module工イリアスを初期化いたします。

```txt
$ source /usr/share/modules-init/sh
$ module
```

注：POSIX互換シル領域modules files環境の初期化は、上記のsourceコマンドで機能するはすです。たて、モジロールフィ�ルinit フオルダの正確な場所と名前は、Linux* ダイストリビューニnhによて異ります。環境モジロールのはんだインストーリルは、modulefiles初期化スケリト /etc/profile.d/modules.shが自動的にソー化いたします。moduleコマンドが適切に初期化いたします。そのコマンドは、次のよう広答を返いたします：Modules Release 4.4.1 (2020-01-03)。その時点で、次のセクIJONに示ように、システムは moduleコマンドを使用する準備が電子郵件はすです。

# 3.8.7 modulefiles-setup.sh スケripsトの使用

次のとが前提とていま�。

Linux*開發ShstEmにtclshがイnstトルさてい  
- プーニスデムに環境モジロール・デイリデイー (module 争创)がインストートさて出来的  
- init メマンドで …/modules/start/sh(たは等価なシル)が source ENGINEER  
- oneAPI開発に必須のイデル®oneAPI リルキットがイドストーリさてい

インストーリル・デイレクトリーツに移動て tbbを口一ドします。

```txt
$ cd <oneapi-root folder> # oneapi_root 汪斯卡尔·德雷克卡里尼以移動する
$. /modulefiles-setup.sh # modulefile 設定スケリトを実行する
$ module use modulefiles # 上記に作成した modulefiles フオルダーを使用する
$ module avail # tbb/X.Y 无论如何表示いたします
$ module load tbb # tbb/X.Y マジュールをローユ
$ module list # バートleted tbb/X.Y マジュールをリスト
$ module unload tbb # 環境から tbb/X.Yの変更を削除
$ module list # tbb/X.Y 環境変数モジュールがリストくださいます
```

an口一的前env可mand为使用到环境来检证口一的modulefile 之变更了部分探。

```txt
$ env | grep -i "intel" 
```

例えは、次のコマンドを実行すると、ロードんだ tbb modulefile て変更くださ过的環境の一部分が表示いたします (modulefileを調ごてすての変更を確認いたします)。

tbbをアンローダします。

```txt
$ module unload tbb # tbb/X.Yの変更を環境から削除する
$ module list # tbb/X.Y env var ミジローをリスiblyようお願いいたします
```

注: modulefile 是スケリトです。デーフローはんだルはリーナリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリrl に、x(実行可能)權限を設定する必要はあらてん。 ハンテル® oneAPI ダルキットのイングストーリルには、modulefile パンターツーツーロは含まてていなた、個別にイングストーリルする必要くださいます。同様に、modulefile には w 概限は必要さはませんが、読み取り可能のはう必要くださいます(r 概限をすばてのイング思维方式設定いたします)。

# 3.8.8 ローダン管理

```python
inntel® oneAPI リルキットのインストーラーは、バーニュンフィルダーを使用て、インテル® oneAPI リルとライランドリOne共存を可能に理由ます。modulefiles-setup.sh スケリ uptはバーニュン管理くださたコングローネnts・フィルダーを使用て、バーニュン管理くださた modulefile 作成ります。modulefiles 出力フィルダーに [<modulefile 名>/バーニュン] 和さシングロック・リングクが作成いたします。moduleコマンドの使用時にそその modulefile 考慮に参照,Thirdly.

```scss
$ module avail
__________ modulefiles
ipp/1.1 ipp/1.2 compiler/1.0 compiler32/1.0 
```

# 3.8.9 複数のモジロールフィiral

ル或拉伊stra一は、modulefiles フルダ一内に複数の modulefileを持つ场合のはむ。它那が口一可能Mド一川にら。展開たCONP-NEINT-FILDA一ごに八一JONが割り当てら。

# 3.8.10 oneAPI 为使用使用的モジュールフアルの記述法を理解する

modulefiles-setup.sh 斯克利トはシングリク·リンクを使用て、すばての modulefileを modulefiles
florulダ一に集約いたします。実際の modulefileは移動たは変更いたします。そのたも、
${ModulesCurrentModulefile} 变数には、その橈のインストーリル・florulダ一にある実際の modulefile
てはなか、各 modulefileごの symlinkが格納いたします。各 modulefileは、次のよう等形式を使用て、その
のインストーリル・デイクtor一にある元の modulefileごの参照を取得いたします。

```txt
[ file readlink ${ModulesCurrentModulefile} ] 
```

它是、実際のインストーリル場所はカスタマイズによるため、実行時に不明,No排測する必要くださいます。実際のmodulefileはインストーリル satisfactionist場所以外に移動するとは可以ません。うしおい上、構成に必須なライフラリーダアフリケーニンの絶対ハスを検出いただけなようお願いいたします。

さらに詳しく理解するには、インストーリルに含まる modulefileを確認てくだい。ほんんだの场合、実際のフィ�ルへの symlinkを解決する方法のCOMNTと、バーグヨン番号(およばバーグヨン・デイレクトリ一)の解析が含まるま�。  
ま、インストーリルせたTCLが適切なバーグヨン%=あを確認するチラクも含まるていま�。

# 3.8.11 開連情報

modulefileの詳細にしだは、以下を参照てくだい。

http://www.admin-magazine.com/HPC/Articles/Environment-Modules (英語)   
- https://www.chpc.utah.edu/documentation/software/modules-advanced.php (英語)   
- https://modules.readthedocs.io/en/latest/ (英語)  
- https://lmod.readthedocs.io/en/latest/ (英語)

# 3.9 oneAPI フリケーニング CMake*を使用

indel oneAPI製品提供さるCMake* パルのOneAPI製品使用と、CMake* プロジュートでWindows*はLinux* 上のoneAPI ライラリーマ简单に利用くださいます。そのハリケジを使用するとて、ほたのステム・ライラリーニがCMake* ビロジュートと統合する场合と同様の体験が付けます。CMake* ビロジュートのターダットに応じて、依存関係が生んだり、ほたのビルド変数が必要に況にあらむ。

次のコンパ-onentに CMake*をサ比較ります。

- ダンテル® oneAPI DPC++ ニンバイヤー - Linux*、Windows*  
- I nテル® I nnte grel一tedd·Pefo-mans·PfIeMte (I nteLIP) 0pfoIeNteL® I nnteGrel-TeTld·Pefo-mans·PfIeMte·KlrlptglaFie-(I nteLIP Cryptgraphy)-Linux\*、Windows\*   
- フrench® MPILawal - Linux*、Windows*  
- プル® oneAPI ロレクテイド・コミニケーニン・ライランドリー (インル® oneCCL) - Linux*、Windows*  
- « ナンテル® oneAPI ローダ・アナリデイクス・ライランドリーニ (インテル® oneDAL) - Linux*、Windows*  
- フrench (い) oneAPI ローネリ・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー · Linux*、Windows*  
- ダンテル®oneAPI DPC++ フラリーニー (イデル® oneDPL) - Linux*、Windows*  
- 元宇宙® oneAPI 毫末·力一诺尔·拉伊德拉—（元宇宙® oneMKL）- Linux*、Windows*  
- 元宇宙® oneAPI Strelldin-g·Bulndin-g·Toll (IneloneTBB) - Linux*、Windows*   
- 八一（IneloneVPL）-Linux*、Windows*

CMake* 設定提供説的拉伊�拉一は、以下識別てきま�。

Linux* 本身就是 macOS*:

```bash
sntu:/usr/local/lib/cmake

一~:/lib/cmake

- Windows*: HKEY_LOCAL_MACHINE\Software\Kitware\CMake\Packages\

CMake* ロックーニング使用するには、ほたのステム・ライランドリーと同樣にインテルoneAPI ロイランドリー使用いたします。例えば、findpackage(tbb)を使用すると、アリケーションの CMake* ロックーニングはインテルoneTBB ロックーニング使用いたします。

# 4 oneAPI フロgr lamのル実行

This is a translation of the following sentence.

# 4.1 单一ソーナスのコンパクト

oneAPI プロガラミング・モデルは、单一ソーナのコンパウルをサボートします。单一ソーナのCONPハILには、木ストとデバイスコトを個別にCONPハILする场合比較て多くの利点のは��。oneAPI プロガラミング・モデルは、一部のEUーサーの要望に答え、木ストコトとデバイスコトの個別CONPハILもサボートるごと見えてお願いいたします。利用可能な单一ソーナのCONPハILには次のモデルくださいます。

- 利便性 - 開發者は作成するフィ�ル数を最小限に抑え、木ストコーツの呼声出し元の直後のデバイスコーツを定義いたします。  
- 安全性 - 单一の安全は、単独のコンハーリラをはみに環境に任意の効力を判断する成分を制成。木スト・コンハーリラを上ご生成起来的反引数がデバイス・コンハーリラを上ご生成起来的力一内科の実引数と一致いたします。  
- 最適化 - ダーホス・コンパクトは、力一内科が起動いたします。」例えに、CONPILARはいつかの定数を伝搬んだり、関数 Respirant全体でロンタOneの工販業協会情報を推奨いたします。

# 4.2 メンバイヤーの起動

indeloneAPI DPC++/C++ バンバイヤレは、マトドライングにトUNバイヤレ一を起動する複数のトUNバイヤレ一・ドライバーハ提示し。次の例は、C++ およこ SYCL*の才予言示し。ドライハ一才予言の詳細にしだは、「各種トUNバイヤレとドライバーハ一見」(英語)を参照てくださ。

CONUNIBIAI-の起動に開示的詳細は、「INTELoneAPI DPC++/C++CONUNIBIAI·DEB口HBA一·カイドおよリフALRENS』の「CONUNIBIAI-の起動」(英語)を参照てくだい。

C++ トリクールをコロILる際にOpenMP*为効に用は、次のコマドでコロIL一を起動し。

```txt
$ icpx -fiopenmp -fopenmp-targets=<arch> (Linux*) $ icx /Qiopenmp /Qopenmp-targets=<arch> (Windows*) 
```

SYCL* 予一言之言，开口。

```powershell
$ icpx -fsycl -fiopenmp -fopenmp-targets=<arch> (Linux*)  
$ icx-cl -fsycl /Qiopenmp /Qopenmp-targets=<arch> (Windows*) 
```

才丶的詳細にては、「IneloneAPI DPC++/C++ ナンバイレーニ・デロルハーニ・ガイドおよリフレス」の「CONHILAR-才丶」(英語)を参照てくだい。

CONVILRAI-DLAVIIBA=OS木SbTcH与互换性G异N。Linux\*为、GCCStall的icpx-fsycl摩卡DIAIN·才PShn加提供、Windows\*为MicrosoftVisualStudio\*的MicrosoftVisualC++互换的icx-cl为提供。

GCC形式のコマンドライON·才予は言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言言  
- Windows* メマンドライnton·オシャン ("/"/ て始む)を認識し、Microsoft* Visual Studio* バーのプロジングトで使用いたします。

# 4.3 トoneAPI DPC++/C++ メンバイラーニの標準才予

```
インテル® oneAPI DPC++/C++ フrenchillーナの完全な才緱リスは、『インテル® oneAPI DPC++/C++ フrenchillーナ・デバイロットバーベイドおよむリフロー』に記載いたします。

- 「才ロード向けのル才予」OpenMP* 才予」(英語)には、SYCL*とOpenMP*才ロードに固有的才予」が示ていま。  
- 利用可能なすての才薦広と簡卍説明は「ルフアバット順」(英語)にごりま�。

# 4.4 メンバイル例

oneAPI フリケーニンは、ダレクト・プロガラルング、利用可能性 oneAPI フリGRAリを使用する API バー、およんだりを組み合わせて記述するとが許ります。API バーのプロガラルングは、ロリガラリの機能を使用してデバイスへの才フローツを行います。こによう、開発者はアリケーニンを開発する時間を節約いたします。一般に、API バーのプロガラルングから始�、二系に対応,Noかい场合にSYCL*まはOpenMP*才フローツ機能を導入するのは最も容易estrと考えらります。

次のせクIJONは、APIバーケのコードとSYCL*を使用たダレクト・プロガラルンの例を紹介し。

# 4.4.1 API バーのコード

次のコードは、インル® oneMKLのoneapi::mk1::blas::axy関数を使用て、浮動小数点数のパクトル全体に对てaとxを乗算てyを加算するAPI呼声出（a\*x+y）の使用法を示ていま。ごサングルコードは、oneAPIプロガラミング·モデルを利用て、アケセレ一た一で加算を実行いたします。

```cpp
1. #include <vector> // std::vector()
2. #include <cstdlib> // std::rand()
3. #include <CL/sycl.hpp>
4. #include "oneapi/mkl/blas.hpp"
5.
6. int main(int argc, char* argv[])
7.
8. double alpha = 2.0;
9. int n_elements = 1024;
10.
11.
12. int incx = 1;
13. std::vector<double> x;
14. xresize(incx * n_elements);
15. for (int i=0; i<n_elements; i++)
16. x[i*incx] = 4.0 * double(std::rand()) / RAND_MAX - 2.0;
17. // -2.0 3 2.0の範圍の rand 值
18.
19. int incy = 3;
20. std::vector<double> y;
21. yresize(incy * n_elements);
22. for (int i=0; i<n_elements; i++)
23. y[i*incy] = 4.0 * double(std::rand()) / RAND_MAX - 2.0;
24. // -2.0 3 2.0の範圍の rand 值
25.
26. cl::sycl::device my_dev;
27. try {
28. my_dev = cl::sycl::device(cl::sycl::gpu_selector());
29. } catch (...) {
30. std::cout << "Warning, failed at selecting gpu device.Continuing on default(host) device.\n";
31. }
32.
33. // 非同期例外をヤマチ
34. auto exception handler = []
35. exceptions)
36. for (std::exception_ptr const& e : exceptions) {
37. try {
38. std::rethrow_exception(e);
39. } catch(cl::sycl::exception const& e) {
40. std::cout << "Caught asynchronous SYCL exception:\n";
41. std::cout << e.what() << std::endl;
42. }
43. }
44. };
45.
46. cl::sycl::queue my_queue(my_dev, exceptionhandler);
47.
48.
49. cl::sycl::buffer<double, l> x_buffer(x.data(), x.size());
50. cl::sycl::buffer<double, l> y_buffer(y.data(), y.size());
51. 
```

```cpp
52. // y = alpha*x + y 者計算  
53. try {  
54. oneapi::mkl::bias::axpy(my_queue, n_elements, alpha, x_buffer,  
55. incx, y_buffer, incy);  
56. }  
57.  
58. catch(cl::sycl::exception const& e) {  
59. std::cout << "\t\tCaught synchronous SYCL exception:\n"  
60. << e.what() << std::endl;  
61. }  
62.  
63. std::cout << "The axpy (y = alpha * x + y) computation is complete!"<< std::endl;  
64.  
65.  
66. // y_buffer 车前插口  
67. auto y_accessor = y_buffer.template  
68. get_access<cl::sycl::access::mode::read>();  
69. std::cout << std::endl;  
70. std::cout << "y" << " = [" << y_accessor[0] << " ]\n";  
71. std::cout << "[ " << y_accessor[1*incy] << " ]\n";  
72. std::cout << "[ " << "... ]\n";  
73. std::cout << std::endl;  
74.  
75. return 0;  
76. } 
```

aplK-ohn(axpy.cpp 10 15

1. MKLROOT 環境變數が適切に設定いたします。

```txt
Linux*: echo ${MKLROOT}
Windows*: echo %MKLROOT% 
```

正しく設定いたします。场合、setvars.sh、oneapi-vars.sh スケリトを source か (Linux*)、setvars.bat、oneapi-vars.bat (Windows*) スケリトを実行、たは lib およ include サデイレクtor一を含むデレクtor一・ルスを変数に設定します。

setvars 0yD oneAPI-vars StKlPbTOnd'z#hE=、「oneAPI 开發環境の設定」を参照てくda。

2. 次のコマンドでアリケーニンをルドします。

Linux*:

```shell
$ icpx -fsycl -I$\{MKLROOT\}/include -c axpy.cpp -o axpy.o 
```

Windows*:

```shell
$ icpx -fsycl -I${MKLROOT}/include /EHsc -c axpy.cpp /Foaxpy obj 
```

3. 次のコマンドでアリケーションをLIENCLます。

Linux*:

```txt
$ icpx -fsycl axpy.o -fsycl-device-code-split=per_kernel \
$\{MKLROOT\}/lib/intel64"/libmkl_sycl.a -Wl, -export-dynamic -Wl, --start-group \
$\{MKLROOT\}/lib/intel64"/libmkl_intel-ilp64.a \
$\{MKLROOT\}/lib/intel64"/libmklsequential.a \
$\{MKLROOT\}/lib/intel64"/libmkl_core.a -Wl, --end-group -lsycl -lOpenCL \
-lpthread -lm -ldl -o axpy.out 
```

Windows*:

```shell
$ icpx -fsycl axpy obj -fsycl-device-code-split=per_kernel ^
"${MKLROOT}/lib/intel64"/mkl_sycl.lib ^
"${MKLROOT}/lib/intel64"/mkl_intel-ilp64.lib ^
"${MKLROOT}/lib/intel64"/mklsequential.lib ^
"${MKLROOT}/lib/intel64"/mkl_core.lib ^
sycl.lib OpenCL.lib -o axpy.exe 
```

4. 次のコマンドでアリケーションを実行いたします。

Linux*:

```txt
$ ./axpy.out 
```

Windows*:

```batch
$ axpy.exe 
```

# 4.4.2 ロレクト・プロダラルング

ごこは、「バク卜ル加算のサングルコービ」(英語)を使用いたします。そのサングルコービは、oneAPI フロガラミング・モテルを利用て、アケセレーダー一域加算を実行いたします。

次のコマンドで、実行形式をコンパウルてリンクします。

```txt
$ icpx -fsycl vector_add.cpp 
```

コマンドと才予はのコンバーニングと関数は、「APIバーケフド」せクシャンで説明たもの類似てい。

ごのコマンドを実行すると、実行時にごク卜ルの加算を実行する実行フィヤルが作成いたします。

# 4.5 メンバイルの手順

才Fl口一卜行上口格拉山作成的场合、元不巴尔一木斯上和丁巴尔向之两方的可卜生成的必要为里。oneAPIは、の複雜作業開發者か見不等用中。開發者は、DPC++元巴尔一icpx-fsyc1)使使用SYCL\*APRk-3nを元巴尔的d知（一度の元巴尔cmandd）木土上和丁巴尔向のコト生成き。

注：Stéme要件示起的Inel® 2016 年初加入、AMD* (Linux*のみ) 05年NVIDIA* (Linux*とWindows*) GPUもた一格トに用場が見ま�。

- メンテル® oneAPI DPC++ ニンバイヤラービ AMD* GPUを使用するには、CodeplayからoneAPI for AMD* GPU プラゲンを入手てインストーリュです。  
- ナンテル® oneAPI DPC++ ニンパイヤラーミ NVIDIA* GPUを使用するには、CodeplayからoneAPI for NVIDIA* GPU フラゲインを入手てインストーリ bem。

デバイスコービの実行には、Just-in-Time (JIT) メンパウルと Ahead-of-Time (AOT) メンパウルの2つの才予言が)”は、JITがデフィルトです。そのセクschonはは、木戸コートのCONPIL方法と、DEAVScoadを生成する2つ的方法を説明いたします。詳は『Data Parallel C++』(英語)書籍の13章を参照てくだい。

# 4.5.1 從来のコンパル手順 (木戸のみのアフリケーニン)

従来のル手順は、C、C++、またはそのほかの言語で利用くださる標準のル方法です。デバイスへの才口一ドがい场合に使用いたします。ル手順を円に示ります。

# 従来のコンパル手順

![](images/88318371f968266e5350723b30818f2cf3812874a0bd47d6a738eb345cd5665a.jpg)

1. フロトエンドは、ソーを中間表現に変換し、バックエンドに渡ります。  
2. ロックエンドは、中間表現を才総ク卜・コトに変換て才総ク卜・フィル (Windows* はは .obj、Linux* はは .o)を出力いたします。  
3. 1つ以上的才緱けクト·フアルがリル一に渡さります。  
4. リンカ一是実行フィイルを生成いたします。  
5. ごて、アplikacionesを実行いたします。

# 4.5.2 SYCL* 才Flö-1dコトのCONVIL手順

SYCL* 才フローロードのコンパ铱ル手順には、從来のCONPIL手順にデバイスコ連のJITおよBAOT才PNHONを追加いたします。その手順のは、開発者はicpx-fsycl使用て、SYCL*APRILKANをCONPAIL、出力とて木トコ連とDEAVSCHDの两方を含む実行可能FAILL作成ります。

SYCL* 才Flö-dコトの基本ル手順を次に示ります。

![](images/0cce3e5f368682fe23692cec9678f52e3d72acd7ed22567e87a4c114962ca3bb.jpg)  
SYCL* 才 fluorideコニート的基本コル手順

1. 木斯トコーリは、バックエンドで才総けク卜・コーツに変換さて。  
2. ダバイスローはSPIR-V*形式たはデバイスバイナリ一に変換いたします。  
3. リン力一は、木スト·才総戦ク卜・コトとデバイスコト(DSPIR-V*はたはデバイスバイナリ一)を組み合わせた、(デバイスコトが埋む迅また)木スト実行コトを含むフアットバイナリ一を生成いたします。  
4. バイナリーが起動いたします。才レーテング・シスチムは木戸・アリケーションを実行いたします。才ロトが行動起来的场合、拉丁語はデバイスローを口一ドします (必要に広てSPIR-V*をデバイスバイナリ一に変換ります)。  
5. トクは、木トと利用可能なデバイスで実行さます。

# 4.5.3 JITのコンパル手順

JIT バンバイルの手順のは、デバイスコeadはバックエンドでSPIR-V*形式の中間コeadに変換いたします、SPIR-V*とてアフツトバイナリーリーツーミり�ら、ランダムによてSPIR-V*からデバイスバイナリーリーツーミり�を変換いたします。アTPLKEJOONが起動いたします。、ランダムは利用可能なデバイスを判別てそのデバイス固有的コeadを生成いたします。こいにごり、AOT(事前) バンバイル手順ょうりも、アTPLKEJOONの実行環境とアモーマンの柔軟性が高まります。しぎし、アTPLKEJOONの実行時にデバイIL(JIT)が行わるたえ、アTPLKEJOONの実行時間が增加する可能性のは).(大量のデバイスコeadを持つ大規模なアTPLKEJOONは、ハフローマングへの影響が顯著に表るこethingに))(

HT:JIT メンバイル手順は、ターダットデバイスが不明くださる场合に役立与否。

注：JIT メンバイラーハス、FPGA ダイスははサボトさきません。

CONVIL手順を次の円に示ります。

![](images/e538cef194b45cd0438140631f4a999db9bb5b8a382f1c49a8dfec7c4bbf528d.jpg)  
JIT ニンパイヤル手順

1. 木ストコーニは、バックエンドで才アジク卜・コーニに変換いたします。  
2. ヨバイスローはSPIR-V*形式に変換いたします。  
3. リンカーハ、木スト・オフロー・デバイス SPIR-V*を組み合わせた(SPIR-V*が埋うらむた)、木スト実行コービを含むフィットバイナリ一を生成いたします。  
4. 实行之称的上用处理裁。

(a) 木戸上のデバイスランタイムは、デバイスのSPIR-V*をデバイスのバイナリ一に変換いたします。  
(b) 变換了一的八八八一1是八八八口一

5. トリクーニは、実行時に利用可能な木スとデバイスで実行いたします。

# 4.5.4 AOTのコンパル手順

AOT(事前) メンバイルのはは、デバイスコービがSPIR-V*に変換いたします。木SPORTクエドのデバイスコービに変換いたします、最終のに生成くださutedeバイスコービがフィットバイナリ一に組みお願いいたします。しぎし、実行フィットルの起動時間はJIT手順お願いも短くります。

HT: AOT 手順は、ターダットとるデバイスが明確に判明してる場合に適ります。AOT 手順は、デバイ�サイクルが高速化いたします。アリケーニンをデバイ格する際の利用が推奨いたします。

CONVIL手順を次の円に示ります。

![](images/1acea45fde0104653e0915b3b0ed2d4c5fdff0d6c23cfbb30b897748aadbb951.jpg)  
AOT メンパイヤル手順

1. 木ストコービは、バックエンドで才総けク卜・コービに変換さてま。  
2. ヨバイスローはSPIR-V*形式に変換いたします。  
3. ヨバイスのSPIR-V*は、コマンドラインでデーカ指定したバイス向けのデバイス·コー・才総クトに変換いたします。  
4. リン力一は、木スト·才総戦ク卜・コトとデバイス·才総戦ク卜・コトを組み合わせた、デバイスサイリーが埋え迅まんだ木スト実行コトを含むアフツルサイリー生成します。  
5. 实行時に、デバイスバイチリーネはデバイスハロトローさります。  
6. ト・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・デ・

# 4.5.5 フアットバイナリ一

フアットバイナリ一は、JITとAOT フONバイル手順から生成いたします。デバイスコーユが埋む迅た木ストバイナリ一です。デバイスコーユ自体は、CONNBIIL手順にて異なります。

# FFAHTBVAHNI

# Host Code

# Executable (ELF or PE)

# Device Code

JIT:SPIR-V

AOT: Executable (ELF or PE)

- 木ストコーナは、ELF (Linux*) または PE (Windows*) 形式的実行フィ�ルです。  
- ヨーナスはリフローは、JIT 手順はは SPIR-V*、AOT 手順ははデバイスサイリーツーツ（実行可能）です。実行フィアルは次のいじての形式です。

CPU:ELF(Linux\*）、PE(Windows\*)  
- GPU: ELF (Windows\*、Linux\*)   
- FPGA: ELF (Linux\*), PE (Windows\*)

# 4.6 CPU 手順

CPUはコンビューダーの頭腦とみ Respirant、分岐予測、×モリ一の反想化、命令のスケジュル等诸多を含む複雜な回路/ルゴリズム構成得很好。そのうな複雜性を考慮し、CPUは幅広いスクを处理するように設計いたします。

SYCL* 予開OpenMP* 才口一卡利用的口格兰三卡·毛德尔可、異種CPU 予開GPU 施式之的  
APRJONの实装が可能に限。SYCL* 予開OpenMP* 才口一卡におは「デバイス」は、CPUとGPUの  
两方指指场合が限。

最新のCPUは、並列計算に利用可能なハリバーベスレツデングと広SIMD幅を備た複数のコアを搭載いたします。ローロービ計算集約型で並列実行可能な領域が存在する场合、その優等領域はGPUやFPGA等方式のロービサイートは必いCPUハフロービする这句话推奨いたします。こははま、デーテをPCIe*を介て才ロービする必要くださいます。デロービサイートは最小限に抑てレイデンチを輕減いたします。

CPU 为アplikacionesを実行するには、CPU 为直接実行得起従来型の CPU フローツ、CPU ダリクスで実行得起的CPU 才ロービドの2つの才探acionesがようね。CPU 才ロービドは、SYCL* または OpenMP* 才ロービド·アリケーモンで使用くださいます。OpenMP* 才ロービド·アリケーモンと SYCL* 才ロービド·アリケーモンは、 whichever OpenCL* ランタイムとインテル® oneTBBを使用て、CPU ルリクスで実行いたします。

HINT: ユーロトがCPU、GPU、たはFPGAに最適のはが不明な場合は「各種oneAPI」。  
Wーロトに対するCPU、GPU、およこFPGAの利点の比較」(英語)を参照てくだい。

# 4.6.1 從来的CPU向手顺

從来のCPUenza克口一は、拉丁式不てCPU上動作し。CONBIL口一は、C、C++ まはほかの言語为使用さる状的才口一卜行わい標準的的。

從来のローは、「コンパルフロ一の概要」で説明いたします。従来のCONPICALFLO一(木戸専用ア フリケーニン)手順を使用て、木戸上でCONPICALおよ务实行いたします。

CONVILLOMDNDSI:

```shell
$ icpx -g -o matrix.mul_omp src/matrix.mul_omp.cpp 
```

# 4.6.2 CPU 才ロービの手順

デフローは、CPU ヨーダイスハフローする场合、OpenCL* マンタムを使用いたします。OpenCL* マンタムは、並列処理にインテル® oneTBBも活用いたします。

CPU に才ローダする場合、wavegrul一は異な論理アに割り当てら、こらのwavegrul一は並列に実行elize。wavegrul一内のwave一項目は、CPUのSIMDレーニにマツドiates。wave項目(サ�格ル一)は、SIMD方式で同時に実行elizeます。

# CPU ユークダルーポ

![](images/f6a0643dc669b6415cc229c2d258fb676ada444adbf0e17ca132dc9a0d271797.jpg)

CPU 实行の詳細にしだは「各種 oneAPI メンピューダイング・ウーロドに对中国 CPU、GPU、おば FPGAの利点の比較」(英語)を参照てくだい。

# 4.6.2.1. CPU 才ロト向けの設定

1. setvars たは oneapi- vars スケリトの実行を含む、「oneAPI開発環境の設定」セクシャンのすばての手順を実行たと確認いたします。  
2. syc1-1s メマドを実行て、必須な OpenCL* ランタイムがCPUに開連付けらてると確認いたします。

例:

```txt
$ sycl-1s
CPU: OpenCL 2.1 (Build 0) [2020.11.12.0.14_160000]
GPU: OpenCL 3.0 NEO [21.33.20678]
GPU: 1.1[1.2.20939] 
```

3. 次のSANPLBコト使用て、コトがCPUで実行いたします。SANPLBコトは、整数的大きなごク卜にス力ラ一を加算し結果を検証いたします。

# SYCL*

SYCL* はは CPU で実行するたの組込デバイスセレクタ一が用意いたします。它は device_selector 基本ケラスを使用し cpu_selector てCPU ダバイスを選択いたします。

はは、default_selectorを使用て、実装で定義くださいますリスデイクに從て次の環境変数による実行時にデバイスを選択するご头顶てき。

```powershell
$ export ONEAPI_DEVICE_SELECTOR=cpu 
```

SYCL\* 拉丁

```cpp
1. #include <CL/sycl.hpp>
2. #include <array>
3. #include <iostream>
4.
5. using namespace sycl;
6. using namespace std;
7. constexpr size_t array_size = 10000;
8. int main(){
9. constexpr int value = 100000;
10. try{
11. cpu_selector d_selector;
12. queue q(d_selector);
13. int *sequential = malloc_shared<int>(array_size, q);
14. int *parallel = malloc_shared<int>(array_size, q);
15. // 小一克沙拉 iota
16. for (size_t i = 0; i < array_size; i++) sequential[i] = value + i;
17.
18. // SYCL*の並列 iota
19. auto e = q.parallel_for(range(array_size), [=](auto i) {
20. parallel[i] = value + i;
}
);
22. e.wait();
23. // 2つの結果が等しだか検証
24. for (size_t i = 0; i < array_size; i++) { 
```

```cpp
25. if (parallel[i] != sequential[i]) {  
26. cout << "Failed on device.\n";  
27. return -1;  
28. }  
29. }  
30. free(sequentia, q);  
31. free(parallel, q);  
32. }catch (std::exception const &e) {  
33. cout << "An exception is caught while computing on device.\n";  
34. terminate();  
35. }  
36. cout << "Successfully completed on device.\n";  
37. return 0;  
38. } 
```

次のコマンドでSANPLULコーはCON八ルしま。

```txt
$ dpcm simple-iota-dp.cpp -o simple-iota. 
```

追加のコマンドはサンプロルのCPUコマンドから取得いたします。

生成了八个字一为实行了。

```txt
$ ./simple-iota
Running on device: Intel® Core™ i7-8700 CPU @ 3.20GHz
Successfully completed on device. 
```

# OpenMP*

OpenMP*のサングルコービ：

```c
1. #include<iostream>   
2. #include<omp.h>   
3. #define N 1024   
4. int main(){   
5. float \*a = (float \*)malloc(sizeof(float)\*N);   
6.   
7. for(int i = 0; i < N; i++)   
8. a[i] = i;   
9. #pragma omp target teams distribute parallel for simd map(tofrom: a[:N])   
10. for(int i = 0; i < 1024; i++)   
11. a[i]++;   
12.   
13. std::cout<<"successfully completed on device.\n";   
14. return 0;   
15. } 
```

次のコマンドでSANPLULコーはCONPILILしま。

```txt
$ icpx simple-ompoffload.cpp -fiopenmp -fopenmp-targets=spir64 -o simple-ompoffload 
```

CPU上成才口一國領域實行的有、巴尼一为实行前次の環境變数を設定し。

```txt
$ export LIBOMPTTARGET_DEVICEETYPE=cpu $ export LIBOMPTTARGET_PLUGIN=opencl
```

生成了八个字一为实行了。

```txt
$ ./simple-ompoffload
Successfully completed on device 
```

# 4.6.3 CPU ∧コトを才フロ一ド

APRIKAN 10101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101010101

才Fl口一土的二一领域特定出川：、个尼尔Advisorの才F口一のMEL化が役立与。

# 4.6.3.1. 才 fluoride 了的 ヨルフ。

以下のリストには、才フローダるコトの基本的なデバックの匕CNTが示ていま。

- 木ストター��ットをチルクてコフが正いとを確認いたします。  
- printfを使用て、アTPLKEーニンをデバイously。SYCL*とOpenMP*才ロトはは、どらモ力一ルコドでprintfがサボートされま。環境変数を設定て詳細なロス情報を取得しま。

- SYCL* はは、次のデバイ格環境変数を利用いたします。surdeの環境変数にしだはGitHub* (英語)から入手いたします。

SYCL* 为推奨いたしますのデバック環境変数  

<table><tr><td>環境変数</td><td>値</td><td>説明</td></tr><tr><td>ONEAPI_DEVICE_SELECTOR</td><td>frontend:device_type:device num</td><td>GitHub* (英語)の説明を参照くださいます。</td></tr><tr><td>SYCL_IR_trace</td><td>1|2|-1</td><td>1: SYCL*/DPC++ マンタivismラダバイnof基本トレーベスロック出力いたします。
2: SYCL*/DPC++ マンタivismラダバイnofすばての APIトレーベス出力いたします。
-1: 2の sucセと追加のデバック情報を出力いたします。</td></tr></table>

- OpenMP* はは、次のデバック環境変数が推奨いたします。利用可能性をその環境変数にしぃいは、「LLVM/OpenMP* ドキュmonton」(英語)を参照くださいます。

OpenMP* 为推奨いたしますのデバック環境変数  

<table><tr><td>環境変数</td><td>値</td><td>説明</td></tr><tr><td>LIBOMPTARGET_DEVICETYPE</td><td>cpu | gpu | host</td><td>デバイスを選択いたします。</td></tr><tr><td>LIBOMPTTARGET_DEBUG</td><td>1</td><td>詳細なデット情報を出力いたします。</td></tr><tr><td>LIBOMPTTARGET_INFO</td><td>LLVM/OpenMP*のドコメト
で利用可能性値(英語)</td><td>EUーザーダーがさばまなタイフのラUNタイム情
報を libomptarget から取得くださいますようご
しいたします。</td></tr></table>

- 事前 (AOT) メンパievILを使用て、ジストインタイム (JIT) メンパievILを AOT メンパievILに移行いたします。詳細にしぃいは、「CPUアーミテクチヤ一向けの事前ドンパievIL」を参照てくだいたします。

oneAPI 为利用可能的嵌入式方法和嵌入式接口的详细，「SYCL* 0x10 OpenMP* 才口一端处理的嵌入式接口」。

# 4.6.4 CPUコトの最適化

CPU 才Fl口一Dコトの八FOM-MANsI影的可能性多の要因かは。W-克項目、W-克GL-、 0.

- メアで実行いたしますのーク量が計算集約型くださ的形式、フフフーマンスが低下する可能性のはんだ。这也可是、スデューリルの才一ハドとスレットのフテきト切り替えが原因です。  
CPUは、PCIe*を介た徳一夕軀送が不要のは、才口一卜領域が徳一夕を長時間待機する必要くださいます。  
- トリクーニフの性質に基は、スレド・アフローはCPUのバフローマスに影響を与え可能性がたま。詳細にしだは、「ルチコアに付けるハリナリの実行制御」を参照てくだき。  
- ダフローは JIT バンババイルが使用いたしますが、代わに AOT バンババイル (オラインババイル)を使用て、特定のCPUアーミデチヤーをターフットにとコトをコトババイルます。詳細にしだは、「CPUアーミデチヤー向けの最適化才務」を参照てくだい。

「才ローダ・八フローマスの最適化」で追加の推奨事項が提供いたします。

# 4.6.5 CPU メマンドの例

次のコマンドは、デバイスコービ一部が静的ライランドリーリーにる実装を想定,Thim。

注: 動的ライランドリーリフローはサボート領域に限ります。

デバイスローを使用てフツト·才緱ク卜を生成します。

```shell
$ icpx -fsycl -c static_lib.cpp 
```

ar リルを使用て、静のフアット・ライランドリ一を作成ります。

```txt
$ ar rc r libstlib.a static lib.o 
```

APRIK-ENJNJOE-10

```txt
$ icpx -fsycl -c a.cpp 
```

静的ライランドリーアフリケーニンをんくじます。

```powershell
$ icpx -fsycl -fossload-static-lib=libstlib.a a.o -o a.exe
```

# 4.6.6 CPU 一卡一向( AOT)

事前(AOT) メンバイルモードのは、最適化才予は使用て、特定のCPUアーミングチヤーの実行を改善するコトを生成いたします。

```shell
$ ipcx -fsycl -fsycl-targets=spir64_x86_64 -Xs "-device <CPU 最適化IFA> " a.cpp b.cpp -o app.out
```

次のCPU最適化才丶予がサロ一トさてま。

```txt
-march=<instruction_set_arch> 夕一袋トの命令SET-ア一希テケチヤ一を設定：
```

'sse42' 入尔 Stuti一三NG SIMD 拓張命令 4.2

'avx2' 1enlrol 4abunsb-ckulcKsTENJH 2

'avx512' 'indel® トクトル・工クSten」 512

注: パボーツングの最適化才総は、将来りリフス変更さる可能性のはんだ。

# 4.6.7 複数のCPUコア上来バイナリOneの実行をコトロール

# 4.6.7.1. 環境变数

次の環境変数は、プロダムの実行中に複数のCPUコアへSYCL*ははOpenMP*スレットの配置をCNTローリしります。OpenCL*ラntonialnCPUデバイスを使用てCPUに才FlD一的场合、它らの変数を使用いたします。

SYCL* または OpenMP* 環境変数  

<table><tr><td>環境変数</td><td>説明</td></tr><tr><td rowspan="13">DPCPP_CPU_CU AFFINITY</td><td>CPUへスレット・アフIONTObe設定お願いいたします。以下を指定,These is.</td></tr><tr><td>close -スレットは利用可能なCPUコアに連続て配置,These is.</td></tr><tr><td>spread -スレットは利用可能なCOAに分散,These is.</td></tr><tr><td>master -スレットは原則MARIL -スレットと同様COAに配置,These is.</td></tr><tr><td>DPCPP_CPU_CU_AFFINITYが設定くださいますと原則MARIL -スレットも固定,These is.</td></tr><tr><td>(This work is an experimental study of the DPCPP CPU SCHEDULE, which is a work in progress.)</td></tr><tr><td>This work is an experimental study of the DPCPP CPU SCHEDULE, which is a work in progress.</td></tr><tr><td>This work is an experimental study of the DPCPP CPU SCHEDULE, which is a work in progress.</td></tr><tr><td>This work is an experimental study of the DPCPP CPU SCHEDULE, which is a work in progress.</td></tr><tr><td>This work is an experimental study of the DPCPP CPU SCHEDULE, which is a work in progress.</td></tr><tr><td>This work is an experimental study of the DPCPP CPU SCHEDULE, which is AORAL-10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td></tr><tr><td>This work is an experimental study of the DPCPP CPU SCHEDULE, which is AORAL-10000000000000000000000000000000000000000000000000000000000000000000000000</td></tr><tr><td>This work is an experimental study of the DPCPP CPU SCHEDULE, which is AORAL-15000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</td></tr><tr><td rowspan="6">DPCPP_CPUpptICES</td><td>アフIONデイーを設定する場所を指定いたします。</td></tr><tr><td colspan="1">価は,{sockets | numa_domains | cores | threads}のいじねかです。</td></tr><tr><td colspan="1">その環境変数は、OpenMP*のOMPpptICES環境変数に似ります。</td></tr><tr><td colspan="1">numa_domainsが選択いたします、oneTBBのNUMA APIが使用いたします。亿吨は、OpenMP*5.1のOMPpptICES=numa_domainsに似ります。oneTBBのtaskarenaはnumaノーロにバイドいたします、SYCL*nd-rangeはtask arenaに均一に分散いたします。</td></tr><tr><td colspan="1">DPCPP_CPUpptICESは、DPCPP_CPU_CU AFFINITYともに使用する,thisを推奨いたします。</td></tr><tr><td colspan="1">デ fasルト:cores</td></tr></table>

ト一トる環境変数の詳細にては、『イルoneAPI DPC++/C++ ニンハーリーニ・デロドバーニ・ガイドおはリフレNS』(英語)を参照てくだい。

# 4.6.7.2. 木戸トモリの割り当て

OpenMP* 要使用這場合、次のAPIを使用てはストメモリ一を割り当て、デバイスと共有するにとてckま。

```sql
EXTERN void *llvm_omp_target_alloc_host(size_t Size, int DeviceNum) 
```

×毎一割当の詳細にては、『レルズ口·コア·プロガラムング·ガイド』(英語)を参照てくだい。

# 4.6.7.3. 例1：Innel®八百一脉Leffing·德口一有

2 ニケットで、ソケットごに4つの物理コア,No、その物理コアはは2つのハイローレットがるマシを想定いたします。

- S<num>は、リストで指定いたします8つのルアを持っケット番号を示いたします  
- T<num>は、インル® oneAPI スレット億ング·ルデインGb・プロック (インル® oneTBB)のスレット番号を示ります。  
- "--"は未使用的コアを意味いたします。

```txt
DPCPP_CPU_NUM_CUS=16  
export DPCPP_CPUpptICES=socket  
DPCPP_CPU_CU_AFFINITY=close: S0: [T0 T1 T2 T3 T4 T5 T6 T7] S1: [T8 T9 T10 T11 T12 T13 T14  
T15]  
DPCPP_CPU_CU_AFFINITY=spread: S0: [T0 T2 T4 T6 T8 T10 T12 T14] S1: [T1 T3 T5 T7 T9 T11 T13  
T15]  
DPCPP_CPU_CU_AFFINITY=master: S0: [T0 T1 T2 T3 T4 T5 T6 T7] S1: [T8 T9 T10 T11 T12 T13 T14  
T15] 
```

export DPCPP_CPUpptLANCES=cores DPCPP_CPU_CU_AFFINITY $\equiv$ close: S0:[T0 T8 T1 T9 T2 T10 T3 T11] S1:[T4 T12 T5 T13 T6 T14 T7   
T15] DPCPP_CPU_CU_AFFINITY $\equiv$ spread: S0:[T0 T8 T2 T10 T4 T12 T6 T14] S1:[T1 T9 T3 T11 T5 T13 T7   
T15] DPCPP_CPU_CU_AFFINITY $\equiv$ master: S0:[T0 T1 T2 T3 T4 T5 T6 T7] S1:[T8 T9 T10 T11 T12 T13 T14   
T15] export DPCPP_CPUpptLANCES $\equiv$ threads DPCPP_CPU_CU_AFFINITY $\equiv$ close: S0:[T0 T1 T2 T3 T4 T5 T6 T7] S1:[T8 T9 T10 T11 T12 T13 T14   
T15] DPCPP_CPU_CU_AFFINITY $\equiv$ spread: S0:[T0 T2 T4 T6 T8 T10 T12 T14] S1:[T1 T3 T5 T7 T9 T11 T13   
T15] DPCPP_CPU_CU_AFFINITY $\equiv$ master: S0:[T0 T1 T2 T3 T4 T5 T6 T7] S1:[T8 T9 T10 T11 T12 T13 T14   
T15]   
export DPCPP_CPU_NUM_CUS $= 8$ DPCPP_CPUpptLANCES $\equiv$ sockets, cores and threads have the same bindings: DPCPP_CPU_CU_AFFINITY $\equiv$ close close: S0:[T0 -T1 -T2 -T3 -] S1:[T4 -T5 -T6 -T7 -] DPCPP_CPU_CU_AFFINITY $\equiv$ close spread: S0:[T0 -T2 -T4 -T6 -] S1:[T1 -T3 -T5 -T7 -] DPCPP_CPU_CU_AFFINITY $\equiv$ close master: S0:[T0 T1 T2 T3 T4 T5 T6 T7] S1::[]

# 4.6.7.4. 例2：Innel®八百八一斯Ledding·Tekn口J—無効

2 ヨケットで、ソケットごに4つの物理コア,No、その物理コアには2つのハイローレットがるマシを想定いたします。

- S<num>は、リストで指定いたします8つのコアを持っケット番号所示いたします。  
T<num>は、oneTBBのスレット番号を示いたします。  
- "--"は未使用的コアを意味いたします。

```python
export DPCPP_CPU_NUM_CUS=8  
DPCPP_CPUpptes=socketcs, cores and threads have the same bindings:  
DPCPP_CPU_CU_AFFINITY=close: S0:[T0 T1 T2 T3] S1:[T4 T5 T6 T7]  
DPCPP_CPU_CU_AFFINITY=spread: S0:[T0 T2 T4 T6] S1:[T1 T3 T5 T7]  
DPCPP_CPU_CU_AFFINITY=master: S0:[T0 T1 T2 T3] S1:[T4 T5 T6 T7]  
export DPCPP_CPU_NUM_CUS=4  
DPCPP_CPUpptes=socketcs, cores and threads have the same bindings:  
DPCPP_CPU_CU_AFFINITY=close: S0:[T0 - T1 - ] S1:[T2 - T3 - ]  
DPCPP_CPU_CU_AFFINITY=spread: S0:[T0 - T2 - ] S1:[T1 - T3 - ]  
DPCPP_CPU_CU_AFFINITY=master: S0:[T0 T1 T2 T3] S1:[- - - - ] 
```

# 4.7 GPU手順

GPUは、アリケーニンの計算集約型領域の負荷を輕減する用途で使用くださいます特殊な計算デバイスです。通常、GPUは多数の小規模なコア構成せ、大量のスルーフットをまたしります。夕スクには、CPUに適したものとGPUに適したものお願いいたします。

注：Sistek要件に示さるInntel®口口ss一加、AMD* 021NVIDIA\*GPUも夕一GnT上の场合があ末(Linux\*の)。

- ナンテル® oneAPI DPC++ ニンバイヤロー AMD* GPUを使用するには、CodeplayからoneAPI for AMD* GPU プラゲンを入手てインストーリします。  
- ナンル® oneAPI DPC++ ニンバイヤー NVIDIA* GPUを使用するには、CodeplayからoneAPI for NVIDIA* GPU フラガインを入手てんだスローいます。

HINT: ユーロトがCPU、GPU、たはFPGAに最適のはか不明な場合は「各種oneAPI」。フーロトに对付CPU、GPU、およむFPGAの利点の比較」(英語)を参照てくだい。

# 4.7.1 GPU 才ロードの手順

プロガラムをGPUに才ローネードる、デフィルトでレルジロのランタイムが利用いたします。OpenCL* マンタイムに切り替え的才アリフロー用意くださいます。SYCL* お願い OpenMP* 才ローネードは、各わーク項目は SIMD 裁一にマツpeesは。サ metabルーツは並列に実行いたしますのわーク項目で形成いたしますSIMD幅に分割 ,(SIMDレーニはGPUのEUスレットにマツpeesは。ロカルデーアを同期たは共有するわーク項目を含むわーク格尔ーツは、計算ユニット(スリーッーマング・ルチプロセss��一まはXeコア-サスライスと必呼ばれ)=(ての実行に割り当てら).(1)最初に、わーク項自の格ローナルND-Range全体がGPU全体にマツpees)=(。

![](images/480411fd710ba9f81a14b23bb9f79c081061f95a4a1a7b79ad2264a585e7a8ad.jpg)  
RPG インターフエイスの GPU ユーク格尔・

GPU実行の詳細にしだは「各種oneAPIルンビューダイング・ウークローユ対するCPU、GPU、およFPGAの利点の比較」(英語)を参照てくだい。

IrisGPU A-kiTckcha之詳細にては『GPU最適化gaid』を参照てくさ。

# 4.7.1.1. GPU 才Flö-ド向はの設定

1. setvars は oneapi-vars スケリトの実行を含む、「oneAPI開発環境の設定」セクIJONのすての手順を実行たと確認いたします。  
2. ローダリバーヤーをインストーリルとGPU システム構成し、デーサイバーを video グルーツフに追加します。詳細にしだては、「導入ガイド」を参照にしてくだいたします。

- プンテル® oneAPI バー・ツールルキット導入ガイド Linux* 版 (英語) | Windows* 版 (英語)  
- プンテル® HPC リルキット導入ガイド Linux* 版 (英語) | Windows* 版 (英語)

3. syncl-1s メマンドを使用て、サボーツローはる GPU と必要なドライバーがインストーリ領域いき。ご確認いたします。次の例のは、OpenCL* お願いレルジロービヤルバーがインストーリ領域いき。GPU に開連付けらたんタイムごに2つのエmontonー表示くださいます。

```txt
CPU: OpenCL 2.1 (Build 0) [2020.11.12.0.14_160000]  
GPU: OpenCL 3.0 NEO [21.33.20678]  
GPU: 1.1[1.2.20939] 
```

4. 次のSAN複ルコトを使用て、コトがGPUで実行いたします。SAN複ルコトは、整数の大的なデクトにスカラ一を加算し結果を検証ります。

# SYCL*

SYCL* はは GPU 为実行するたの組みデスレクタが用意ていま�。它は、device_selector基本クラスを使用gpu_selectorでGPUデバイスを選択いたします。独自の力stsム連クタを作成するごとてき)=(。詳細にしぃては、『Data Parallel C++』書籍の「Choosing Devices (デバイスの選択)」(英語)を参照てくださ。

# SYCL\* 拉卜

```cpp
1. #include <CL/sycl.hpp>
2. #include <array>
3. #include <iostream>
4.
5. using namespace sycl;
6. using namespace std;
7. constexpr size_t array_size = 10000;
8. int main(){
9. constexpr int value = 100000;
10. try{
11. // 
12. // 德芙ルトのデバイスセレクタは、最もバフローマングが高出デバイスを選択いたします
13. default_selector d_selector;
14. queue q(d_selector);
15.
16. // USMを使用た共有メモリ一割り当之
17. int *sequential = malloc_shared<int>(array_size, q);
18. int *parallel = malloc_shared<int>(array_size, q);
```

```cpp
19. // 小一包的iota  
20. for (size_t i = 0; i < array_size; i++) sequential[i] = value + i;  
21.  
22. // SYCL* 的並列 iota  
23. auto e = q.parallel_for(range{array_size}, [=](auto i) { parallel[i] = value + i; });  
24. e.wait();  
25. // 2つの結果が等しぃいか検証  
26. for (size_t i = 0; i < array_size; i++) {  
27. if (parallel[i] != sequential[i]) {  
28. cout << "Failed on device.\n";  
29. return -1;  
30. }  
31. }  
32. free(sequentia, q);  
33. free(parallel, q);  
34. }catch (std::exception const &e) {  
35. cout << "An exception is caught while computing on device.\n";  
36. terminate();  
37. }  
38. cout << "Successfully completed on device.\n";  
39. return 0;  
40. } 
```

次のコマンドでSANPLULコーはCONPILILしま。

```txt
$ icpx -fsycl simple-iota-dp.cpp -o simple-iota
```

生成了八个字一为实行了。

```txt
$ ./simple-iota
Running on device: Intel® UHD Graphics 630 [0x3e92]
Successfully completed on device. 
```

# OpenMP*

OpenMP*のサングルコード:

```c
1. #include <stdlib.h>  
2. #include <omp.h>  
3. #include <iostream>  
4. constexpr size_t array_size = 10000;  
5.  
6. #pragma omp requires unified_shared_memory  
7. int main() {  
8. constexpr int value = 100000;  
9. // `drafalutのターダットデバイスを返しおる`  
10. int deviceId = (omp_get_num/devices() > 0) ? omp_get_default_device() : omp_get_initializer();  
11. int *sequential = (int *) omp_target_alloc_host(array_size, deviceId);  
12. int *parallel = (int *) omp_target_alloc(array_size, deviceId);  
13. for (size_t i = 0; i < array_size; i++)  
15. sequential[i] = value + i;  
16.  
17. #pragma omp target parallel for  
18. for (size_t i = 0; i < array_size; i++) 
```

```cpp
19. parallel[i] = value + i;  
20.  
21. for (size_t i = 0; i < array_size; i++) {  
22. if (parallel[i] != sequential[i]) {  
23. std::cout << "Failed on device.\n";  
24. return -1;  
25. }  
26. }  
27.  
28. omp_target_free subsequential, deviceId);  
29. omp_target_free (parallel, deviceId);  
30.  
31. std::cout << "Successfully completed on device.\n";  
32. return 0;  
33. } 
```

次のコマンドでSANPLULコーはCONPILルします。

```txt
$ icpx -fsyclsimple-iota-omp.cpp -fiopenmp -fopenmp-targets=spir64 -o simple-iota
```

生成了八个字一为实行了。

```txt
$ ./simple-iota
Successfully completed on device. 
```

注：才フロー領域が存在し、アク塞尔ーダーがない場合、OMP_TARGET_OFFLOAD=mandatory 環境変数が指定くださいます限り、力一ルは從来のストコンパウル (OpenCL* ランタムなし)にフィールバックします。

# 4.7.1.2. GPU ∧コトを才プロド

GPU八一、のコト領域を才フロ一トか決定するには「GPU最適化フーフ口一·ガイド」(英語)

才Fl口一卜的二卜領域を特定るには、InnelAdvisorの才Fl口一卜のモル化(英語)が役立ら。

# 4.7.1.2.1. GPUコトのデバック

以下のリストには、才フローネるコフの基本的なデバックの匕CNTが示ていま。

CPU は木ト/ターダットをチルク、たはラUNダムを OpenCL* に切りてコトが正いとを確認しま�。  
- printfを使用て、アTPLKEーニンをデバイously。SYCL*とOpenMP*才ロービはは、どらも力一ルコーユdf printfがサボートはる。  
· 環境變數を設定て詳細なロケ情報を取得いたします。

SYCLは、次のデバック環境変数を利用いたします。sedoの環境変数にてはGitHub* (英語)を参照てくだい。

才フローニドローのデバックのヒnstト  

<table><tr><td>環境変数</td><td>値</td><td>説明</td></tr><tr><td>ONEAPI_DEVICE_SELECTOR</td><td>frontend:device_type:device_num</td><td>GitHub*の説明を参照くださいます。</td></tr><tr><td>SYCL.PI_TRACE</td><td>1|2|-1</td><td>1: DPC++ ランタイムラガイン的基本トレーベスロ gwを出力いたします。
2: DPC++ チンタイムラガインのsurての APIトレーベスを出力いたします。
-1: 2のsurveと追加のデバイダ情報を出力いたします。</td></tr><tr><td>ZE_DEBUG</td><td>任意の值で定義くださ过的変数（有效）</td><td>その環境変数は、DPC++ ランタイムが使用くださ过的際にレルズロ・バックエンドからのデバイダ出力を有効にいたします。以下が報告いたします。
•　レルズロ APIの呼声お願いいたします。
•　レルズロイCNT情報</td></tr></table>

OpenMP* はは、次のデバック環境変数が推奨いたします。利用可能性をその環境変数にしぃいは、「LLVM/OpenMP*」(英語)を参照てくだい。

OpenMP* 微軟化推奨たる環境変数  

<table><tr><td>環境変数</td><td>値</td><td>説明</td></tr><tr><td>LIBOMPTARGET_DEVICEETYPE</td><td>cpu | gpu</td><td>デバイスを選択いたします。</td></tr><tr><td>LIBOMPTTARGET_DEBUG</td><td>1</td><td>詳細なデバイス情報を出力いたします。</td></tr><tr><td>LIBOMPTTARGET_INFO</td><td>LLVM/OpenMP*のド kjuentで利用可能性値(英語)</td><td>euーザーダーがさまごまなタイプロのLANタイム情報を libomptarget から取得くださいますにいたします。</td></tr></table>

事前(AOT)コンパウルを使用て、シャストインタイム(JIT)コンパウルをAOTコンパウルに移行いたします。

# 4.7.1.2.2. CL_OUT_OF_RESOURCES工一

CL_OUT_OF.RESOURCES 工拉一是、工三レ一夕一がデモルトでサボ一トする _private ×モリ一もは local ×モリ一ually多くの×モリ一を力一neaルが使用すると発生する可能性のはんだ。

ごの工拉一が発生すると、次のようなメソせ一ジが表示いたします。

```txt
$ ./myapp
: Problem size: c(150,600) = a(150,300) * b(300,600)
terminate called after throwing an instance of 'cl::sycl::runtime_error'
what(): Native API failed. Native API returns: -5 (CL_OUT_OF_RESOURCES) -5
(CL_OUT_OF_RESOURCES)
Aborted (core dumped)
$ 
```

たは、onetraceを使用する场合は、次のようメソーナが表示いたします。

```txt
$ onetrace -c ./myapp
: >>>[6254070891] zeKernelSuggestGroupSize:hKernel = 0x263b7a0 globalSizeX = 163850
globalSizeY = 1 globalSizeZ = 1 groupSizeX = 0x7fff94e239f0 groupSizeY = 0x7fff94e239f4
groupSizeZ = 0x7fff94e239f8
<>>> [6254082074] zeKernelSuggestGroupSize [922 ns] -> 
ZE.Result_ERROR_OUT_OF_DEVICE_MEMORY(0x1879048195)
terminate called after throwing an instance of 'cl::sycl::runtime_error'
what(): Native API failed. Native API returns: -5 (CL_OUT_OF_RESOURCES)
-5 (CL_OUT_OF_RESOURCES)
Aborted (core dumped)
$ 
```

共有口一力ル×モリ一にコビ一さた的×モリ一量とハ一の制限を確認するには、デバツク一を設定します。

```typescript
export PrintDebugMessages=1  
export NEOREadDebugKeys=1 
```

此等可以、出力是次的。

```txt
$ ./myapp
:
Size of SLM (656384) larger than available (131072)
terminate called after throwing an instance of 'cl::sycl::runtime_error'
what(): Native API failed. Native API returns: -5 (CL_OUT_OF_RESOURCES) -5
(CL_OUT_OF_RESOURCES)
Aborted (core dumped)
$ 
```

は、onetraceを使用する场合は、次のようお願いいたします。

```txt
$ onetrace -c ./myapp
:
>>> >> [317651739] zeKernelSuggestGroupSize: hKernel = 0x2175ae0 globalSizeX = 163850
globalSizeY = 1 globalSizeZ = 1 groupSizeX = 0x7ffd9caf0950 groupSizeY = 0x7ffd9caf0954
groupSizeZ = 0x7ffd9caf0958
Size of SLM (656384) larger than available (131072)
<<<< [317672417] zeKernelSuggestGroupSize [10325 ns] -> ZE.Result_ERROR_OUT_OF_DEVICE_MEMORY(0x1879048195)
terminate called after throwing an instance of 'cl::sycl::runtime_error'
what(): Native API failed. Native API returns: -5 (CL_OUT_OF_RESOURCES) -5
(CL_OUT_OF_RESOURCES)
Aborted (core dumped)
$ 
```

oneAPI 为利用可能的 DVB 手法和 DVB 次尔的详细，「DPC++ およんだ OpenMP* 才プロ一従处理の DVB」を参照てくは。

# 4.7.1.3. GPUコードの最適化

才Flor一D卡一D为最適化山有ははか的方法が有。次の表には、最適化の匕卜が示てい。詳細にては、「oneAPI GPU 最適化ガト」を参照てくだ。

- 木戸トとデバイス間のメモリ一軽送の才一ハ一ハドを削減いたします。  
- ピアをビジー状態に維持し、デーダ軸送の才一ハーヒットのコストを輕減するたけ十分な量のフローを実行いたします。  
- GPU マヤツド、共有ロ一力ル×モリ一等GPU×モリ一階層を活用て、×モリ一アケせスを高速化いたします。  
- JIT メンパウルの代わに AOT メンパウIL (オライン広バウIL)を使用いたします。事前広バウILのは、コートを特定のGPUアーニテクチヤーをターダットに付けます。詳細くださいます、「GPU向けの事前(AOT)広バウIL」を参照にしてくださいます。  
- I nntel®GPU Occupancy Calculator (英語)を使用すると、特定の力一nergルお願いいたします。

「才ローダ・バフローマングスの最適化」で追加の推奨事項が提供いたします。

# 4.7.2 GPUコマンドの例

次の例は、Linux* てデバイスコーナー使用て静的ライランドリ一作成し、使用する方法を示しま。

注：動的ライランドリーリーにのリンクはサボートてきいせん。

デバイスローを使用てフアット・才緱ク卜を生成します。

```shell
$ icpx -fsycl -c static_lib.cpp 
```

ar ダルを使用て、静のフアト・ライランドリ一を作成いたします。

```txt
$ ar cr libstlib.a static lib.o 
```

APRIK-ENJN'soUs toCINPILLus。

```txt
$ icpx -fsycl -c a.cpp 
```

静的ライランドリーアフリケーニンをんくじます。

```powershell
$ icpx -fsycl -foffload-static-lib=libstlib.a a.o -o a.exe
```

# 4.7.3 GPU 一卡一向( AOT)

次のコマンドは、特定のGPUターダット向にapp.outを生成いたします。

```txt
DPC++: 
```

```shell
$ icpx -fsycl-targets=spir64_gen -Xs "-device <device name>" a.cpp b.cpp -o app.out 
```

OpenMP* 才□一卜:

```shell
$ icpx -fiopennp -fopenmp-targets=spir64_gen -Xopenmp-target-backend "-device <device name>" a.cpp b.cpp -o app.out
```

デバイス名に利用得起の一観は、『インテルoneAPI DPC++/C++ フンバイヤー・デバイロフロー・ガイドおよむリフロー』(英語)から入手,No。

# 4.8 FPGA手順

FIFAは、空き広にフリーナイデー・アーニルド・プロダム・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー・デー．デー．DELEADISITHERESHOTEDTHERESHOTEDTHERESHOTEDTHERESHOTEDTHERESHOTEDTHERESHOTEDTHERESHOTEDTHERESHOTEDTHERESHOTEDTHERESHOTEDTHERESHOTEDTHERESHOTEDTHERESHOTEDTHERESHOTEDTHERESHOTEDTHERESHOTEDTHERESHOTEDTHERESH

CPU、GPU、またはFPGA向にSYCL*コートをコンパルてきま�が、FPGA開発用のCONPIL手順は、CPU和GPU開発におけるCONPIL手順は多少異なてま�。

FPGA手順の詳細にしぃは、「インル®oneAPI FPGAハンド複ツク」(英語)を参照くださいます。

HINT: GitHub*のFPGA向oneAPI メン複ル(英語)を確認し、FPGAデバイスのSYCL*プロgrāmengは学习お願いいたします。

FPGA 『ロガラミングの詳細は、https://link.springer.com/chapter/10.1007/978-1-4842-5574-2_17 (英語) から入手くださirts『Data Parallel C++』書籍からも学みにきてきります。

# 4.8.1 FPGA向下的特殊力的理论

FPGAはいつかの点でCPUやGPUは異なります。CPUやGPU比較大的大小な違は、FPGAハーニウア専用のデバイスバイナリ一が必須なとです。こはほんんだ場合、計算集約型で時間がかる处理です。FPGAのコンバイルが完了するま奨時間かけは通常の動作です。そのた、FPGA開発向けに事前(才ライIN)力一ル・CON バイル・モートのみがサロトされます。FPGAハーニウアのCONバイルには時間がかるた、ヤストインタイム(才拉IN)CONバイILは実用的はあら逅せん。

FPGAをターダットと用開発設計を素早く反復する力二斯ム提供し。可能限完全FPGA一にかる手順を回護するご上、CPUおはGPU開発に近い感觉高高速CONBAIL时间の恩惠を受けらし。

FPGA手順の詳細にしぃは、インル® FPGA向けインル® DPC++/C++ ニンバイヤラ・ハンドフック (英語)を参照てくだせ。

# 4.8.2 SYCL* FPGA メンパイルの種別

SYCL*はアクセラレーダー全般をサボーリス。インテルoneAPI DPC++/C++ フPGA サボーツバックジは、インテルoneAPI DPC++/C++ フPGA ハドの開発を支援するた、FPGA固有的サボーツを提供します。そのドキメトのは、インテルoneAPI バー・ソールkjットがサボーツする標準なFPGA フンサイル手順にpine说明いたします。

FPGA ニンパイヤルの実践のなレットンにpineは、GitHubのFPGA ニンパイヤルサングル(英語)を確認てくだい。

以下の表に、FPGA ニンパイヤルの要約を示いたします。

FPGA メンパルの種別  

<table><tr><td>デバイス・イメー・タイド</td><td>コンパ铱ル時間</td><td>説明</td></tr><tr><td>FPGA 工ミュレーナー</td><td>数秒</td><td>FPGA ダバイスコートはCPU向けにconiなフィルiatesます。OpenCL*ソフットウア向けインテル®FPGA 巴チレーニン・フロットフィアム使用て、SYCL*コートが正しく機能する这句话を確認いたします。</td></tr><tr><td>FPGA 最適化レポト</td><td>数分</td><td>FPGA ダバイスコートは部分のにハートウア向けにconiなフィルiatesます。CONPABBRA-は、FPGA 生成得起構造とフィアーマNsのボルネックを特定し、リソーニ斯利用率を推奨て最適化レポトを生成いたします。CONPABBRAでFPGA ダバイスフィアーマーハは製品番号をターフットにする场合、上のSTEJEでconi卜内的IP バンポーネnts RTL フアウア使用成ります。その後、インテル®Quartus®Prime 开発ソフットウア使用て、IP バンポーネntsをさらに大的きな設計に統合,Noisy。</td></tr><tr><td>FPGA フミュレーナー</td><td>数分</td><td>FPGA ダバイスコートはCPUにconiなフィルiatesます。Questa*-インテル®FPGA Edition Softwareのシミュレーション使用て、コートをデ abb格します。</td></tr><tr><td>FPGA 半球ウア・イメー</td><td>数時間</td><td>ターフットのFPGA プラツトフィアムで実行するFPGA ビットスローは製品番号をターフットにする场合、上のSTEJEでconi卜内のIP バンポーネnts RTL フアウア使用成ます。その後、インテル®Quartus®Prime 开発ソフットウア使用て、IP バンポーネntsをさらに大的きな設計に統合,Noisy。</td></tr></table>

一般的FPGA開発フローは、工三レーニル、最適化レート、およんだリーニン・ステジを繰り返て、そのるスチジからもたさるフィートバツクを反映てコト改为改良ります。可能限に工三レーニルとFPGA最適化レートを活用するごを推奨いたします。

IP メンボーネntsの開発時にこらのステーニジがそのように適用いたします、「FPGA IP イーダリング手順」を参照てくたさ。

HINT: FPGA 工三レーニchaftは FPGA プリル、FPGA 最適化レトを生成するには、インテルoneAPI DPC++/C++ プリラ用の FPGA サロトバックジが必要です。

FPGAハーニドウアでコンパルするには、Quartus®Primeソフローもインストーリる必要かのはんだ。ボーダをターフットにするには、ボーツ用のBSPも必要です。

詳細にては、『イルoneAPI リルキット・イストル・ガイド』(英語)とイルFPGA開発手順のを一(英語)を参照てくた。

た、RTL IP メアを生成するには、インル® oneAPI DPC++/C++ ニンバイヤラの FPGA サボーリトバイケジのみが必要です。ただし、IP メアをシミュレーションんだり、ハートウア設計に統合するには、Quartus® Prime開発ソフトウア·プロ・工徳な会必要です。

# 4.8.2.1. FPGA 工ミュレーダー

FPGA工ヨレーナー（OpenCL* プフロー向けインテル® FPGA工ヨレーニン·TPLTFOUM)は、コトの正当性を検証する最速の手法です。CPU上ごSYCL* メバイスコトを実行いたします。FPGA工ヨレーナーは、SYCL* 木ストデバイスに似りますか、木ストデバイスのは異なり、FPGA ロイプロやfpga_reg等FPGA拏張機能がサロト siderます。詳細にしだは、「インテル® oneAPI リルキット向け FPGA最適化ガット》の「ハイプロ拓張」(英語)と「カーナル変数」(英語)を参照にしてくだい。

次にFPGA工ミレ一族を使用する際に見ておくご重要事項を示ります。

# - 步步一、二、三、四、五、六、日、月、年、夏、春、夏、秋、夏、冬、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏、夏季、夏季、夏季

FPGA工彌レーダリは、FPGAデバイスの動作そのモを再現するモはなた、八フアーマンスの評価に使用しぃてくださ。例えは、FPGAで100倍の八フアーマンス向上をもたらす最適化は、工彌レーダ一の八フアーマンスには影響しおか、多少の增減を示す这句话は。

# - 未定義の動作は異な可能性,No�。

FPGA 工業広レーダーと FPGA 半球のア向付にコルは工成結果が異な場合、コトに未定義の動作が含む可能性のは。未定義の動作は言語仕様は指定さておら、ターフットごに振る舞いが異な可能性のは。

力一ルの工ヨレーニンの詳細にては、『イルoneAPI FPGAハンドフク』の「カーナルの工ヨレ」を参照てくさ。

# 4.8.2.2. FPGA最適化レト

完全なFPGA ニンバイルは次の-Stーニで行わい、最適化レトは両方のStーニの後に出力いたします。

FPGA最適化レト  

<table><tr><td>ステーダ</td><td>説明</td><td>最適化レ boltの情報</td></tr><tr><td>FPGA初期イモーダ(コンパルには数分かけます)</td><td>SYCL* フバイスコドは最適化いたします、Verilog Lejstura一軽送レル(RTL)(FPGAの低レルの設計入力言語)で指定くださる FPGA設計に変換いたします。ごによう、実行形式フィアのは不孕 FPGA初期イモーダが生成いたします。そのステーダのはは静的ね最適化レ boltが生成いたします。</td><td>こりには、CONPILARaがSYCL* フバイスコドからFPGA設計に変換た手法にiores的重要な情報を含むて亿吨み。レ boltには次の情報が含む亿吨み。FPGAで生成た構造の可视化情報• フフローマスと予期たるハフローマスのボルネックに開る情報• リソーの利用状況を推測FPGAの最適化レ boltにしぃいは、『インル®oneAPI FPGAハンド複ツ』(英語)を参照にして,leftaito。</td></tr><tr><td>FPGAハンドウエア・イモーダ(CONPILRには数時間かけます)</td><td>設計回路のトロジーを指定する VerilogRTLは、InelletuQuartusPrime開発なトロウア・プロ・エデイチニソフウアによてFPGAのリミチイド・ハンドウア・リソーにマッチングいたします。結果は、FPGAハンドウエア・ハイナリ-(ビットスリム)です。</td><td>リソーとfMAX数に開る正確な情報を含む亿吨み。レ boltの解析に開る詳細は、『Inelletu®oneAPIツルkjth向けFPGA最適化ガBITDの「設計の解析」(英語)を参照にして,leftaito。FPGAの最適化レ boltにしぃいは、『Inelletu®oneAPI FPGAハンド複ツ』(英語)を参照,Thightle。</td></tr></table>

CONPILF FPGADEBLVSmE Hc品番号tategutl'35.10RTLFFALM作成。其後、INNTLQuartusPrime開發SFTWua为使用，IPCONP-NENTo也

# 4.8.2.3. FPGA プルーダー

Shimenu一念手順は、Questa*-Innel® FPGA Edition SoftwareのShimenu一束を使用て、合成た力一neaの正確な動作をShimenu一上ごきま。工menu一と同様に、タ�ガトのFPGAロトが装着てい。いSStmfofshu一在実行ごきま。Shmnu一は、工mnu一ohy也正確に力一neaをMDL化ごきまか、工mnu一一やもかが低速です。

シミュレーション手順は、サイクル精度とビット精度を目的と、力一NELのデーダルスの動作と浮動小数点デーダル操作結果を正確にモダル化いたします。ただし、シミュレーションは、可変レイテングロー・メモリーやその其他的外部インタフイスを正確にモダル化する这句话は可以せん。シミュレーションはFPGAハーニウアや工モリーダーよりもがな低速のはるた、小規模な入力デーダルで設計をシミュレーションする这句话を推奨いたします。

Shimuraon手順をプロフィ�ルと組み合わて利用すること、設計に閲る追加情報を取得くださいます。プロフィ�ルの詳細にしぃは、『インテルoneAPI FPGA八トドフク』の「DPC++のインテルFPGAダイナミック·プロフィ�ル」(英語)を参照てくだき。

注：GNU* Project Debugger (GDB)、Microsoft* Visual Studio* はたは通常のソフロー・デバASSカを使用て、シミュレーション向付にコルはた力一NEルコトをデバASSするとはてきません。

Shimuraon手順の詳細にしぃは『InnteloneAPIFPGA八ndFpck』の「ShuRei」的力一尼尔の評価」(英語)を参照てくさ。

# 4.8.2.4. FPGA八一卡夫

FPGAハーニドウアのコンパクトには、Quartus®Prime開発ソフトウア(英語)を別途インストルする必要くださいます。こりは、次のいHZがたーダットにるFPGAハーニドウア·イメーの完全なCONPILLSteJezです。

- 元代 FPGA テーナリフロー・  
- 特定のインル®FPGA ダバイスの製品番号  
- トトさる BSPを持つ力スムト一  
- 入ル® プロガラマリル・アケセレーダー・力一ド (PAC) (非推奨)

夕一袋トの詳細にしだは「インテルoneAPI DPC++/C++ ニンパイヤラのシスム要件」(英語)を参照てくさい。インテルFPGA PACんだは力stsムトOneの使用に閲る詳細は『インテルoneAPI FPGAハンドフク』の「FPGAトとト・サロト・バックeer(BSP)」の節と、『インテルoneAPI リルキット・インストーリド(Linux*)』(英語)を参照てくだい。

# 5 API バーのプロガラムング

最適化くださiatedアプロkeeヨン向けの特殊APIを提供するとて、プロガラルムスを簡素化するインテルoneAPI ダールキットのライランドリーチ利用,Noは。This is the official English translation of the following article. 10. 特定の利用ケスはそのライランドリーチが最も有效か判断るに役立つ情報を提供いたします。利用可能なAPI等、その雑誌のライランドリーチの詳細は、ライランドリーツドクフメトを参照てくだせ。

インル® oneAPI リートルキットのライランドリーダ  

<table><tr><td>ライランドリーニ</td><td>使用法</td></tr><tr><td>インテル® oneAPI DPC++ マイランドリーニ (インテル® oneDPL)</td><td>ハイローマフローmansの並列アプロケーションで使用いたします。</td></tr><tr><td>インテル® oneAPI マス・カーナル・ライランドリーニ (インテル® oneMKL)</td><td>高度に最適化お願い並列化くださいます数学ルーッチニをアプロケーションて利用いたします。</td></tr><tr><td>インテル® oneAPI スレットデイング・ビルデイング・プロック (インテル® oneTBB)</td><td>マルチコア CPU出于インテル® TBB バースの並列处理と、アプロケーションてのSYCL*デバイス高速並列处理を組み綜合いたします。</td></tr><tr><td>インテル® oneAPI ヤーネフ・アナリデイクス・ライランドリーニ (インテル® oneDAL)</td><td>ビックデーナ解析アプロケーションと分散計算を高速化いたします。</td></tr><tr><td>インテル® oneAPI プレクTIPTS・コミチニケーション・ライランドリーニ (インテル® oneCCL)</td><td>デイープラーニングとマシングラーニングのリーミロードを处理するアプロケーションて使用いたします。</td></tr><tr><td>インテル® oneAPI テイフ・ニューラル・ネットフロー・ライランドリーニ (インテル® oneDNN)</td><td>インテル® 亚一きテクチヤー・デースのプロセSSFローおよんだインテル® フロセSSFロー・ガラFIFFUS向着に最適化くださいます、ニューラル・ネットフローを使用するデイープラーニング・アプロケーションて使用いたします。</td></tr></table>

注: oneAPI 沙蔵ルコトの完全なリストは、GitHub* にた oneAPI 沙蔵ル力タロ格 (英語)を参照てくさ。こりらのサングルは、CPU、GPU、FPGAをターダットと連マルチアーミデクチヤー・アリケーニンの開発、才ロト、最適化を支援するよう作成いたします。

# 5.1 〔 oneAPI DPC++ ヤイランドリーナ (いnteloneDPL)

インル® oneAPI DPC++ ライランドリーナ（インル® oneDPL)は、インル® oneAPI DPC++/C++ メンバイヤーと連携て生産性の高的APIを提供いたします。こりらのAPIを使用て、ハイバイフローマングな並列アプロケーニ onwardに、デバイス全体でSYCL*プロダラミングの労力を最小限に抑るこが成長を。

indeloneDPL is次的cnonb一不ntd成哉。

Parallel STL

- Parallel STLの使用手順  
- 麦克□

- ライランドリーダースと関数の追加セット(そのドキュメトのはは擴張APIと呼声)。

並列ルガリズム  
- ダテレー夕一  
- 開數才緱約克卜·克拉斯  
- 篦囿亻一スのAPI

- ナスト济みの標準 C++ API  
- 乱数シエネレ一夕一

# 5.1.1 1onTeloneDPLLaiIPLR-の使方

indeloneDPLto使用s用一、indeloneAPI一上·一尔卡卜在不上一

Patalle STLとAPI擴張使用するには、必要なハダーフアイルをソーメコーユでインクル一下しま。 seabての
```bash
Patalle STL  oneDPL ハダーフアイルはoneapi/dpl テレクトリーハ我们需要。そのらをインクル一下誃るには、
#include <oneapi/dpl/…>を使用いたします。インテル® oneDPLには、大部分のクラスと関数対照名前空間
oneapi::dplidgetually。

ntst洛的C++標準APIを使用するには、対応るC++ハツダ一フアイルをインクル一ド、std名前空間を使用する必要くださいます。

# 5.1.2 1nToloneDPLs

indeloneDPLのsulplcは、https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/ oneDPL(英語)から入手,No。。It 15.170 Readme 184

# 5.2 1nTeLoneAPI MarS·力一NEU·LAIePRALI (1nTeLoneMKL)

インテルoneAPI 麻・力一neaル・ライフリーリー (インテルoneMKL)は、最大限の八万欧元一manスを必要するアリケーニん向けに最適化せ、広範围に並列化さたル一チncyの数学計算ライフリーリーです。インテルoneMKLには、C/fortran トロガラモν言語イナーフエスを備たCPU 一希テクチヤ一向けのインテル MKLの八万欧元一manス等最適化が含まており、各種CPU 一希テクチヤーとインテル グラフィックス・デクロジーで八万欧元一manスを高うの SYCL* 伊ナーフエスが追加さていま。インテル oneMKLは、BLAS およじ LAPACK 線形代数ル一チ、高速一工変換、バウトル数学関数、乱数生成関数、その其他的機能を提供します

OpenMP* 才Flö-d为使用、GPU等标准的 oneMKL 计算为实行。詳細につはは、「C ナフローの OpenMP* 才Flö-d」(英語) およIFICFortran ナフローの OpenMP* 才Flö-d」(英語)を参照てくだい。

CPUとGPUアーニングチヤ一向に最適化くださいますSYCL*インーナフローは、次のよう計算機能が追加いたします。

- BLASとLAPACK密線形代数ル一チN   
- スpiracles BLAS プーネス線形代数ルーニフ  
- 乱数生成器 (RNG)  
- バケトルの数学演算用に最適化くださいます バケトル数学 (VM) ルーチン  
高速フーリル変換 (FFT)

機能一覈、ドキムnt、サングルコード、ダウロードにては、インルoneMKLのウフサイトを参照てくさ。インルoneMKLをインルoneAPIバーケ・ツルクットの一部とて利用する场合、有償才仮庁とて優先サローツ(英語)を利用くださいます。インルのコチニテー・サローツにては、インルoneMKL フ0ーリラム(英語)を参照てくさ。コチニテーがサローツる才一脱ンソーナ・バーダヨncyにては、oneMathGitHub* (英語)のバーダけを参照てくさ。

次の表に、oneMKLサイトの違いを示ります。

<table><tr><td>oneMathのoneAPI仕様(英語)</td><td>バフローmansに優た数学ライランドリーニングのSYCL ナンターフイヤスを定義いたします。oneMath仕様は、oneMath実装のは頻繁に更新いたします。</td></tr><tr><td>oneAPI マス・ライランドリーニ(oneMath)(英語)</td><td>仕様の才一PurpleSOS実装です。そのプロジceptsは、oneMath仕様で文書化くださたSYCL ナンターフイヤスをあらゆる数学ライランドリーニ実装し、各種ターダット・ハーヒダアその動作実証する这句话を目標にしてます。此文提供くださる実装は、まえ完全,Noはい可能性のは、時間をかけて完全仕様を構築する这句话を目標にしてます。複数のハーヒダア・ターダットやほたの数学ライランドリーニにサポットを拏張するため、COMUNIONERLYERONLINEORALINEORALINEORALINEORALINEORALINEORALINEORALINEORALINEORALINEORALINEORALINEORALINEORALINEORALINEORALINEORALINEORALINEORALINEORALINEORALINEORALINEORALINEORALINEORALINEORALINEORALINEORALINEORALINEORALINEORALINEORALINEORALINEORALINEORALINE</td></tr><tr><td>インテル® oneMKL プロジceptsト(英語)</td><td>oneMath仕様のインテル製品実装(DPC++ ナンターフイヤスを使用)およむ同等の機能を提供するCとFortran ナンターフイヤスは、インテル®oneAPI バー・ツルキットの一部とて提供いたします。インテル®CPU的优点はインテル®GPUハーヒダア向ality中高度に最適化いたします。</td></tr></table>

# 5.2.1 ナンル® oneMKLの使の方

SYCL* ンターフエイスを使用する场合、考慮ますきにがりります。

- 一 oneMKLは、一 oneAPI DPC++/C++ ニンバイヤーおよこいテルoneAPI DPC++ マイフリーナリーツに依存ていま。APRIL oneAPI DPC++/C++ ニンバイヤーでビルドさ。SYCL* ハツダ一利用ており、DPC++ リンカ一使用ていテルoneMKLとリクさていの必要かあ。  
- ネンテル® oneMKLのSYCL* ネンターフイヤスは、入力デー夕 (バケル、行列等各种)にデバイスのアクsesが可能な統合共有×モリ—(USM) ネンタ一を使用くださ。

- 一 oneMKLの一部の SYCL* トーナフイスは、入力デー夕向けのデバイスへのアクsesが可能な USM バンタOneに、sycl::buffer才総戦トのアクsesもサトていま�。  
- 一 oneMKLの SYCL* 一 ローフリーニー・タイド std::complex<float>、std::complex<double>を使用する、单精度实数引数(float)、倍精度实数引数(double)、半精度实数引数(half)、おはい異な精度の複素数引数を受け接入的沢用行列乘算APIがたて。  
- トーナリル® oneMKLの2レパターンの名前空間構造がSYCL* ナンターフローに追加いたします。

インル®oneMKLの2レパターンの名前空間  

<table><tr><td>名前空間</td><td>説明</td></tr><tr><td>oneapi::mkl</td><td>インテル® oneMKLの各種ドメイん間の共通要素が含,No�。</td></tr><tr><td>oneapi::mkl::blas</td><td>密険クトル-険UCTル、行列-険UCTル、おはみ行列-行列の低レBEL操作が含,No�。</td></tr><tr><td>oneapi::mkl::lapack</td><td>行列因数分解や固有値ソルバーニ喹高レBELの密行列演算が含,No�。</td></tr><tr><td>oneapi::mkl::rng</td><td>各種確率密度関数の乱数生成器が含,No�。</td></tr><tr><td>oneapi::mkl::stats</td><td>単精度おはみ倍精度の多次元デーダセット基本のな統計予測值が含,No�。</td></tr><tr><td>oneapi::mkl::vm</td><td>険UCTル数学ル一チncy含,No�。</td></tr><tr><td>oneapi::mkl::dft</td><td>高速フーリ工変換操作が含,No�。</td></tr><tr><td>oneapi::mkl::sparse</td><td>スロー行列険UCTル乗算、スロー三角ソルバーニ喹のスロー行列演算が含,No�。</td></tr></table>

# 5.2.2 1nTEL®oneMKL サン複ド

SYCL* トーナーフエイスとインテル® oneMKLの一般的ncyクフロ一を示すた、次のサングルコードは、GPUデバイスで倍精度の行列-行列乘算を行いま�。

注：次のコト例のは、行中的COMNT为示さるように、CONBAILと実行に追加のコトが必要です。

```cpp
1. //標準SYCL\*^ssdauer  
2. #include <CL/sycl.hpp>  
3. //STLクLAS  
4.#include <exception>  
5.#include<iostream>  
6. //oneMKLのSYCL*/DPC++APIの宣言  
7.#include"oneapi/mkl.hpp"  
8.int main(int argc，char \*argv[]) {  
9. //  
10. //乙一は、m、n、k、ldA、ldB、ldCの設定とA、B、C行列のデーを取得  
11. //  
12. //AB、おはこCは、data()とsize()Menb一関数を含むstd::vector之类的  
13. //CONテに格納いたします  
14. //  
15.  
16. //GPUデバイスを作成  
17.sycl::device my_device;
```

18. try{   
19. my_device $\equiv$ sycl::device(sycl::gpu_selector();   
20. 1   
21. catch (...){   
22. std::cout << "Warning: GPU device not found! Using default device instead." << std::endl;   
23. }   
24. // 卡一可亚卡的非同期例外八卡拉一作成   
25. // 必须はあらませが、システム適切に構成てい等場合に参照か有用な情報を提供さむ。   
26. auto my_exceptionhandler $=$ [] (syc1::exception_list exceptions）{   
27. for(std::exception_ptr const& e : exceptions) {   
28. try{ std::rethrow_exception(e);   
30. }   
31. catch (sycl::exception const& e) { std::cout << "Caught asynchronous SYCL exception:\n" << e what() << std::endl;   
32. }   
33. catch (std::exception const& e) { std::cout << "Caught asynchronous STL exception:\n" << e what() << std::endl;   
34. }   
35. catch (std::exception const& e) { std::cout << "Caught asynchronous STL exception:\n" << e what() << std::endl;   
36. }   
37. }   
38. }   
39. }   
40. };   
41. // 例外八卡リーナーがアタチたのgpu ダバイスで実行ケルを作成   
42. sycl::queue my_queue(my_device, my_exception_handler);   
43. // 德バイスと hast間の才ローツ向けに行列デタの SYCL* ダ呋フロー作成   
44. sycl::buffer<double, 1> A_buffer(A.data(), A.size());   
45. sycl::buffer<double, 1> B_buffer(B.data(), B.size()));   
46. sycl::buffer<double, 1> C_buffer(C.data(), C.size()));   
47. // add oneapi::mkl::bias::gemm 要行ケル一追加し、同期例外をヤツチ   
exceptions   
48. try{   
49. using oneapi::mkl::bias::gemm;   
50. using oneapi::mkl::transpose;   
51. gemm(my_queue, transpose::nontrans, transpose::nontrans, m, n, k, alpha, A_buffer, ldA, B_buffer, ldC);   
52. ldB, beta, C_buffer, ldC);   
53. }   
54. catch (sycl::exception const& e) { std::cout << "\t\tCaught synchronous SYCL exception during GEMM:\n" << e what() << std::endl;   
55. }   
56. catch (std::exception const& e) { std::cout << "\t\tCaught synchronous STL exception during GEMM:\n" << e what() << std::endl;   
57. }   
58. catch (std::exception const& e) { std::cout << "\t\tCaught synchronous STL exception during GEMM:\n" << e what() << std::endl;   
59. }   
60. // 绪行する前に、ヤツチたけの非同期例外外を处理   
61. }   
62. // 終行する前に、ヤツチたけの非同期例外外を处理   
63. my_queue.wait_and THROW();   
64. //   
65. // 後処理の結果   
66. //   
67. // c ヒフローからデタをアクsesし、c 行列の一部を出力   
68. auto C_accessor $\equiv$ C_buffer.template get_access<sycl::access::mode::read>(); std::cout << "\t" << C << " = [ " << C_accessor[0] << ", "   
70. << C_accessor[1] << ", ... ]\n";   
71. std::cout << "\t [ " << C_accessor[1 * ldC + 0] << ", "   
72. << C_accessor[1 * ldC + 1] << ", ... ]\n";   
73. std::cout << "\t [ " << "..." ]\n";

```txt
74. std::cout << std::endl;  
75.  
76. return 0;  
77.} 
```

(倍精度值)行列A（サイズm*k）、B（サイズk*n）、C（サイズm*n）は、ほストマシングの配列(次元1dA、1dB、1dc)に格納いたしますと想定いたします。スカラ一(倍精度)alphaとbetaを指定し、行列-行列乘算(mkl::blas::gemm)を計算いたします。

```txt
C = alpha * A * B + beta * C 
```

標準SYCL*ハダーと対象のmkl::blas::gemmAPI宣言を含むインル®oneMKL SYCL*/DPC++固有ハダーをインクル一下しります。

```cpp
//標準SYCLハダー  
#include <CL/sycl.hpp>  
//STLクラス  
#include <exception>  
#include<iostream>  
//伊nteloneAPI馬斯·力一専ル·拉伊布拉リのSYCL/SYCL++APIの宣言#include"oneapi/mkl.hpp"
```

次に、通常のように木ストマシング行列デーたを口一ドたはイス化し、GPU ダバイスを作成て非同期例外八NDラーニ作成し、最後に例外八NDラーニでデバイスキチを作成しぃま。木トで発生する例外は、標準 C++ 例外M力二斯ムでヤツチ成長。ただし、デバイスで発生する例外は非同期工LA一と見なさし、例外リストに保存て、ユーダ一定義の例外八NDラーニによて处理さきま。

```cpp
// GPU 微巨虫子作成  
sycl::device my_device;  
try {  
    my_device = sycl::device(sycl::gpu_selector());  
}  
catch (...) {  
    std::cout << "Warning: GPU device not found! Using default device instead." << std::endl;  
}  
// ハチーネアチフロー作成  
// 必須はようお願いいたします。デスローが適切に構成いたします。場合に参照くださいます有用な情報を提供いたします  
auto my_exceptionhandler = [(syl::exception_list exceptions) {  
    for (std::exception_ptr const& e : exceptions) {  
        try {  
            std::rethrow_exception(e);  
        }  
        catch (syl::exception const& e) {  
            std::cout << "Caught asynchronous SYCL exception:\n" << e.what() << std::endl;  
        }  
        catch (std::exception const& e) {  
            std::cout << "Caught asynchronous STL exception:\n" << e.what() << std::endl;  
        }  
}
```

ごて、行列デ一夕が SYCL* バツフア一にロービさ、ターダットのデバイスに才ロービて、完了後にはストに尻す。とがてきま。最後に、mkl::blas::gemm APIがさてのバツフア、サイズ、およ価軸置操作で呪出さ、行列乘算力一ルと一夕をタ一格トにク一に追加し。

```cpp
// 例外八nd拉一加艾尔特的gpu 微巴式实行卡一作成  
sycl::queue my_queue(my_device, my_exceptionhandler);  
// 微巴式和木斯卜間の才口一向に行列デーのSYCL 萃FFA一作成  
sycl::buffer<double, 1> A_buffer(A.data(), A.size());  
sycl::buffer<double, 1> B_buffer(B.data(), B.size()));  
sycl::buffer<double, 1> C_buffer(C.data(), C.size()));  
// add oneapi::mkl::bias::gemm为实行卡一追加、同期例外来卡  
try{using oneapi::mkl::bias::gemm;using oneapi::mkl::transpose;gemm(my_queue, transpose::nontrans, transpose::nontrans, m, n, k, alpha, A_buffer, ldA,B_buffer，ldB，beta,C_buffer，ldC）;  
}  
catch（sycl::exception const& e）{std::cout<<"\t\tCaught synchronous SYCL exception during GEMM:\n"<<e.what()<<std::endl;  
}  
catch（std::exception const& e）{std::cout<<"\t\tCaught synchronous STL exception during GEMM:\n"<<e.what()<<std::endl; 
```

gemm力一専がチ一登録た後、実行さて。は、すての力一専の実行を待機し、ヤツチが了非同期例外を例外八ndlra一渡てスロ一るうに要求しぃ。LANtaiUsは、HosトとGPUデバイ斯間のハFFア一の従一軽送を处理し。C_bufferのアケサ一が作成さるまごに、ハFFFA一の従一夕はHosトマシに暗默的に軽送さて。。。場合、Arssa一は2x2のc_bufferのサ複行列を出力するたに使用さて。

```cpp
// C バフローからデータをアクセスし、C 行りの一部を出力  
auto C_accessor = C_buffer.get_access<sycl::access::mode::read>();  
std::cout << "\t" << C << " = [ " << C_accessor[0] << ", " << C_accessor[1] << ", ...]\n";  
std::cout << "\t" [ " << C_accessor[1 * ldC + 0] << ", " << C_accessor[1 * ldC + 1] << ", ...]\n";  
std::cout << "\t" [ " << ";..."...\]\n";  
std::cout << std::endl;  
return 0; 
```

結果デー夕は C_buffer 才総じク卜に係、明示的にとかにコビ一ない限り（元のCコンテナに尻すな）、C_buffer がスコーフ外に係のまえアケ塞尔を介てのみ利用くださいます。

# 5.3 ネンテル® oneAPI スレットデング・ルデング・プロック (インテル® oneTBB)

インテル® oneAPI スレットンダ・ルデインダ・プロック (インテル® oneTBB)は、木asant上でタスケーメフの、共有メモリーネ並列プロガラミングを可能にし、広く使用くださいますC++ ライランドリーヤー。そのライランドリーハは、SYCL* お願いISO C++ て利用可能性機能のほにし、CPU上ごの並列プロガラミング向けに次のような機能を提供いたします。

· 汔用並列ルゴリズム  
- 冗力レntb·ドテナ  
- Sケラ一 brunl·Mモリ一·アロケ一夕一  
- ユークスチル·夕スク·スケジーリー一  
- 低レパターン同期プロリデイフ

€10 oneTBB 10 €10 oneDNN 10 €10

機能一覽、卜達ク丶�普木卜、夕王口一卜中は、不テL oneTBBのwa上告卜を参照てくさ。1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 1. 20 (英語)を利用くださいます。1. ナルのコムニーニー・サロトにとは、1. ナルoneTBB フ0ラム (英語)を参照てくさ。毎日はリフローは、oneTBB GitHub* (英語)のご一を参照てくさ。

# 5.3.1 1onTBBの使方

インテル® oneTBBは、ほかのC++ メンパイヤラーミモインテル® oneAPI DPC++ メンパイヤラーミ同じ方法で使用くださいます。詳細は、「インテル® oneTBBドキメnt」(英語)を参照くださいます。

現在、インル® oneTBBはアケセラレーダーを直接サボートします。ただし、DPC++言語、OpenMP* 才プロ一のほかのインル® oneAPI ライランドリーチ组成み合わて、利用可能性を八一ドウエ・リソーニスを効率良く使用するプロダムを構築いたします。

# 5.3.2 1nTBB

2 トの基本のなインテル® oneTBB サンTPLコードが、https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneTBB (英語) て入手ARGE。こらのサングルコードは、CPUとGPU向に記述さていす。

- tbb-async-syclは、インル® oneTBB フローダラフ非同期ノートと機能ノートを使用し、計算力一内科を分割てCPUとGPU間で実行する方法を示ります。ローダラフ非同期ノートは、SYCL*を使用し機能ノートが計算のCPU部分を実行する間に、GPUで実装くださ过的計算を実行いたします。

- tbb-task-syclは、2つのイルoneTBB夕ケが同計算力一ルを実行する方法を示ります。1つの夕ケがSYCL*コトを実行し、も一方はイルoneTBBコトを実行ります。  
- tbb-resumable-tasks-syclは、インルoneTBB再開タスケとparallel_forを使用て、計算力一ノルを分割てCPUとGPUで実行する方法を示ります。再開可能性タスケはSYCL*を使用てGPUで計算を実装し、parallel_forは計算のCPU部分を実行いたします。

# 5.4 1nTeL® oneAPIDea-AdarLdticKs·LiaIblar（1nTeLoneDAL)

indeloneAPI dea-ndalirekS-1 (innel oneDAL) is, dea-darfchns (前处理、变换、解析、Molng、检証、意思決定) 4、BHT、tANLAIN、0j6i分散处理Mond为计算实行的、高度i最適化了的ALGZLMObIeLNG·Ptoo提供sso。

ルの計算はてなく一夕の取みを最適化し、スル一トとスケ一拉リテ一向上し。C++、おはいJava* APIに加て、Spark*やHadoop*等の一般的徴一夕一スの広ケタが含まきま�。InテoneDALのPython*ラリバ一是、Inテル®徴上リビヨンのPython*プロダラル説語に含まきま�。

さらに従来の機能に加て、インル® oneDALは従来の C++ インターフイスに DPC++ API 扩張機能を提供し一部のアルガリズムでGPUも利用得起ようお願いいたします。

ごの现代农业一は、分散計算はは特に有用です。通信レイヤーから独立た分散アルゴリズムのビルデイン格・プロクの完全なセットを提供いたします。ごによう、ユーダーは利用た通信基盤を使て、高速でスケーラフルな分散アリケーニンを構築いたします。

機能一覽、卜帝元卜、半不藥一卜、夕王口一卜中也、一oneDALのwa上告卜を参照てくさ。一InTELoneDALをInTELoneAPIバー·ル卡ト一部と用利用的场合、有償才丶別子と優先サト(英語)を利用てき。InTELの三二一·沙トにては、tenLoneDALFOraL(英語）を参照てくさ。三二一·沙トする才一土・ハ�ヨトにては、oneDALGihB\*（英語）のご一登を参照てくさ。

# 5.4.1 1onTELoneDALの使方

APRIKJONeDAL 1oneDAL  oneDAL (i)

indeloneDAL パーニスのアリケーニンは、適切のデバイスレクタを選択するとて、CPUはGPUでアルゴリズムをシャムレスに実行いたします。新機能による次のとが可能くださいます。

数值テ一丶ルかSYCL\*八FFA一を抽出て力スム力一NE儿に渡す。

SYCL* 萬夫一加数值子一的作成。

ALULOL=SYCL*VAPFFA-1111111111111111111111111111111111111111111111111111

# 5.4.2 1nTEL®oneDAL消费升级コーユ

```csharp
// ナンデル® oneDAL のサングルコードは GitHub* リボジットリーマから入手,Thales。次のサングルコードは、インデル® oneDAL 固有の機能を示す分かりやす例です。

https://github.com/oneapi/src/oneDAL/tree/master/examples/oneapi/dpc/source/svm (英語)

# 5.5 1nToloneAPI CReLkTeIeP·CmHcN2KeAShon·LAIePbRl- (1nToloneCCL)

- ヨンテル® oneAPI ロレ克莱フ・コミューニケーニム・ライランドリーナー (インテル® oneCCL)は、デイープラーニング (DL)、およんだマシングラーニング (ML) ラーロード指向のスケーマルでハイバフローマンスな通信ライランドリーナです。 
- ヨンテル® Machine Learning Scaling Libraryに由来するアイデアを発展いたします、新い機能と利用ケスを実現するたけ設計とAPIを拝張にしてます。

indeloneCCLは次の機能を備ていす。

- 低レルの通信三菱ルウア上に構築たMPIとlibfabrics。  
- 通信ハフローマングに对中国生产的支持を可能に傾倒の状態に、通信ハダローはスケーマリデイを促進する最適化。  
優先順位、永統的な操作、アウト才別一実行等诸多、一連のDL固有の最適化。  
- CPU 或 GPU 類各種八一線のエフローは実行する DPC++ API。  
- さまきまなイナーリフクトで動作：イナル® Omni-Path 亚一卡デチヤー (イナル® OPA)、InfiniBand*、イ一サネット。

機能一覽、卜希連、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、卜、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、ト、扱はこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこはこは乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙は乙方是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是乙是

# 5.5.1 1onTel®oneCCLの使方

MPI 或インテル oneAPI DPC++/C++ ハンバイヤラーニ、ハートウアとソフトウアの依存関係に開る完全なリストにpineは「インテルoneCCLのシスム要件」(英語)を参照てくだき。

SYCL* 对応 APIは、インルoneCCLの才予仕機能です。インルoneCCLストリーマ・才予地ク卜を作成する场合、CPUとSYCL*バックエンドの哪らかを選択,Noは。

CPU 菜卡克工下: 最初の引数に ccl_STREAM_host 来指定します。  
- SYCL* ロクエド: テバイデイフに広て ccl_STREAM_cpu または ccl_STREAM_gpu 杆指定しおす。  
SYCL* ストリムで動作する集合操作

- C API はは、インル® oneCCL 是通信バUTFーナが void* にチアトいたします 的 sycl::buffer 才総工ケ卜のはと想定いたします。  
- C++ API はは、インル® oneCCL 是通信バUTFア一が参照渡し之称を想定いたします。

使用法に閲る詳い説明は、https://oneapi-src.github.io/oneCCL/(英語)から入手いたします。

# 5.5.2 1nToloneCCLs

```
インル® oneCCLのサイングルコードは、https://github.com/oneapi-src/oneAPI-samples/tree/master/Libraries/oneCCL(英語)から入手,Thales。

一上

# 5.6 1onTeL® oneAPI徴一·二一拉ル·新トは克（1nTeL®oneDNN) ライフロリ—

インテル oneAPI ダイロー・ニーツロー・ネットロー克 (インテルoneDNN) ライローは、デイロー二ング・アリケーション向けの才一プロスOneの八フローは。その理由には、インテル・アーきテクチヤー・バーケのプロセSSF�およんだインテル・プロセSSF�・ガラフィックス向けに最適化くださたニーツロー・ネットロー克的基本の構成要素が含まemos。インテルoneDNNは、インテル・アーきテクチヤー・バーケのプロセSSF�と、インテル・プロセSSF�・ガラフィックス上ごアリケーションの八フロー・ハス向上に注目するデイロー二ング・アリケーションおよんだレーツロー・開発者を対象ててい。デイロー二ングは、インテルoneDNNを利用するアリケーションは使用すきです。

```
```c
// ネンテル® oneDNNは、インテル® oneAPI DL フレーリムロー・デバイヤルキット、インテル® oneAPI バー・ツルキットの一部と配布いたします、aptまたはyumチヤノルから入手,No�。

インテル® oneDNNは、Cよう\C++ インターフエイス、OpenMP*、インテル® oneTBB、OpenCL* マンタイム各種、インテル® ダーツ・ニューラル・新业态ロー・サイ布鲁リー（インテル® DNNL）で現在サボート領域の機能を vigorantlyしむ。インテル® oneDNNは、oneAPI プロガラモング・モSELのSYCL*/DPC++ APIとランタイムサボートを導入いたします。

機能一覽、卜希丶ト、半不連口一上、夕不口一上にては、一丁oneDNNのwa插s（英語）を参照。

一上 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 一 二

# 5.6.1 ナンル® oneDNNの使い方

indoneDNN 64 一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一卡一

indel oneDNN is实行時令命令sett·一卡（ISA)を検出、才不立生成機能を使用て、トさる最新のISA向に最適化たコト展開し。

APRILKANJHs#CPCU 1tGUPLARNTI.

# 才レーネインズ・シスチムごとのハクケー。

<table><tr><td>設定</td><td>依存関係</td></tr><tr><td>cpu_dpcpp_gpu_dpcpp</td><td>DPC++ バンタイム</td></tr><tr><td>cpu_iomp</td><td>インルの OpenMP* バンタイム</td></tr><tr><td>cpu_gomp</td><td>GNU* OpenMP* バンタイム</td></tr><tr><td>cpu_vcomp</td><td>Microsoft* Visual C++* OpenMP* バンタイム</td></tr><tr><td>cpu_tbb</td><td>インル® oneTBB</td></tr></table>

八一テ一のリルを使用てアリケーニンで依存関係を解決する必要のはんだ。

SYCL* 環境はは、インルoneDNNはDPC++ SYCL* ランタムを介てCPUたはGPUハートウアと対話ります。インルoneDNNはSYCL*を使用するほかのコト使用するごみ成長。ごれ可能にすた、インルoneDNNは基盤なSYCL*才総戦と相互作用用的API拓張機能を提供しま。

そのような状況の1つとて、インル®oneDNNが提供:NO力stsム操作を行うたSYCL*力一NEルを実行する场合が考えらます。その场合、インル®oneDNNは力一NEルをSUUMLEスに送信するに必要なAPIを提供し、同じデバイス広一使用て実行CONテキストをインル®oneDNNと共有いたします。

相互運用性を提供する APIは、次の2つシナリ才を想定いたします。

- 既存のSYCL*才総戦トをご一とするインル®oneDNN才総戦トの構築  
- 既存のイデル® oneDNN 才総戦ト向けの SYCL* 才総戦トへのアクセス

次の表にイングル® oneDNN 才総じクトと SYCL* 才総じクトのマッチングを示ります。

# oneDNN & SYCL* 才緱トのマツビング1

<table><tr><td>インル® oneDNN 才予設けた</td><td>SYCL* 才予設けた</td></tr><tr><td>工事会</td><td>cl::sycl::device and cl::sycl::context</td></tr><tr><td>スリーリム</td><td>cl::sycl::queue</td></tr><tr><td>メモリー</td><td>cl::sycl::buffer&lt;uint8_t, 1&gt; または統合共有 メモリー (USM) フツングロー</td></tr></table>

注：内部的にライランドリーマモリーマフジクトは、1D uint8_t SYCL* バツフィーを使用いたしますが、異なるタイドの SYCL* バツフィーを介てメモリーマ初期化お願いアクsesにしてます。その場合、バツフィーは異なるタイドのcl::syc1::buffer<uint8_t, 1>に再解収いたします。

# indeloneDNN 2

<table><tr><td>インル® oneDNN 才予約はく</td><td>SYCL* 才予約はくからの再構成</td></tr><tr><td>工事会</td><td>dnnl::sycl_interop::make_engine(sycl_dev, syclctx)</td></tr><tr><td>スリーリム</td><td>dnnl::sycl_interop::make_STREAM.engine, sycl_queue)</td></tr><tr><td>メモリー</td><td>USM バー: dnnl::memory/memory_desc, engine, usm_ptr)
バッチーフロー: dnnl::sycl_interop::make_memory(memory_de_sc, engine, sycl_buf)</td></tr></table>

# 1oneloneDNN 3

<table><tr><td>oneDNN 才複ジエ crank</td><td>SYCL* 才複ジエ crankの抽出</td></tr><tr><td>工んだん</td><td>dnnl::syc1_interop::get_device (engine)
dnnl::syc1_interop::get_context (engine)</td></tr><tr><td>スリーリム</td><td>dnnl::syc1_interop::get_queue (stream)</td></tr><tr><td>メモロー</td><td>USM フサイングー: dnnl::memory::get_data_handle()
バッチー: dnnl::syc1_interop::get_buffer (memory)</td></tr></table>

# 注:

- ネンテル® oneDNN ごアリケーニんをビルドするには、コンパイヤーが必要です。 
- ネンテル® oneAPI DPC++/C++ プンパイヤーは、インテル® oneAPI バー・ツールキットに含まえてます。  
- SYCL* 相互運用性 API 来有効に説は、dnn1_sycl.hppをインクル一下説必要くださいます。  
- OpenMP*はランタイム・才総戦トの受け渡しに依存しぃた、インル®oneDNNと連携する相互運用APIは必要のはません。

# 5.6.2 1nTeL®oneDNN sAnPulc-

```python
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
``

# 5.7 その他的ライランドリ一

その他的ライランドリーハス、各種インテルoneAPI リルキットに含むます。各ライランドリーナ詳細にしぃは、そのそのライランドリーナの公式ドクメトを参照てくださ。

- 元代のデモーテー・デモーテー・デモーテー・デモーテー・デモーテー・デモーテー・デモーテー・デモーテー・デモーテー・デモーテー・デモーテー・デモーテー・デモーテー・デモーテー・デモーテー・デモーテー・デモーテー・デモーツリフロー・デモーツリフロー・デモーツリフロー・デモーツリフロー・デモーツリフロー・デモーツリフロー・デモーツリフロー・デモーツリフロー・デモーツリフロー・デモーツリフロー・デモーツリフロー・デモーツリフロー・デモーツリフロー・デモER・デモER・デモER・デモER・デモER・デモER・デモER・デモER・デモER・デモER・デモER・デモER・デモER・デモER・デモER・デモER・デモER・デモER・デモER・デモER・デモER・デモER・デモER・  
- 元日MPL拉尔拉尔  
- 入尼尔·才一、木利一、力一、拉伊

# 6 ヨフトウエ開発プロセス

oneAPI トロガラ ミング・モデル使用んだスフウア開発プロセスは、標準の開発プロセスをバーメにしては。プロガラ ミング・モデルは、アケせレーダーを使用てハフローマなスを向上するた、その節ははその作業に固有的手順を説明いたします。这也以下是以下の术がようお願いいたします。

- 八万欧元一曼联·切尔西一二隆·沙尔克尔  
一卜のデハむ  
- ほかのアクセラレーナー一向けのコーツドの移行  
- メートのコンパーダービリデイ一

# 6.1 SYCL* と DPC++ へのコトの移行

C++ または OpenCL* なうほかのプロダラル言語で記述くださいますコトは、複数のデバイスで使用たた DPC++ メンバイヤーにドンバイルさる SYCL* ミートへ移行いたします。移行手順は、元の言語にて異なります。

# 6.1.1 C++ から SYCL* ご移行

SYCL*は、C++をご一スとる「单一ノス」タイルのプロガラムング·モデルです。C++17とC++20の機能を基に構築せ、ハテロジニアス·プロガラムングに付ける才一�、マルチムングー、およむマルチア一金テケチーのソリューニnhをサボトしります。

```
```c
// プーナル® oneAPI DPC++ フロー・プロジ的概率は、SYCL*をLLVM C++ フロー・導入し、複数のバングローとアーニテクチヤーに対応た八爪ハフローマンスな実装を実現いたします。

既存のC++アリケーニンを高速化する场合、大部分のC++コトは变更する必要くださいます。SYCL*はシムレスな統合を可能にいたします。デバイス側のコンパルを可能にするSYCL*の構造にしては、「oneAPI フロガラミング·モデル」を参照てくだいたします。

# 6.1.2 プル® oneAPI DPC++ ニンバイヤーを使用た CUDA* から SYCL* への移行

インル® DPC++ 互換性ツーリル (インル® DPCT)は、インル® oneAPI バー・ソールkjトに含まえます。そのツーリルの目的は、NVIDIA* CUDA* て記述くださ�た既存のプロGRAMから、インル® oneAPI DPC++ バンバイラーミコンバイルaaSる SYCL* て記述くださ�たプロGRAMへの移行を支援するごとです。そのツーリルは、可能な限りSYCL*コードを自動生成いたします。しおし、surてのコーユが自動のに移行いたします。手動のは変更要な场合,Noかはまむ。そのツーリルには、IDE プラダインハリフと、DPC++ への移行を完了uveの「デバイロドロー・ガイドおよリフアレNS」

が含まえま�。手動のは変更が完了しら、インル® oneAPI DPC++ フフローを使用て実行可能フィ�ルを作成ま�。

# インル® DPC++ 互換性ソールを使用くださ CUDA* ican SYCL* イ移行

![](images/e7e39f6d1519a12d257c0edede5845279f60d805d877913ec317364054b3a35c.jpg)

- 移行たコト例、ルのダウローツ手順のは説明は、ル DPC++ 互換性ルのウフサイト (英語) と参照てくさい。  
- リフアレンス》を参照てくだい。

# 6.1.3 OpenCL* メートから SYCL* への移行

現在のインル® oneAPI DPC++ プジ乌克トの SYCL* ランタイムは、並列处理を実現するたけ OpenCL* ミートを採用いたします。通常、SYCL* はは力一ノルを実装するeerの行数と必須な API 開数やメソットの呼声は少な)”ごります。ほstsのソーメード行にデバイスのソーメードを埋むとて、OpenCL* フロGRAムを作成いたします。

ほんんだのOpenCL*アリケーニン開発者は、デバイスの力一neaル才ロトに伴うセットアツド·コトの必要性を認識てい的でし。SYCL*を使用すると、OpenCL*Cコトに関連する大部分のセットアツド·コトなて、シングルで現代のなC++ バースのアリケーニンを開発得很好。こによ、習得の労が輕減て、並列化の実装に集中得很好。

さらに、OpenCL* 予リケーニンの機能は、SYCL* APIを介て引き綴き利用くださいます。更新たけeerは、必要に広てSYCL* トタフイスを使用くださいます。

# 6.1.4 CPU、GPU、おはいFPGA間の移行

インテル® oneAPI DPC++ ニンバイヤリーヤ使用たSYCL*は、プロトフローはCPU、GPU、FPGA、たはその其他的アケセレーナーやプロセSSFローのデバイス(にてもかまえせん)に接続た的木ストデバイスで構成いたします。

FlaHTFOMI有数的DVBs存在用的场合、一部未是大部分のW一克をDVBsH才口一上用以APRILKAN为设计。oneAPIPbGraMnG·MDELHd数的DVBsH以W一克为分散出的，いは、か的方法が用。

1. ダーナイスセレクタの初期化 - SYCL* ははセレクタと呼ばるケラスが提供いたします、TPLTフロー内的デバイスを手動で選択いたします。インテル oneAPI ランタムのヒューリスチックがデバイスで利用可能性計算機能を判断しにデバイスを選択くださいます。  
2. ダーナセットの分割 - ダーナに依存関係:NOい高い並列性を持つアリケーションは、 ダーナセットを明示的に分割て異なデバイスで利用いたします。次のSANPURCは複数のデバイスにローを分配する例です。icpx - fsycl snippet.cppコマンドでコトをCONPIL resumes。

```cpp
1. int main() {  
2. int data[1024];  
3. for (int i = 0; i < 1024; i++)  
4. data[i] = i;  
5. try {  
6. cpu_selector cpuSelector;  
7. queue cpuQueue(cpuSelector);  
8. gpu_selectorgpuSelector;  
9. queuegpuQueue(gpuSelector);  
10. buffer<int, 1> buf(data, range<1>(1024));  
11. cpuQueue.submit([\&](handler& cgh) {  
12. auto ptr =  
13. buf.get_access<access::mode::read_write>(cgh);  
14. cgh_parallel_for<class divide>(range<1>(512),  
15. [=](id<1> index) {  
16. ptr[index] -= 1;  
17. });  
18. });  
19. cpuQueue.submit([\&](handler& cgh1) {  
20. auto ptr =  
21. buf.get_access<access::mode::read_write>(cgh1);  
22. cgh1_parallel_for<class offset1>(range<1>(1024),  
23. id<1>(512), [=](id<1> index) {  
24. ptr[index] += 1;  
25. });  
26. });  
27. cpuQueue.wait();  
28. cpuQueue.wait();  
29. }  
30. catch (exception const e) {  
31. std::cout << "SYCL exception caught: " << e.what() << '\n';  
33. return 2;  
34. }  
35. return 0;  
36. } 
```

3. ダービス間で複数の力一内科をターフットにする - トクリケーニンに複数の独立た力一内科で並列处理可能なスフムとがる场合、夕一効ドデバイスごに異なチは使用いたします。SYCL* てサロトさるフリトフアムとフリトフアムごのデバイスのリスは、getPlatforms(）と platform.getdevices()を呼む出ますと取得いたします。すaveのデバイスが特定くださいます、デバイスごにチは作成し、異な力一内科を異なチは配置いたします。次のサングルコードは、複数のSYCL* ダービスに力一内科を配置する方法を示ります。

```cpp
1. #include<stdio.h>  
2. #include <vector>  
3. #include <CL/sycl.hpp>  
4. using namespace cl::sycl;  
5. using namespace std;  
6. int main() 
```

```txt
7. {  
8. size_t N = 1024;  
9. vector<float> a(N, 10.0);  
10. vector<float> b(N, 10.0);  
11. vector<float> c_add(N, 0.0);  
12. vector<float> c.mul(N, 0.0);  
13. {  
14. buffer<float, l> abuffer(a.data(), range<1>(N),  
15. { property::buffer::use_host_ptr() });  
16. buffer<float, l> bbuffer(b.data(), range<1>(N),  
17. { property::buffer::use_host_ptr() };  
18. buffer<float, l> c_addbuffer(c_add.data(), range<1>(N),  
19. { property::buffer::use_host_ptr() };  
20. buffer<float, l> c.mulbuffer(c.mul.data(), range<1>(N),  
21. { property::buffer::use_host_ptr() };  
22. try {  
23. gpu_selectorgpuSelector;  
24. auto queue = cl::sycl::queue(gpuSelector);  
25. queue.submit([\&] (cl::sycl::handler& cgh) {  
26. auto a_acc = abuffer.template  
27. get_access<access::mode::read>(cgh);  
28. auto b_acc = bbuffer.template  
29. get_access<access::mode::read>(cgh);  
30. auto c_acc_add = c_addbuffer.template  
31. get_access<access::mode::write>(cgh);  
32. cgh.parallel_for<class VectorAdd>  
33. (range<1>(N), [=](id<1>it) {  
34. //int i = it.get_global();  
35. c_acc_add[it] = a_acc[it] + b_acc[it];  
36. });  
37. });  
38. cpu_selector cpuSelector;  
39. auto queue1 = cl::sycl::queue(cpuSelector);  
40. queue1.submit([&](cl::sycl::handler& cgh) {  
41. auto a_acc = abuffer.template  
42. get_access<access::mode::read>(cgh);  
43. auto b_acc = bbuffer.template  
44. get_access<access::mode::read>(cgh);  
45. auto c_acc.mul = c.mulbuffer.template  
46. get_access<access::mode::write>(cgh);  
47. cgh.parallel_for<class VectorMul>  
48. (range<1>(N), [=](id<1>it) {  
49. c_acc.mul[it] = a_acc[it] * b_acc[it];  
50. });  
51. });  
52. }  
53. catch (cl::sycl::exception e) {  
54. /* In the case of an exception being throw, print the error message and  
55. return 1. */  
56. std::cout << e.what();  
57. return 1;  
58. }  
59. }  
60. }  
61. for (int i = 0; i < 8; i++) {  
62. std::cout << c_add[i] << std::endl;  
63. std::cout << c.mul[i] << std::endl;  
64. }  
65. return 0;  
66. } 
```

# 6.2 メンボーダリデー

oneAPI プロガラーニング・モデルは、開発ソルチエン全体をサボートする工CONISテムを実現いたします。ごにはCPU、GPU、FPGA と複数のアケ塞尔ーダーをサボートするコンパloyer一和ライフロー、デバットー和解析ツルが含まえます。

# 6.2.1 C/C++ OpenMP* およこ SYCL*のコンパーダリデー

oneAPI プロガラーニング・モデルは、OpenMP* 才フロードをサボーツる LLVM/Clang バースの統合コンパウリーニを提供いたします。ごによう、OpenMP* 械造を使用て木isticallyのアリケーションを並列化いたします。ターダットデバイスに才フロードするシャムレスな統合が可能にibilityます。インテル oneAPI バース・ツルキットで利用可能性はNTELoneAPI DPC++/C++ バンバイヤリは、制限付け得 OpenMP* と SYCL*の互換性を提供いたします。单一のAPRILKUNは、OpenMP* target 領域または SYCL* 械造を使用て、さまむら間数やコトドセガメト各種のコト領域の実行をデバイスに才フロードお願いいたします。

OpenMP* 和 SYCL* 才 fluoride構造は、別々のフィル、同じフィル、たは同じ関数（制限付き）で使用いたします。OpenMP* およむ SYCL* 才 fluorideコトは、実行可能フィル、静的ライランドリ一、たはさまばまな組み合わせ每一緒にバンドルくださいます。

注：DPC++ 向けの SYCL* 是 CPU 与 ヨーナル oneTBB 的 ナンタムを使用いたします。そのた、CPU 与 OpenMP* 和 SYCL* 的两方を使用いたします。スレットの才一バーネフーマNsを解析すると、その問題が生くださいます。はステムで実行いたします。

# 6.2.1.1. 制限事項

同上。

- OpenMP* ヨイレクチアは、デバイスで実行いたします。SYCL* 力一NES内のは使用くださいます。同樣に、SYCL*コーリドは、OpenMP* target 領域內のは使用くださいます。ただし、木ストCPUで実行いたします。OpenMP*コーリド内分泌SYCL*構造を使用するこはお願いいたします。  
- 予口GLA内0nMP* 0.50000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000   
- 現時点のは、OpenMP* 和 SYCL* 演替方式·拉伊德拉間の直接的相互作用はサボーツ領域いせん。例えは、OpenMP* API 生成了一次性表示、×モリ・才総約は、SYCL* ミートからはアクセスを完成せん。OpenMP* 生成了一次性表示、×モリ・才総約は SYCL* ミートで使用すると、未定義の動作くださいます。

# 6.2.1.2. 例

次のコトは、SYCL*とOpenMP*才ローニ構造を同比アリケロー使用する例を示ります。

```cpp
1. #include <CL/sycl.hpp>
2. #include <array>
3. #include <iostream>
4.
5.
6. float computePi(unsigned N) {
7. float Pi;
8. #pragma omp target map(from : Pi)
9. #pragma omp parallel for reduction(+: Pi)
10. for (unsigned I = 0; I < N; ++I) {
11. float T = (I + 0.5f) / N;
12. Pi += 4.0f / (1.0 + T * T);
13. }
14. return Pi / N;
15. }
16.
17.
18. void iota(float *A, unsigned N) {
19. cl::sycl::range<1> R(N);
20. cl::sycl::buffer(float, 1> AB(A, R);
21. cl::sycl::queue().submit([&] (cl::sycl::handler &cgh) {
22. auto AA = AB.template get_access<cl::sycl::access::mode::write>(cgh);
23. cgh.parallel_for<class Iota>(R, [=](cl::sycl::id<1> I) {
24. AA[I] = I;
25. });
26. });
27. }
28.
29.
30. int main() {
31. std::array<float, 1024u> Vec;
32. float Pi;
33.
34.
35. #pragma omp parallel sections
36. {
37. #pragma omp section
38. iota(Vec.data(), Vec.size());
39. #pragma omp section
40. Pi = computePi(8192u);
41. }
42.
43.
44. std::cout << "Vec[512] = " << Vec[512] << std::endl;
45. std::cout << "Pi = " << Pi << std::endl;
46. return 0;
47. } 
```

suntplulcdtoonvialur的h次的可mandd使用了。

```shell
$ icpx -fsycl -fiopenmp -fopenmp-targets=spir64 offloadOmp_dpcpp.cpp
```

# 說明：

- fsycl 才普専は SYCL* 者有効にしま�。  
- - fiopenmp -fopenmp-targets = spir64 才予は OpenMP* 才ロトを有効にしま�。

次は消费升级ドからの出力例なります。

```javascript
$ ./a.out
Vec[512] = 512
Pi = 3.14159 
```

注: OpenMP* 才Flö-1dが含まておら、通常の OpenMP* メードのみが含まる場合、-fopenmp-targetsを省略た次のコマndは使用しま�。

```txt
$ icpx -fsycl -fiopenmp omp_dpcpp.cpp
```

# 6.2.2 OpenCL* メートの相互運用性

oneAPI フロガラーニング・モDELのは、開発者はSYCL*APIのさまばまな部分からすてのOpenCL*コトの機能を引き統き利用くださいます。SYCL*が提供するOpenCL*コトの相互運用性は、SYCL*が持つ高度なプロガラーニング・モDEL・インーナフイスを利用いたします、從来のOpenCL*コトを再利用のはに役立いたします。その相互運用性モトには2つに主要機能,Noは不行。

1. OpenCL* メートの才総けクトから SYCL* 才総けクトを生成する。例えは、SYCL* バフローは、OpenCL* cl_mem から、たは cl_command_queue の SYCL* ハチ一から構築いたします。  
2. SYCL* 才緱克卜から OpenCL* 曲の才緱克卜を取得る。例は、SYCL* トに開連付けらた暗黓のcl_mem 使用する OpenCL* 力一ルを起動いたします。

# 6.3 DPC++ 与 OpenMP* 才Flö-1d 处理のデバック

木スト·フリツフロー向けにコトを記述、デバック、おば最適化する场合、コトを改善する手順はシングルです。デバックガーニ実行中的ビルド、キヤチ、おばケラツschや不正な結果の原因くださる言語レルのエラーナ対处し、プロフアIL·USILを使用てハフローマンスの問題を特定て修正いたします。

One部分DPC++ 10 OpenMP* 才口一上行的了大化斯为实行之的个

- DPC++ または OpenMP* 才プローロの誤った使い方は、接続くださた才プローロデバイスでプロGRAMが実行さる際に、シャストインタム (JIT) フンバイルいたしますようお願いいたします (その問題は、事前フロー (AOT) 为確認くださいますようお願いいたします)。

- 丶□格拉ムの論理的なエーニによる克莱ツは、木ト、才ロ一ドデバイス、まは各種計算デバイスを連携さるソフウア・stsackで予期ない動作とて現る可能性のはう。原因を究明するには以下が必要です。

- プンテル® フツトリビューニングの GDB 之称の標準デバイガ一を使用て、は状上上的コフで何が起こてい的かデバイ格しま。  
- ヨーダイス固有的デバイガを使用て才ローツデバイスの問題をデバイングいたします。ただし、デバイスのア一きテケチヤ一、計算スレドを表現する規則、まははアSENリ一が木ストとは異なこに注意てくだせ。  
- 力一NEルとデータがデバイス上のやりを行う场合にのみ中間ソフトウア・-StaSSKで現る問題をデバックするには、デバイスと木ト間の通信、およ旬处理中に報告くださる工LA一監視する必要くださいます。

- 木戸トと才フローネデバイスで発生する可能性のは一般的なハフローマングの問題に加て、木戸トと才フローネデバイスが連携するハターニは、アリケーションのハフローマングに大的影響を与えるごさお願いいたします。こりは、木戸トと才フローネデバイス間の通信を監視する必要くださいます1つのケスです。

ごは、才ロ一トロガラムの実行中に利用得起各種デハツ、およむアフーマンスに解析ルとその用法にて説明いたします。

リソーニスを才フローネする擴張機能を備た OpenMP* または SYCL* API 来使用するアプロケーションのトラTPLシuya一テインは、「高度な並列アリケーニンのトラTPLシuya一テイン」(英語)のチuya一トリルを参照てくさい。

# 6.3.1 SYCL* 与 OpenMP* 開発向けの oneAPI ダーロックリル

次に示すつルは、SYCL*およIPv6OpenMP*才ロト卜处理のデバツに役立与否。

SYCL* およんだ OpenMP* 才フローフ处理をデバックするリル  

<table><tr><td>ソル</td><td>使用方法</td></tr><tr><td>環境変数</td><td>環境変数を使用て、プロGPLムを変更するCLSIL、プロGPLムの実行時にOpenMP* お願いいたします。</td></tr><tr><td>GPU向けのプロフィ�ル・ソル REFERer
onetrace リル (GPU 向け PTI)</td><td>SYCL* お願い/openMP* 才プロ一ave oneAPI リルジロと OpenCL* ヒックエンドを使用する场合、そのソルを利用してバクエンドのエラをデバックし、木ストとデバイスの两方でハチーマングのプロフィ�ルを実行いたします。
関連資料:
• Onetrace リルの GitHub* (英語)
• GPU 向け PTIの GitHub* (英語)
• ナンテル® VTune™ ツロフィーラーの「GPU計算/メチア·ドットスボット解析」</td></tr><tr><td>OpenCL* フリケーニjahnsのインターハス
ト・レイヤー</td><td>SYC*L お願い/openMP* 才プロ一ave OpenCL* ヱックエンドを使用する场合、そのライリラリーダ利用してバクエンドのエラをデバックし、木ストとデバイスの两方でハチーマングのプロフィ�ルを実行 ,(。</td></tr><tr><td>インテル® フリトリビューニjahnsの GDB</td><td>通常木ストおよんだバイス(CPU、GPU、FPGA工モレーニjahns)で、論理のうむを調查る際にアリケーニjahnsのソスレルのデバックで使用 ,(。</td></tr><tr><td>アプロケーニン・デバイGb</td><td>ごれらのソルとLANタイムバーケのアプロ一チに加て、開発者は別のアプロ一チから問題を見,Thushing be ごこもごこご。次に例を示ります。 
• 力一ncyルの出力と期待いたします。 
• ダバイGb用途の変数を作成て中間結果を確認 
• 力一ncyル党内結果をTPLINT 
注: SYCL*とOpenMP*は、どらも才FIO-14領域内からのstdoutへの出力をサポーツします。そのSIMDレーニまたはスレットが出力しぃるか確認してckだき。</td></tr><tr><td>SYCL*例外ハンドラーレ</td><td>一部のDPC++ プロガラミングのエーニは、効力は、実行時にフリカを使用するコト内的工RARを診断するに役立与否。詳細とSANPLにしこは、「SYCL*例外」を参照てckだき。SYCL*例外のSANPLにしこは、以下を参照てckだき。 
• イイド对付行列乗算の例外 
• イイド对付行列乗算の無効なCONTEKIST 
• イイド对付行列乗算の競合状態</td></tr><tr><td>インテル®Advisor</td><td>Fortran、C、C++、OpenCL*おばさSYCL*アリカーニュンが最新のプロセSSACA最大限のAAPアーマスを發揮するを支援ります。</td></tr><tr><td>インテル®VTune™ フロフィILAーニ</td><td>NEIYTHIPUSStEmはリモートステムでAAPアーマNs·デーナを叩取て解析いたします。</td></tr><tr><td>OpenMP*才FIO-14·デイレ克莱フ</td><td>「INTELULOIL」によるOpenMP*APRIKAERJONの才FIO-14と最適化」(英語)はは、OpenMP*デイレ克莱フを使用てAAPLEERJONに並列处理を追加する方法を説明いたします。</td></tr></table>

# 6.3.1.1. ダ布鲁克環境変数

OpenMP* 和 SYCL* 的才フローダルタイム、およレルズロ、OpenCL*、シャーダー広バイヤレは、木ストと才フローダルタイス間の通信を監視する環境変数を提供いたします。その環境変数を使用て、才フローダ卜計算向付に選択た的拉丁タイムを検出たは制御,Noきまむ。

# 6.3.1.1.1. OpenMP* 才Flö-1D環境變数

OpenMP* 才Flö一卜がのよう動作すかを理解し、ハクエndの制御に利用くださいます環境変数が用意さていま�。

注: OpenMP*はFPGA テバイスのははサボーツせん。

# OpenMP* 才Flö卜環境變数

<table><tr><td>環境変数</td><td>説明</td></tr><tr><td>LIBBOMPTARGET_DEBUG=&lt;Num&gt;</td><td>デバイス情報の出力を制御いたします。詳細は「LANタイム」(英語)を参照くださいます。その環境設定は、OpenMP* 才プローダンタイムからのデバイス出力を有効にしていたします。以下が報告いたします。
• 检出お願い使用くださいます利用可能性 Lamarタイム(1、2)
• 選択くださutedenancyは開始お願い停止くださいますタイチダ(1、2)
• 使用くださるオフロードデバイスの詳細(1、2)
• ロードさんたサボーツ・ライランドリーリ(1、2)
• 示万欧元メモリーラ割り当てと割り当て解除のサイズとアドレス(1、2)
• ローナス間のデーダコビーハ況の情報、まえ統合共有メモリーヤフローはデバイスマッチング(1、2)
• 力一ncyルの起動と起動时期的詳細情報(引数、SIMD幅、GLEUR情报のは) (1、2)
• 呼出くださったセロレル/OpenCL* API関数(関数名、引数/バラメーテー)(2)
值:
&lt;Num&gt; = 0:無効
&lt;Num&gt; = 1:デバイス検出、力一ncyルCONHAイル、メモリービー操作、力一ncyル呼声突出、ようお願いいたします。その其他へのラガイン依存アクIJON各種のラガインアクIJONからの基本のNeedleは根要の状態を表示いたします。
&lt;Num&gt; = 2: &lt;Num&gt;=1の出力に加えて、上のGPU マンタイムAPI関数が客户的引数/バラメーテーで呼声突出たけは表示いたします。
デバイ卜:0</td></tr><tr><td>LIBOMPTARGET_INFO=&lt;Num&gt;</td><td>它的環境変数は、オフローダンタイムから基本の才口ロート情報の表示を制御いたします。以下を表示いたします。uyaーよ一がlibomptargetにさ;mazamaランタイム情報を要求くださいますようお願いいたします。詳細は「LANSTAR」(英語)を参照くださいます。OpenMP* ダービスカーナルが受け取った�ごデータ引数を出力いたします(1)マッチ��作たアドレスがデバイス・マッチング・データ・テープルに/Subに存在するご示いたします(2)夕一��ットの才ロートが失敗た場合、デバイス・ボイnton・マッチ的内容をダ总承包む(4)デバイス・マッチング・テープルで工CNTリーが変更たと示いたします(8)データがデバイス間でコビローたと示いたします(32)值:(0,1,2,4,8,32)デモルト:0</td></tr><tr><td>LIBOMPTTARGET Plugin_PROFILE=&lt;Num&gt;[,&lt;Unit&gt;]</td><td>它的環境変数は、才ロートかけた OpenMP* ミートのバフローマス・データの表示を有効にしてます。以下を表示いたします。合計データ軸送時間(リートと拉动)徴一夕割り当て回数●モジュールのビルド時間(シャストインタイム・CONBIL)●各力一ncyルの実行時間值:F-無効化T-三菱秒単位のターマングで有効化●T,usec-マイクロ秒単位のターマングで有効化DEMOルト:F例:export LIBOMPTTARGET Plugin_PROFILE=T,usec&lt;Enable&gt;:= 1 | T&lt;Unit&gt; := usec | unit_usec基本のナガーニング・プロフィALSを有効にし、プロガラムの終了時に結果を出力いたします。&lt;Unit&gt;を指定くださいます场合、マイクロ秒がDEMOルトの単にります。</td></tr><tr><td>LIBOMPTTARGET_PLUGIN=&lt;Name&gt;</td><td>その環境変数を使用して OpenMP* 才プローロの実行に使用するバックエンドを選択いたします。
注: ヒルズロのバックエンドは GPU ダバイス关于我们サイバーにいます。</td></tr><tr><td></td><td>&lt;Name&gt;:
LEVEL0 | OPENCL | CUDA | x86_64 | NIOS2 |
level0 | openc1 | CUDA | x86_64 | nios2 |</td></tr><tr><td></td><td>使用するオプロートのTPLUGIDEN名を指定いたします。その�PLEIJSONが指定いたします、才プローロムは他的RTLを口一致いたします。</td></tr><tr><td></td><td>値:
• LEVEL0 本身就是 LEVEL_ZERO - ルルズロ・バックエンドを使用いたします
• OPENCL - OpenCL* メックエンドを使用いたします
デバイ卜:
• GPU 才プローロデバイス: LEVEL0
• CPU まえは FPGA 才プローロデバイス: OPENCL</td></tr><tr><td>LIBOMPTTARGET_PROFILE=&lt;FileName&gt;</td><td>libompttarget がClangの -ftime-trace 才plushon同様の時間プロフィILルの出力を生成くださいますようお願いいたします。詳細は「ラntoniek」(英語)を参照くださいます。</td></tr><tr><td>LIBBOMPTARGET_DEVICE=&lt;DeviceKind&gt;</td><td>&lt;DeviceKind&gt; := 
DEVICE | SUBDEVICE | SUBSUBDEVICE | ALL | 
device | subdevice | subsubdevice | all</td></tr><tr><td></td><td>サフダバイスをuyaーキに公開する方法を制御いたします。 
DEVICE/device: 最上位レBELのデバイスのみが OpenMP* ダバイスと連球を、subdevice 節がサポットります。 
SUBDEVICE/subdevice: 第1レBELのサフダバイスのみがOpenMP* ダバイスと連球を、subdevice 節は無視いたします。 
SUBSUBDEVICE/subdevice: 第2レBELのサフダバイスのみがOpenMP* ダバイスと連球を、subdevice 節は無視 ,(GPU と、サフダのサフダバイスをターツル内的单一計算SLAHUSと制限 ,(GPU と追加の GPU計算LANTAYUM環境変数CFESingleSliceDispatchCCSMode=1も設定必須).(ALL/all: 最上位のデバイスとそのらのサフダバイスがOpenMP* ダバイスと連球を、subdevice 節は無視 ,(GPU と、サフダのデバイスをターツル内的单一計算SLAHUSと制限 ,(GPU と追加の GPU計算LANTAYUM環境変数CFESingleSliceDispatchCCSMode=1も設定必須)</td></tr><tr><td>LIBBOMPTARGET_LEVEL0_MEMORY=&lt;Option&gt;</td><td>&lt;Option&gt; := 0 | &lt;PoolInfoList&gt; 
&lt;PoolInfoList&gt; := &lt;PoolInfo&gt;[, &lt;PoolInfoList&gt;] 
&lt;PoolInfo&gt; := 
&lt;MemType&gt;[,&lt;AllocMax&gt;[,&lt;Capacity&gt;[,&lt;PoolSize]] 
&lt;MemType&gt; := all | device | host | shared 
&lt;PoolSize&gt; := 正の整数 ,, (MB 単位の最大割り当てサイズ) 
&lt;Capacity&gt; := 正の整数 ,, (单一ロリクからの割り当て数) 
&lt;PoolSize&gt; := 正の整数 ,, (MB 単位の最大脱トサイズ)</td></tr><tr><td></td><td>再利用可能性MXMULERの構成を制御 ,(デバイは、合計salasが &lt;PoolSize&gt; 足は最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大大</td></tr><tr><td>LIBBOMPTARGET_LEVEL0_STAGING_BUFFER_SIZE=&lt;Num&gt;</td><td>Ste豕-バフア-サイズを &lt;Num&gt; KB に設定 ,(Ste豕は、合計salasが &lt;PoolSize&gt; 足は最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大最大大</td></tr><tr><td rowspan="2">LIBBOMPTARGET_LEVEL_ZERO_COMMANDBatch=&lt;Value&gt;</td><td>&lt;Value&gt; := &lt;Type&gt;[, &lt;Count&gt;] &lt;Type&gt; := none | NONE | copy | COPY | compute | COMPUTE &lt;Count&gt; := バッチ处理するコマンドの最大数</td></tr><tr><td colspan="1">ターダット領域のコマンドバチ处理を有効にしてます。 &lt;Type&gt;=none | NONE: バッチ处理を無効にしてます。 &lt;Type&gt;=copy | COPY: ダーダ軽送でターダット領域のコマンドバチ处理を有効にしてます。 &lt;Type&gt;=compute |COMPUTE: ダーダ軽送と計算にターダット領域のコマンドバチ处理を有効にし、コピーエンジの利用を無効にします。 &lt;Type&gt;がcopyまたはcompute(有效)のないかて、 &lt;Count&gt;が指定くださいますようお願いいたします。 メフィルト：&lt;Type&gt;=none (無効)</td></tr><tr><td>LIBBOMPTARGET_LEVEL_ZERO_USE_IMMEDIATE_COMMAND_LIST=&lt;Bool&gt;</td><td>&lt;Bool&gt; := 1 | T | t | 0 | F | f
カーネル送信に即時コマンドリストの使用を有効/無効ります。 メフィルト:無効</td></tr><tr><td>OMP_TARGET_OFFLOAD=MANDATORY</td><td>这是我们OpenMP*仕様で定義いたします。 https://www.openmp.org/spec-xml/5.1/openmpse74.html #x340-515000617 (英語)</td></tr><tr><td>ONEAPI_DEVICE_SELECTOR</td><td>这是我们デバイス選択環境変数は、OpenMP*アTPLケーニングの実行時に使用可能なデバイスの選択を制限するため使用いたします。デバイスを特定のターリフ(GPUやアクセラレーダー)”んだはバッチenlist(レパターンやOpenCL*oled)に制限する场合に便利,NoAPI_DEVICE_SELECTOR構文はOpenMP*と共有のはり、デバイスを選択する;butoで)=(oneAPI DPC++ ヒンパイヤローのド kcμntb(英語)を参照してる(&lt;だい)。</td></tr></table>

# 6.3.1.1.2. SYCL* & DPC++ 環境变数

InntelDPC++CONVILRA-は、すての標準SYCL\*環境変数をサロトしま。�ての環境変数にて是GitHub\* (英語)を参照てくさ。DEVUGd注目はきは、次のSYCL\*環境変数及追加のレル口環境変数です。

SYCL* DPC++ 環境变数  

<table><tr><td>環境変数</td><td>説明</td></tr><tr><td>ONEAPI_DEVICE_SELECTOR</td><td>その複雜な環境変数を使用すると、ランタイムで使用得起のランタイム、計算デバイス IDを利用可能性をはんだ組み合わせのサフローに制御,Noし。計算デバイス IDは、SYCL*API、clinfo、たはは sycl-1s (0から始まる番号)にて返さるIDに対応いたします。そのIDを持つデバイスが特定のタイドお願いいたします、特定のランタイムをサボーツするかはは関連性,Noかngは指定のセレクタ-gpu_selector等等)を使用て、ONEAPI_DEVICE_SELECTORのフィルターヤー除む以外は子は要求いたします。詳細にしだは、GitHub*にある環境変数の説明を参照くださいます。https://github.com/intel/llvm/blob/sycl/sycl/doc/EnvironmentVariables.md(英語)次のうな値を含ります。·opencl:cpu -利用可能性をはんだCPU メデバイスでOpenCL*ランタイムのみを使用します·opencl:gpu -利用可能性をはんだGPU メデバイスでOpenCL*ランタイムのみを使用します·opencl:gpu:2-GPU%=2-GPU%=3番目のデバイス%=2番目のGPU%=2番目のデバイス%=2番目のGPU%=2番目のGPU%=2番目のGPU%=2番目のGPU%=2番目のGPU%=2番目のGPU%=2番目のGPU%=2番目のGPU%=2番目のGPU%=2番目のGPU%=2番目のGPU%=2番目のGPU%=2番目のGPU%=2番目のGPU%=2番目のGPU%=2番目のGPU%=2番目のGPU%=2番日のリフローは使用します·opencl:cpu,level_zero-GPU%=2-GPU%=3番目のデバイス%=2番目のリルズロランタイムのみを使用します·opencl:cpu,level_zero-GPU%=2-GPU%=3番目のデバイス%=2番目のリルズロランタイムのみを使用します、サボーツ=}计算デバイス%=lelbelzロランタイムを使用します。デフィルト:利用可能性をはんだランタイムとデバイスを使用します</td></tr><tr><td>ONEAPI_DEVICE_SELECTOR</td><td>そのデバイス選択環境変数にually、SYCL*バーリ�のアリケーニングの実行時に使用するデバイスの選択を制御,Noし。デバイスを指定のタイ徴(GPU or Ackela-Lea-ta-)早已はハク克エンド(レルズロ或 OpenCL*)に制限するの已役立与否。そのデバイス選択の力は、ONEAPI_DEVICE_SELECTORを置き換うものです。ONEAPI_DEVICE_SELECTORの構文はOpenMP*と共有さてお、デバイスを可能にしります。詳い説明は、https://intel.github.io/llvm/EnvironmentVariables.html(英語)を参照くださいます。</td></tr><tr><td>SYCL_IR_trace</td><td>その環境設定は、ランタイムからのデフロー出力を効に,Noし。值:1-SYCL*ラフローとデバイスが検出之日起使用たを報告,No引数と結果の值を含むSYCL*API呼吁出を報告,No-1-利用可能性をはんだリレスを報告,No者。デフィルト:無効</td></tr><tr><td>ZE_DEBUG</td><td>その環境変数は、ランタイムが使用くださいます際にレBELズロ・バックエンドからのデバック出力を有効にしてます。以下が報告いたします。
• レBELズロ APIの呼声出于
• レBELEZロイランド情報
值:任意の値で定義くださ过的変数(有效)
デ fasルト:無効</td></tr></table>

# 6.3.1.1.3. 沙ト向の診断情報を生成る環境変数

レルズロ・バックエンドは、動作を制御て診断を支援するい backsの環境変数を提供いたします。

- トルロ仕樣、コア・プロダムンダ・ガイド：

https://spec.oneapi.com/level-zero/latest/core/PROG.html#environment-variables (英語)

- トルロ仕樣、ツル・フロムラルンダ・ガイド：

https://spec.oneapi.com/level-zero/latest/tools/PROG.html#environment-variables (英語)

デバック情報の追加リソーナスは、実行時まは事前コンパル(AOT)時に、レルズロまは OpenCL* ヒックエンド(OpenMP* 才フロービドと SYCL*/DPC++ マンタイム使用くださる)にようお願いいたします。GLP-10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
形式コトを生成いたします。環境変数の完全なリスは、https://github.com/intel/intel-graphics-compiler/blob/master/documentation/configuration_flags.md (英語)を参照てくだい。ハフローマスの問題をデバックする際に必要くださいます。次の2つです。

- IGC_ShaderDumpEnable=1 (デフィルトは0) によう、インル® プラフィックス・コンバイヤーが生成する satisfてのLLVM、アSENプローリ、およんだ ISAコトが /tmp/IntelIGC/<application_name> に書きお願いいたします。  
- IGC_DumpToCurrentDir=1 (デフィルは0)は、IGC_ShaderDumpEnableにて生成坐着すばてのフィアルを/tmp/IntelIGC/<application_name>に書きお願いいたします。多数のフィアルが生成坐着的可能性のはた、一時デレクトリ一作成するとを推奨いたします。

oneAPIの異なバーニューニ間でOpenMP*才ロービやSYCL*才ロービ·アリケーニンのハフーマングの問題が生じる场合、異なるコンバイヤー・才総ドを使用った、デバイガを使用する等诸多、IGC_ShaderDumpEnableを有効に結果フィルを提供する必要くださいます。互換性の詳細にしぃは、「oneAPI バイランドリOneの互換性」を参照てくだい。

# 6.3.1.2. 才FlO-ト·イnta-te-SetbT·U-尔

才フローロ・ソフローの自身に組みお願いいたします。デバイガーニと診断情報に加て、才フローロ・サイランドンを介て送信いたします。API呼吁出はとデーを監視するは有益です。レルズロはは、アリケーニンが onetrace またはze_tracer メルの引数と実行いたします。场合、アリケーニンのレルズロはさまむ動作がインターミット之称

報告いたします。OpenCL* %=、OpenCL* 呼出しをインーネットて報告するライランドリーテD.Library_PATHに追加て、環境変数を設定しきアルの診断情報生成を制御いたします。た、onetrace はは cl_tracer 使用て、アTPLKEIJONの OpenCL* API 呼出しのさま資金情報をレトするともごきます。たても、APRILKJUNは onetrace 或 cl_tracer リルの引数と実行いたします。

# 6.3.1.2.1. OpenCL* トリルーニンのインセ bt・レイヤー

ごのライフローは、SYCL* または OpenMP* 才プロドのバックエンドと OpenCL* が使用くださる场合にデバイ格お願いいたします。OpenCL* が SYCL* または OpenMP* 才プロドのバックエンドによる場合、ごのソルはバフローの才一ハーマリト、メモリーリー、ボインタ的不同致を検出し、ランタイム·エーマ・マツsei-ジのよ詳い情報を提供します(CPU、FPGA、またはGPUのいすか計算デバイスoled場にごれらの問題を診断いたします)。OpenCL* ヒックエンドを使用するプロガムで onetrace 来利用する场合や、レBELSEロ・バックエンドを使用するプロガムで OpenCL* トリケーニ広・ライフローのインターミ�ト・レイヤー利用する场合には、あまき役立たないごに注意てくだき。

追加のリソーネs:

- OpenCL* トーニー・リド・デルド・使用法に閲る各種情報は、https://github.com/intel/opencl-intercept-layer(英語)から入手いたします。

注: 最良の結果を得るには、次のflagraを使用てcmakeを実行いたします。

```txt
- DENABLE CLIPROF=TRUE -DENABLE CLILOADER=TRUE 
```

- 同樣のソル (CLIntercept) に開る情報は、https://github.com/gmeeker/CLintercept (英語) お願いいたします。https://sourceforge.net/p/clintercept/wiki/Home/ (英語) て入手いたします。  
- OpenCL* トリケーニングのインセフ・レイヤーの制御に関連する情報は、https://github.com/intel/opencl-intercept-layer/blob/master/docs/controls.md (英語)にごります。  
- GPUの最適化に閲る情報は、『oneAPI GPU 最適化ガイド』(英語 | 日本語)から入手いたします。

# 6.3.1.2.2. GPU 向はのプロフィル・ルのインーフエス (onetrace、cl_tracer およze_trace)

OpenCL* トリケーニルのイターテフロービーと同様に、こらツルは、レルズロがSYCL*ははOpenMP* ヒックエンドaaSる场合にデバイ務およんだアフローマス・デー�を収集いたします。レルズロは、GPU为実行さる計算のバクク工ドとてのみ利用くださいます。(現時点で、CPU和FPGA向けのレルズロ・バクク工ドはようお願いいたします)。onetrace ヒルは、https://github.com/intel/pti-gpu(英語)にあ的GPU向けのプロフィAIL·ツル・イナーフ�イス(GPU向けPTI) プジチクトの一部です。そのプロジチクはは、レルズロははOpenCL*才Flor一ド・バクク工ドからのアクテビデイのみをトレーするze_tracer或cl_tracer舌ルも含まててい).(Ze_tracerおよんだリク工ド使用するアリケーニンで使用くださいます、出力を生成ませんだ、onetrace是使用誃才Flor一D・バクク工ドにかわりな<出力くださいます。

onetrace メルはソーナスで配布いたします。ツルのビルドに親る手順は、https://github.com/intel/pti-gpu/tree/master/tools/onetrace(英語)を参照くださいます。そのツルは次の機能を提供いたします。

- 呼出のロム：そのモードは、すての標準レルズロ (L0) API 呼出とその引数、およむチムsts�予付きの尻値をトレスお願いいたします。ごによう、馬トプロガラムが接続た计算デバイスを利用する際に発生する障害の補足情報が得りります。  
- 木戸トとデバイスのタイミング:陛下そのAPI呼声出の存続期間、カーナルの存続期間、およんだリケーニン全体の実行時間を提供いたします。  
- ヨーナイス・タイムライド・モーツ：各テイス・アケテリデローのタイムstsUNPを提供いたします。surdeのタイムstsUNPは、同じ(CPU)時間スケルで示されります。  
- Chrome* 呼出のロダモーツ: chrome://tracing プラウサイツル (英語) て開くごが成功的 JSON 形式への API 呼出出をダフリestr。

ごの従一夕は才ロトの障害やハフ0－MANスの問題をデバックするに役立らま。

追加のリソーリス:

- GPU 向付プロフィル・ソル・インーフロー (GPU 向付 PTI) GitHub* プロジcepts (英語)  
- onetrace メルの GitHub* (英語)

# 6.3.1.3. ヨンテル® ヨストリビューニングの GDB

イル® ヨスリビューニングの GDBは、プロダムの状態を調査お願い变更ablerのアリケーション・デバイガ一定能。アリケーションの木戸部分とデバイスに才フロードた力一nergの两方を、同じデバイ格sesssionでシムレスにデバイ格いたします。そのデバイガ一是、CPU、GPU、およFPGA工ヨレーニング・デバイスをサポーツします。主な機能を以下に示ります。

- GPU ヨバイスに自動のに接続てデバイ�を監視  
- 德専格用に JIT メンバイルさた、または動のにロ一ドさた力一ルバイナリ一を自動検出  
- トロガラムの実行を停止する克莱ルトを設定 (力一内科部と外部の两方)  
- スレットのリスト表示、現在のスレット・コンテキストへの切り替え  
- トデなSIMDレーニルス表示、現在のSIMDレーニルのCONTERSはスレドごに切り替  
複数のスレットとSIMDレーニン·コンテキトの式価の評価と出力  
- 責江夕一值の調查と変更  
- マシング命令を逆アSENS格尔  
間數呼丶出丶斯夕克の表示とナビゲート  
- ヨースと命令レルのStテツ複実行  
- 非停止おはみすて停止のデバイ格モード  
- 元代のデモーテー・デモーテー・デモーテー・デモーテー・デモーテー・デモーテー・デモーテー・デモーテー・デモーテー・デモーテー・デモーテー・デモーテー・デモーテー・デモーテー・デモーテー・デモーテー・デモーテー・デモーツロー・デモーツロー・デモーツロー・デモーツロー・デモーツロー・デモーツロー・デモーツロー・デモーツロー・デモーツロー・デモーツロー・デモーツロー・デモーツロー・デモーツロー・デモーツロー・デモーツロー・デモーツロー・デモーツロー・デモER・デモER・

```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
``

# 6.3.1.4. 才Flö-ind向着Inn-Indel Inspector

注：「不テル」Inspectorは、「不テル」HPC リルキット 2024.1 以降に含まななにらもた。

Inspecior 15.

前述のツールや手法は異な、インル InspectorはGPUはもはFPGAと通信する才ローダコトの工ヤを検出るごはてきません。インルInspectorは、CPUをタ�ットと力一ルを実行するようにSYCL*ははOpenMP*ランタイムを設定必須のは験。解析を実行する前、次の環境変数を設定必須のは験。

CPU 微巴式カ力一ルを実行するように SYCL* トリケーニンを設定いたします。

```powershell
$ export ONEAPI_DEVICE_SELECTOR=opencl:cpu 
```

CPU 微巴斯力一零尔を実行するようにOpenMP* トリケーニンを設定いたします。

```shell
$ export OMP_TARGET_OFFLOAD=Mandatory $ export LIBOMPTARGET_DEVICETYPE=cpu
```

- JIT メンバイヤラ一まはんタイムでコト解析とトレーニス効効にしります。

```shell
$ export CL_CONFIG_USE_VTUNE=True
$ export CL_CONFIG_USE_VECTORIZER=false 
```

次のいじてかのコマンドを使用て、コマンドラインから解析を開始いたします。インルInspectorのGRAFIカル・ユーダー・インターフエイスからも開始いたします。

- Xモリ一: inspxe-cl -c mi3 -- <app> [app_args]   
- StreLDD化: inpxe-c1 -c ti3 -- <app> [app_args]

次のコマンドを使用て解析結果を表示いたします。

```powershell
$ inspxe-cl -report=problems -report-all 
```

SYCL* 或 OpenMP* 才Florod-口口G拉夫OpenCL* 次不正的PIN-渡了、誤的Sledd 从B克工下不正的PIN-渡场合、INnel Inspectorは問題を警告し。它は、INT-LeY一或Dg-使用用：

『イル Inspector ハーダーガイド (Linux* 版)』(英語)んだ『イル Inspector ハーダーガイド (Windows* 版)』(英語)で詳細を参照くださいます。

# 6.3.2 才 fluoride处理のトレーナス

GPU に計算を才フロ一ドするプロガラムが開始坐着場合、プロガラムの実行に関連する多くのCONPOneトが動作いたします。マシング非依存のコーはマシング依存のコーはCONPハリル、デーとハリナリをデバイスにコビ一て、結果を戸必要のはります。ごはは、「oneAPI ダーヒツル」で説明たリル使用て、すばてのアクテリデーをトレーニス的方法を示ります。

# 6.3.2.1. 力一不儿設定時間

才Fl口一D一卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡

OpenMP* 才Flor一端口G拉ムはは、環境変数LIBOMPTARGET Plugin_PROFILE=T[,usec]を設定すると、才F口一端ModuleBuildのビルドに必要な時間が報告いたします。こをF口G拉ムの実行時間全体比較しま�。

SYCL* 才口一上口格拉卡は、力一ルのせトア的判断は判断はに困難に

- Le菲尔口は OpenCL* がバックエンドolingの场合、onetrace or ze_tracer yて返さるデバイスのターニングとターツルフロー、力一内科のせットアpped時間を求えらむ。  
- OpenCL* がバックエンドの场合、OpenCL* プリカーニングのインセ bt・レイヤー使用て情報を取得する際に、BuildLogging、KernelInfoLogging、CallLogging、CallLoggingElapsedTime、KernelInfoLogging、HostPerformanceTiming、HostPerformanceTimeLogging、ChromeCallLogging、または CallLoggingElapsedTime フラムを設定くださいます。onetrace or cl_tracer oて返さるデバイスのターヌンgrおよんだチムラフロー、カーナルのセットアツpf時間を求むごとてごきります。

之的方法により、LIBOMPTARGET.PLGIN_PROFILE=Tにて戸さる情報を補足くださいます。

```
```
```
```
```
```
```
```
```
```
```
```
```
```
``

# 6.3.2.2. ロフローの作成、サイズ、およんだこ一の監視

バフローが作成た時期、作成た的数、おはこるが再利用るか、た常に作成おは破棄るかを知るごは、才ローツ・アリケーニンのバフーマンスを最適化する上重要な键とりま。しし、OpenMP*或SYCL*等の高レル・プロガラミング言語使用する场合、れらは必しぃも明確ない可能性のは」一からバフローの管理は隠匿さて。

高レルは、プロダムの実行時にLIBOMPTARGET_DEBUGおよSyCL.PI_TRACE環境変数を使用て、バフア一関連するアケテビデイ一追跡くださいます。LIBOMPTARGET_DEBUGは、SYCL.PI_TRACEよう多くの情報を提供いたします(作成た的バフアアドレスとサイズをレト)。SYCL.PI_TRACEは、API Respirantleは、API Respirantleは、API Respirantleは

低レルは、レルズロのバックエンドを使用する场合、onetraceやze_tracerの Respirantleは、引数を含むすてのレルズロAPI Respirantleに開る情報を提供いたします。例は、バフア一作成 Respirantleは、leMemAllocDevice等）で、デバイスと間で渡さる結果バフア一のサイズを取得くださいますた役立つご)+(Xモリ一軽送を含む)をダnp説るごが生態。ArckyDlelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelele

OpenCL* がバックエンドの场合、OpenCL* プリカーニングのインーベフローヤーハーを使用する際に、CallLogging、CallLoggingElapsedTime、おば ChromeCallLogging フラジを設定て同樣の情報を取得いたします。onetraceやze_tracerの版权声明は口ガモードは、引数を含むすてのOpenCL* API呼吁出于関涉的情報を提供いたします。上記と同様に、onetrace和ze_tracerを使用すると、デバイス·タイムライドですてのOpenCL*デバイス間へのアクテビテée(メモリ一軽送を含む)をダnp説る这句话ごきます。

# 6.3.2.3. 合計軸送時間

合計デ一夕軽送時間を力一ル実行時間比較するとは、接続いたします。デバイスへの計算の才ロトが有益のはか判断するとが重要にうるとが)”

OpenMP* 才Flö-indプロgrämはは、LIBOMPTARGET_PLGIN_PROFILE=T[,usec]を設定すると、ルト(DataAlloc)、才Flö-indデバイスの読み取り(DataRead)、およ書き行銷(DataWrite)に必須な時間がレーリトさしま�(ただし合計とて)。

SYCL* 使用説用 C++ 二元化的「日夕軸送時間」判断説用は上に困難にの言語。

- LeルズロまたはOpenCL*がバックエンドによる场合、onetraceやze_tracerよて返さるデバイスのタイ モングとタイムラインから、合計デ一夕軽送時間を求われます。  
- OpenCL* がバックエンドの场合、onetrace たけは cl_tracer 使用するか、OpenCL* 予りケーニングのインターミング・レイヤー使用て情報を取得る際に、BuildLogging、KernelInfoLogging、CallLogging、CallLoggingElapsedTime、KernelInfoLogging、HostPerformanceTiming、HostPerformanceTimeLogging、ChromeCallLogging、たけは CallLoggingElapsedTime フラムを設定くださいます。

「ITUNETVITUNETVITUNETVITUNETVITUNETVITUNETVITUNETVITUN

# 6.3.2.4. 力一不儿实行時間

OpenMP* 才Flö-indプロダムはは、LIBOMPTARGET_PLGIN_PROFILE=T[,usec]を設定すると、才Flö一卜さたすての力一neaル (Kernel#...)の合計実行時間が報告いたします。

SYCL* 使用的才□一卜力一不儿向付:

- LeßルセロまたはOpenCL*ハクエンドは、onetraceやze_tracerのデバイス·タイチング·モーツを使用てすての力一内科のデバイスへの実行時間を取得いたします。  
- OpenCL* がバックエンドの场合、ontrace たは cl_trace 者使用るか、OpenCL* トリケーニンのイ�ターベフロ・レイヤー使用て情報を取得する際に、次のラフム設定くださいます：CallLoggingElapsedTime、DevicePerformanceTiming、DevicePerformanceTimeKernelInfoTracking、DevicePerformanceTimeLWSTracking、DevicePerformanceTimeGWSTracking、ChromePerformanceTiming、ChromePerformanceTimingInStages。

「INテル®VTune™ フロフィーリーカ力一neaルの実行時間を解析する方法の詳細にしぃは、『Inテル®VTune™ フロフィーリー・デーガイド』の「アクセラーテー一解析gregul一」を参照てくだき。

# 6.3.2.5. ヨバイスカーネルが Respirant、Streptoidが生成する场合

場合によては、才ロ一力一ルが作成さ、実行を開始するかの前にデバイスへ軸送さるごがは常は、力一ルの実行に必要なての徴一夕と制御が軸送た後にの。

インル® ヨイストリビューニングの GDBを使用てデバイスカーナルにTPLERクロイINTを設定いたします。その、カーネル引数の照会、スレットの生成と破棄の監視、コト内它的現在のスレットの位置とリスト表示 (info threadを使用)なります。

# 6.3.3 才 fluoride处理のデバック

# 6.3.3.1. 異なルタムたは計算デバイスで実行

才Flor一DpGraMg正常I实行之的成、生成之的结果为正不场合、比较的容易的确方法是、OpenMP\* APLKJONはLIBOMPTARGET_PLGIN 与OMP_TARGET_OFFLOAD 環境变数、及SYCL\* APLKJONはONEAPI_DEVICE_SELECTOR 環境变数使用。別の兰夕（OpenCL\*とレル））は计算デバイス(CPU和GPU)为APLKJONを実行するごて。異る兰夕間再現さる工一、は、ほんの場合、兰夕的问题上排除可以。て丁德尔斯間再現出的工一の大部分は、不良八一DwArの問題を排除可以。

# 6.3.3.2. CPU実行をデバイ格

才Fl口一DコトをCPUで実行するには、木ス卜実装とOpenCL\*のCPUバーニヨンとう2つの才PUNがりま。木ス卜実装は、才Fl口一DコトのNEIテIPF实装のは、才Fl口一Dさるいコトと同じょうに丁BABB得きま

一。OpenCL\*のCPUバーニュは、OpenCL\* ランタイムとコト生成プロセスを通過しおが、最終のにインテルoneTBB ランタイムで実行いたします通常の並列コトに係ります。繰り返しおは、它によう慣態親んだアSENリーと並列处理×力ニズムのデバイ環境が提供くださいます。ロインターは-StaSS全体にアクSESます、De-atu直接参照,No。も、才レーネイン格·StStM·ProSの通なの上限を超る×M1一制限はあらせん。

CPU 才 fluoride 实行のエラ一を検出て修正すると、GPU 才 fluoride 实行で発生するエラ一是りもはるかに減少労力でエラ一を解決いたします、GPU 或はかのアクセレ一たが接続ったシスチムを利用する必要くださいます。

OpenMP* トリケーニフは木ト実装を適用するには、target また device 構造を削除て、通常の木トOpenMP* ミードに置き換えま。LIBOMPTARGET Plugin=OPENCLが設定せ、GPU才ロトが無効にると、才ロトドは OpenMP* ランタムで実行せ、イテルoneTBB 並列处理を行いま。

SYCL* トリケーニンで ONEAPI_DEVICE_SELECTOR=hostを設定すると木戸デバイスはシングルスレットで実行を進行。二是、デタ競合やデットロック等スレット化の問題が実行工娘の原因くださるか判断するに役立与否。ONEAPI_DEVICE_SELECTOR=openc1:cpuに設定いたします、CPUのOpenCL* ランタイムが使用いたします、インテル® oneTBBが並列处理を進行いたします。

# 6.3.3.3. 1nTeL®DvStRlBvUeJShonGDB为使用Gpu实行vTb

インル® ヨイストレービューニjahの GDB にしだは、『インル® ヨイストレービューニjahの GDB 导入ガイド (Linux* 版)』(英語) たは『インル® ヨイストレービューニjahの GDB 导入ガイド (Windows* 版)』(英語) に詳しく記載いたします。有用なコマンドにしだは、インル® ヨイストレービューニjahの GDB 「リフアレUNS・シート」(英語) て簡單に説明くださいます。ただし、GDBを使用て GPU シリケーションをデバックする方法は、ホストその手順のは若干異たたの一部のコマンドの使い方が異なり、見慣態ない出力が表示いたします。その違いの一部をごこて紹介いたします。

「イル® ヨストリビューニングのGDBを使用たデバックのチートリル(Linux*版)」(英語)は、SYCL*プロGLAMAのデバックセSSFUNを開始し、カーネル内にトレーニ克ロイINTを設定し、プロGLAMAを実行てGPUに才FLO一ドしロ一力ル値を出力し、スレットのSIMDLEUN5を切り替え変数を再度出力するサNFILのデバックseschUNを紹介ていま。

通常のGDBと同様に、command <CMD>にはGDBのhelp <CMD>コmandbを使用て、<CMD>の情報テキストを読み取り MSR。次に例を示し MSR。

```txt
(gdb) help info threads   
Display currently known threads.   
Usage: info threads [OPTION]...[ID]...   
If ID is given, it is a space-separated list of IDs of threads to display. Otherwise, all threads are displayed.   
Options: -gid Show global thread IDs. 
```

# 6.3.3.3.1. GDB 为INFEXRA一、SRELL、およこSIMDレんの参照

APRIKJONsLREHd=、DgA-1F 1Ee表示成。表示的情ID上Sld 停止在的位置含。GPU SLEdd的场合、DgA-是AkTIPSIMD Lons也表示。

上記の例のは、GDBのinfo threadsコマンドでスレットを表示いたしますが、見慣り等形式で情報が示りますご)”とお願いいたします。

```txt
Id Target Id Frame 1.1 Thread <id omitted> <frame omitted> 1.2 Thread <id omitted> <frame omitted> \*2.1:1 Thread 1073741824 <frame> at array-transform.cpp:61 2.1:[357] Thread 1073741824 <frame> at array-transform.cpp:61 2.2:[1357] Thread 1073741888 <frame> at array-transform.cpp:61 2.3:[1357] Thread 1073742080 <frame> at array-transform.cpp:61 
```

GDBは次の形式でスレットを表示いたします：<インフ利亚一番号>.<スレット番号>:<SIMDレーニn/s>

例えは、スレット ID 2.3: [1 3 5 7]は、インチリーダー2で実行いたします。

GDB 用語の「inferior (インチアーリー)」は、デバックするプロセスを指いたします。GPUに才ローダリるプロダムのデバックセッチには、通常2つのインチアーリーくださいます。プロダムの木ストを示す「ネイチア・インチアーリー」(上記のインチアーリー1)と、GPUデバイスを示す「リモート・インチアーリー」(上記のインチアーリー2)です。インテルデイチリビューニohnの GDBは自動にGPUインチアーリーを生成するたて、特に操作は必要お願いいたします。

式の值を出力すると、式は現在のスレットの現在の SIMD マーニングのコンテキスを評価いたします。thread 3:4、 thread :6、または thread 7 な哪家 thread ミマンドを使用て、スレットと SIMD マーニングを切り替え的成本はきま�。最初のコマンドは、スレット3と SIMD マーニング 4に切り替え)=(2) 番目的コマンドは、現在のスレットで SIMD マーニング 6に切り替え)=(3) 番目的コマンドは、スレット 7に切り替え)=(4) 選択出来的デフィルトーニングは、以前に選択したレーニング(アクテイドのはれ)=5)、またはスレット内最初にアクテイドに变了的レーニングの哪方かに)=(6)

thread apply メマンドは、同様に広域たは集中的一员可能性のはんだ可能性のはんだ。(これにやり、変数を調査するコマドからの出力を制限しぃさくり)=SIMDレーニングのデバイングの詳細と例についは、「インテル®デイストリビューニングのGDBを使用た徴バイングのチートリアル(Linux*版)](英語)を参照てくだい。

GDBのスレットとインチアーリフリーローツーフローに開る詳細は以下を参照くださいます。

- https://sourceware.org/gdb/current/onlineDocs/gdb/Threads.html (英語)   
- https://sourceware.org/gdb/current/onlinedocs/gdb/Inferiors-Connections-and-Programs.html# Inferiors-Connections-and-Programs (英語)

# 6.3.3.3.2. 斯ケジーラーの制御

デフィルトのは、スレットが預一クボイCNTに到達すると、デバßガ一は預一ク・ボイCNT・ヒット・イCNTをeu一��一に通知する前にすてのスレットを停止いたします。二者はGDBのすて停止モトです。非停止モトはは、ほかのスレドが実行くださる間、スレットの停止イCNTが表示いたします。

surve停正一上口は、sleddd加再開さると(例:continue mond成通常の状以再開出、はnext mondfoStePP实行的场合)、かのsèてのsledd也再開出。sledd化之的aprikeond复数的PreeoINTa设定也到达次的Sledd加续<steod有不可能性有的t、混乱招可能性为。

set scheduler-locking メマンドを使用すると、現在のスレットが再開たとにほかのスレットが再開ないように制御するとが許令。这也、現在のスレットのみが命令を実行してるとに、ほかのスレットの介入を避けるに有効です。help set scheduler-locking と入力すると利用可能性は予言は表示いたします。詳細は、https://sourceware.org/gdb/current/online/docs/gdb/Thread-Stops.html（英語）を参照てくだいたします。SIMDレーニは個別に再開能否いとに注意てくだいたします。这也、バームなのスレットともに再開能否い。

非停止モーツドのデ fasルトのは、現在のスレットのみが再開いたします。surdeのスレットを再開するには、continue ミマンドで-a フラムを指定いたします。

# 6.3.3.3.3. 1つ以上的スレット/レーニンの情報をダフ(Thread Apply)

複数のコンテキットの值を調査すると必要なともお願いいたします。そのようALLENGe apply ミマINTド使用しまう。例えは、以下はスリド2,5のSIMDレーニn3-5に对てprint elementコマINTド実行いたします。

```txt
(gdb) thread apply 2.5:3-5 print element 
```

同様に、以下は、現在のスレットの SIMD 責一 3、5、およこ6のコンテキストに対し print elementコマンドを実行いたします。

```txt
(gdb) thread apply :3 :5 :6 print element 
```

# 6.3.3.3.4. プーニ克莱ト停止後のGPUコトのスルフ実行

GPUに才Fl口一上さ力一不内內停止的は、力一不内のS一行にPレ克P点卜設定的けは。GPUスレドがそのS一行に到達ると、デバガ一は実行を停止てPレ克P点トの到達を示し。S一行单位でスレドをStePP实行するには、stepま末はnextコマnd使使用。stepコマndは間数にStePP。 nextコマndは間数呼出しをStePP一。StePP实行前、かのSteLdの介入を避たset scheduler-locking stepを設定這一を推奨し。

# 6.3.3.3.5. 1nTeL®DvStIbVbUeJShonのGDB为使用的DPC++实行形式为比尔

木戸·アリクーニンのデバックと同様に、GPUでデバック可能なバイナリを作成するには、いっかの追加ラフムを指定する必要くださいます。詳細にしぃては『インル®デストリビューニングのGDB導入ガイド(Linux*版)』(英語)を参照てくだいたします。

JIT ニンパウルを行う際にスムーネズなデバックを可能にするには、-g フラガを指定してコンパウローのデバック情報生成を有効にし、アリケーニングの木ストと JIT ニンパウルカーナルの两方で -00 フラガを指定て最適化を無効にしま�。力一NELのFLAGはリUNク時に適用いたします。次に例を示ります。

- トロガラムのルicpx -fsycl -g -00 -c myprogram.cpp  
- トロガラムのリンク:icpx-fsycl-g -00 myprogram.o

Cmake 要使用 CMake_BUILD_TYPE 的 Debug 夕引为使用。  
CMAKE_CXX_FLAGS_DEBUG 变数可以追加为。次例所示。

```cmake
$ set (CMAKE_CXX Flags_DEBUG "${CMAKE_CXX Flags_DEBUG} -00") 
```

デバックforwardにビルドくださたアプロkeeヨンは、通常の「リリーフ」ビルドで最適化くださたアプロkeeヨンのはも起動に時間かける场合お願いいたします。そのたて、デバックガーミ起動すると、プロGRAMの実行速度が遲なったように感激いたします。ごに問題が生じる场合、大規模なアプロkeeヨンの開発者は、プロGRAMの実行時はなかくビルド時代 JIT才ロービーは事前(AOT)コンバイルするとを推奨いたします(ご之称,-g -00を使用するとビルドに時間かける场合お願いいたします)。詳細にしぃては、「コンバイルの手順」を参照てくだい。

GPU向けの事前ルを行か、夕一格トデイスに对应了德専は指定する必要のは。次のコマド使用て、現在のマド利用可能GNDEHIS才PON为确认き。

```txt
$ ocloc compile --help 
```

さらに、力一NEルのデバイ�モトを効にしま。次のAOT ニンバイルの例は、KBL ニバイスをターダットにしも。

```shell
$ dpcpp -g -00 -fsycl-targets=spir64_gen-unknown-unknown-sycldevice \
-Xs "--device kbl -internal_options -cl-kernel-debug-enable -options -cl-opt disable" myprogram.cpp 
```

# 6.3.3.3.6. 1

□glaomcunpaikllo

```shell
$ icpx -fiopenmp -00 -fopenmp-targets=spir64 -c -g myprogram.cpp
$ icpx -fiopenmp -00 -fopenmp-targets=spir64 -g myprogram.o
```

次の環境変数を設定し、効広に、力一ルのデバック情報を有効にと。

```powershell
$ export LIBOMPTTARGET_OPENCL_COMPILATION_OPTIONS=" -g -cl-opt disable" $ export LIBOMPTTARGET_LEVEL0_COMPILATION_OPTIONS=" -g -cl-opt disable"
```

# 6.3.3.4. GPU实行をデバイ格

才Flor一DpGraLmの一般的不題是、実行に失敗し、追加情報をほと持たなOpenCL*工一生成さる。此。OpenCL* Aplk-ohn的in-tle-1-ontrace、ze_tracer、おはcl_tracer使用て、。。

# 6.3.3.4.1. OpenCL* トリケーニンのインーセ bt・レイヤ

ごのライランドリーヤー使用する场合、Buildloggingging、ErrorLogging、およ� USMChecking=1 才予予を使用て工しの原因为特定くださいます。

1. 次のデイストを含む clintercept.conf フアルを木一ム・デレクトリに作成いたします。

```txt
SimpleDumpProgramSource=1  
CallLogging=1  
LogToFile=1  
// KernelNameHashTracking=1  
BuildLogging=1  
ErrorLogging=1  
USMChecking=1  
// ContextCallbackLogging=1  
// Profiling knobs KernelInfoLogging=1  
DevicePerformanceTiming=1  
DevicePerformanceTimeLWSTracking=1  
DevicePerformanceTimeGWSTracking=1 
```

2. 次のように cliloaderを使用てアTPLケーニンを実行いたします。

```xml
<OCI_Intercept Install_Dir>/bin/clioaler/clioaler -d ./<app_name> <app_args> 
```

3. ~CLIntercept_Dump/<app_name> テレクトリーヤーヤの結果を確認いたします。

- interceptor_report.txt: 予口芙専ルの結果  
- interceptor_log.txt: OpenCL*の問題をデバックする際に使用くださる OpenCL*uisse出ロ格

次のデイスは、CL_INVALID.Arg_VALUE（-50） ランタイムエラ一が発生たプロガラム生成たロガフアルの例の一部です。

```txt
...
<< clSetKernelArgMemPointerINTEL -> CL_SUCCESS >>>>
clGetKernelInfo( _ZTSZZ10outer_coreiP5mesh_i16dpct_type_1c0e3516dpct_type_60257cS2_S2_S2_S2_S2_S2_S2_iENKULRN2c14syc17handlerEE197->45c1ES6_EU1NS4_7nd_itemILI3EEE225->13): param_name = CL_KERNEL_CONTEXT (1193)
<< clGetKernelInfo -> CL_SUCCESS >>>>
clSetKernelArgMemPointerINTEL( _ZTSZZ10outer_coreiP5mesh_i16dpct_type_1c0e3516dpct_type_60257cS2_S2_S2_S2_S2_S2_S2_S2_S2_S2_S2_S2_iENKULRN2c14syc17handlerEE197->45c1ES6_EU1NS4_7nd_itemILI3EEE225->13): kernel = 0xa2d51a0, index = 3, value = 0x41995e0
mem pointer 0x41995e0 is an UNKNOWN pointer and no device support shared system pointers!
ERROR! clSetKernelArgMemPointerINTEL returned CL_INVALID.Arg_VALUE (-50)
<< clSetKernelArgMemPointerINTEL -> CL_INVALID.Arg_VALUE 
```

它的例是、次的值加工一的丁伍和格与役立令。

ZTSZZ10outer_coreiP5mesh   
- index = 3, value = 0x41995e0

ごの徴一に効一力一ル川問題か、もはの引数に問題が的か分か、その理由を特定てきま�。

# 6.3.3.4.2. onetrace、ze_tracer、およこcl_tracer

OpenCL* トリクーニンのイターベー・レイヤー同様に、onetrace、ze_tracer およむ cl_tracer リルはレルズロのラフロー工し一的原因を検出るに役立与否。

ontrace 本身就是 ze_tracer ダルを使用してレパターンに付ける問題の根本的原因为特定いたします (cl_tracer 是、OpenCL*の問題の同樣の原因を特定くださいます)。

1. 呼出ロガモーツでアリケーニンを実行いたします。ソルの出力をフィルにリダレクトする这句话を推奨いたします。

```shell
$ ./onetrace -c ./<app_name> <app_args> [2> log.txt] 
```

ze_tracerのコマンドも同樣です。onetraceをze_tracerに置き換え的巨大尺寸。

1. 呼出レーニスを確認てエラ一を特定ります(log.txt)。次に例を示ります。

```txt
>>> [102032049] zeKernelCreate: hModule = 0x55a68c762690 desc = 0x7fff865b5570 {29 0 0 GEMM}  
phKernel = 0x7fff865b5438 (hKernel = 0)  
<>>> [102060428] zeKernelCreate [28379 ns] hKernel = 0x55a68c790280 -> ZE.Result_SUCCESS (0)  
...  
>>> [102249951] zeKernelSetGroupSize: hKernel = 0x55a68c790280 groupSizeX = 256 groupSizeY = 1 groupSizeZ = 1  
<>>> [102264632] zeKernelSetGroupSize [14681 ns] -> ZE.Result_SUCCESS (0)  
>>> [102278558] zeKernelSetArgumentValue: hKernel = 0x55a68c790280 argIndex = 0 argSize = 8  
pArgValue = 0x7fff865b5440  
<>>> [102294960] zeKernelSetArgumentValue [16402 ns] -> ZE.Result_SUCCESS (0)  
>>> [102308273] zeKernelSetArgumentValue: hKernel = 0x55a68c790280 argIndex = 1 argSize = 8  
pArgValue = 0x7fff865b5458  
<>>> [102321981] zeKernelSetArgumentValue [13708 ns] -> ZE.Result_ERROR_INVALID.ArgUMENT (2013265924)  
>>> [104428764] zeKernelSetArgumentValue: hKernel = 0x55af5f3ca600 argIndex = 2 argSize = 8  
pArgValue = 0x7ffe289c7e60  
<>>> [104442529] zeKernelSetArgumentValue [13765 ns] -> ZE.Result_SUCCESS (0)  
>>> [104455176] zeKernelSetArgumentValue: hKernel = 0x55af5f3ca600 argIndex = 3 argSize = 4  
pArgValue = 0x7ffe289c7e2c  
<>>> [104468472] zeKernelSetArgumentValue [13296 ns] -> ZE.Result_SUCCESS (0) ... 
```

ごの例のロムには次のデー夕が示ていestr。

- 問題の原因參考レルズロAPI呼吁出（zeKernelSetArgumentValue）  
- 問題の原因（ZE.Result_ERROR_INVALID.ArgUMENT）  
- 引数インはくス(argIndex = 1)  
- 不正値の場所(pArgValue = 0x7fff865b5458)  
- 力一neaルハンドル (hKernel = 0x55a68c790280)、その問題が検出くださた力一neaル名を示いたします (GEMM)

「フィルルへのリダレクト」才予言を省略て、すての出力 (アフリケーニンの出力 + ダルの出力)を1つのStutりムにダングPURるごと、多多の情報を取得いたします。单一のスリルムにダングを行うごと、アフリケー

Shonの出力に関連する工一的原因を特定るに役立つごたがります(例は、APRJANの初期化と計算の最初のFUEZで工一が発生てい的哪が分かます)。

```txt
Level Zero Matrix Multiplication (matrix size: 1024 x 1024, repeats 4 times) Target device: Intel® Graphics [0x3ea5]  
>>> [104131109] zeKernelCreate: hModule = 0x55af5f39ca10 desc = 0x7ffe289c7f80 {29 0 0 GEMM}  
phKernel = 0x7ffe289c7e48 (hKernel = 0)  
<<[104158819] zeKernelCreate [27710 ns] hKernel = 0x55af5f3ca600 -> ZE.Result_SUCCESS  
(0)  
>>> [104345820] zeKernelSetGroupSize: hKernel = 0x55af5f3ca600 groupSizeX = 256 groupSizeY = 1 groupSizeZ = 1  
<<[104360082] zeKernelSetGroupSize [14262 ns] -> ZE.Result_SUCCESS (0)  
>>> [104373679] zeKernelSetArgumentValue: hKernel = 0x55af5f3ca600 argIndex = 0 argSize = 8  
pArgValue = 0x7ffe289c7e50  
<<[104389443] zeKernelSetArgumentValue [15764 ns] -> ZE.Result_SUCCESS (0)  
>>> [104402448] zeKernelSetArgumentValue: hKernel = 0x55af5f3ca600 argIndex = 1 argSize = 8  
pArgValue = 0x7ffe289c7e68  
<<[104415871] zeKernelSetArgumentValue [13423 ns] -> ZE.Result_ERROR_INVALID.ArgUMENT  
(2013265924)  
>>> [104428764] zeKernelSetArgumentValue: hKernel = 0x55af5f3ca600 argIndex = 2 argSize = 8  
pArgValue = 0x7ffe289c7e60  
<<[104442529] zeKernelSetArgumentValue [13765 ns] -> ZE.Result_SUCCESS (0)  
>>> [104455176] zeKernelSetArgumentValue: hKernel = 0x55af5f3ca600 argIndex = 3 argSize = 4  
pArgValue = 0x7ffe289c7e2c  
<<[104468472] zeKernelSetArgumentValue [13296 ns] -> ZE.Result_SUCCESS (0)  
...  
Matrix multiplication time: 0.0427564 sec Results are INCORRECT with accuracy: 1  
...  
Matrix multiplication time: 0.0430995 sec Results are INCORRECT with accuracy: 1  
...  
Total execution time: 0.381558 sec 
```

# 6.3.3.5. 正当性

才Fl口一D可卜は、接統て的计算D巴式大容量の情報を効率良く处理る力一。、は一部の入力八L一夕一か大量の情報を生成用化利用さは。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。、。正い結果が得にいないとはプロガム実行のかな後判明しま。

そのような场合、その力一内科が誤った結果を生成してるか特定するは困難です。誤った結果を生成する力一内科を特定する方法とて、プロダムを2回実行する这句话を考にらます。最初は木ストローの実装を実行し、2回目は才FLOD实装を実行てすての力一内科（多は個のアル）の入力及出力を取得ります。次に、結果を比較て、その力一内科が予期ない結果を生成してるか確認します（特定のイフロロンで、才FLOD·ハーニアの操作順序や新业态の精度の違いによ、結果の最後の1桁もはは2桁が木ストロー及異な可能性のはんだ。

誤了結果を生成する力一内科が特定くださいます、インル® ダイストリビューニングの GDBを使用て原因を調査いたします。基本情報と詳細なドキメトへのリンクにpineは、『インル® ダイストリビューニングのGDBを使用たデバイングのチートリア(Linux*版)』(英語)を参照てくだい。

SYCL* と OpenMP* は哪吒も才ロービた力一NEL内で標準の総効力二VSム (SYCL* と C++ OpenMP* はは printf、Fortran OpenMP* 才ロービは print * なう)を利用くださいます。こを使用て、実行中的動作を確認いたします。出力元のスレット和SIMDレーニenを締つ、締つる情報が総効に一貫性持っように、同期力二VSムを追加するとを検討てくだい。Stur亜ムクラスを使用て DPC++ と同様のこを行う例は、『oneAPI GPU 最適化ガイド』記載得很好。OpenMP* 才ロービ向けの SYCL* 的説明同樣のアローツを適用いたします。

OpenMP* ヨーリ克莱フ使用てアリケーニンに並列处理を追加する方法の詳細にしぃは「インテルツル」によ得OpenMP* トクルクーニンの才ロードドと最適化」(英語)を参照てくだせ。

HINT: SYCL* 力一内科は printf 是冗長のにう可能性のはんだ。簡單にするたて次のマクロを追加いたします。

```cpp
#ifndef __SYCL_DEVICE_ONLY
#define CL_constant __attribute__( (opencl_constant))
#else
#define CL_constant
#endif
#define PRINTF(struct, ...) { \ static const CL_constant char __format[] = format; \
    sycl::ONEAPI::experimental::printf(_format, ##__VA Arguments); } 
```

使用例: PRINTF("My integer variable:%d\n", (int) x);

# 6.3.3.6. 障害

SYCL* たは OpenMP* 才プローニ語の誤った用法が原因で JIT フンバイルが失敗すると、プロガラムは工一を終了いたします。

SYCL* は事前コンパルいたします。OpenCL* バックエンドを選択て OpenCL* フリケーニングのインターミフロービーを使用する、構文工枠を持つ力一neaを特定くださいます。

口ジック工ヤは、実行中にケラツドが発生た、工LA一MSS一Jが表示るこが有み。こには以下が含まえま�：

·誤了CONNテ馬卜以属的八FF一力一乃川中渡山场合  
this トクルを克莱ス要素ははなく力一ルに渡す场合  
- ヨバイスバフアーヤはなく木トトフアーヤ渡す場合  
力一ル用使用てに、初期化ていはいはみンタ一渡か场合

インテル® ヨスリビューニングの GDB (または新业态 GDB)を使用て注意深く調查すると、生成たすてのコンテキトのアドレスを記録て才ローダ力一NEルに渡さるアドレスが正いコンテキトに属するか確認得起。同様に、変数のアドレスがその含むケラスでなく、変数自身的アドレスと一致するか確認得起。

OpenCL* 割り当用のインーベフローは、onetrace/cl_tracer 来使用て、適切なバックエンドを選択る方がバassicフローとアドレスをトレーニングするよう簡單な这句话は頃い。OpenCL* ヒックエンドを使用する場合、CallLogging、BuildLogging、ErrorLogging およんだ USMChecking 来設定てプロガラムを実行いたします。

onetrace or ze_tracerの Respirantはデバイス・ターマラインを参照する、レルズロのバクエンドからの工場の原則を理解するに役立つ追加の工場一情報が得りまな。こは、上記の論理工場を検出るに役立ちまな。

- LeVeLz口·VACKEINDを使用てデバイスに才FlO一Dる際にコ一Dでエーが発生する场合、OpenCL* VACKEINDを試てみてくさ。プロgrAUMが正常に機能する场合、LeVeLz口のVACKEINDに工一をレトてく。
- ヤ�バイス向けのOpenCL* VACKEINDでモ工一が再現する场合、OpenCL* CPU VACKEINDを試しま。
- OpenMP* 才FlO一Dはは、OMP_TARGET_OFFLOADをCPUに設定すると指定くださいます。SYCL*はは、ONEAPI_DEVICE_SELECTOR=opencl:cpuを設定いたします。CPU上ごのデバイスはなか容易にり、デーダのコ
- ビーとプロgrAUMのデバイスへの変換によて生じる複雜性も排除いたします。

問題が発生する可能性のはロジックの例とて、次のSYCL*コーユでparallel_forを実装する際に使用くださるラムダ関数でヤフチヤーる対象を考えいたします。

```cpp
class MyClass {
private:
    int *data;
    int factor;
    void run() {
        auto data2 = data;
        auto factor2 = factor;
        {
            dpct::get_default_queue_wait().submit([\&](cl::syc1::handler &cgh)
            {
                auto dpct_global_range = grid * block;
                auto dpct_local_range = block;
                cgh.parallel_for<class kernel_name<class kernel_855a44>>(cl::syc1::nd_range<1>(cl::syc1::range<1> dpct_global_range.get(0)), 
                cl::syc1::range<1> (dpct_local_range.get(0)), 
                [=](cl::syc1::nd_item<3> item_ct1)
            {
                kernel(data, b, factor, LEN, item_ct1); // This blows up
            };
        }
    } // run
} // MyClass 
```

上記のコトは、[=]がラム内用使用を数を值でコ比一用た、プロガラムはケラツ広し。ご例は、factorは実際にthis->factorで、dataはthis->dataあるた、thisはdataおよfactorを使用するたに取得を数です。OpenCL*はリルズ口は、kernel(data,b,factor,LEN, item_ct1)YP出て不正な引数エーナが原因でケラツ広し。

ごの問題を解決するには、ロ一力ル変数auto data2とauto factor2を使用いたします。auto factor2 = factorはint factor2 = this->factorにたて、ラムダ内分泌 [=]を指定てfactor2を使用いたします、intが取得いたします。内部セク余万元kernel(data2,b,factor2,LEN, item_ct1)；に变更いたします。

注：ごの問題は、CUDA*力一内科を移行する際によく発生いたします。同じ CUDA*力一内科の起動シングネチヤーを保持し、コマンドル一とラムダを力一内科内に配置するとて問題を解決するとも facileいたします。

OpenCL* 割り当のインーベフローフリーフリーフリーフリーフリーフリーフリーフリーフリーフリーフリーフリーフリーフリーフリーフリーフリーフリーフリーフリーフリーフリーフリーフリーフリーフリーフリーフリーフリーフリーフリーフリーフリーフリER。

統合共有×モリ一(USM)を使用てMyClassをUSMに割り当之る场合、上記のコフが動作するごに注意てくだい。ただし、USMにdataのみが割り当之てらてる场合、前述の理由からプロガムはケラツ広しま�。

ご例は、力一ル呼声を変更する必要くださに、ロ一ルスフ内同名前の変数を再宣言得起と留意てくさ。

```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
``

- OpenMP*

- export OMP_TARGET_OFFLOAD=CPU   
- export OMP_TARGET_OFFLOAD=MANDATORY   
- export LIBOMPTTARGET_PLUGIN=OPENCL

SYCL*

- export ONEAPI_DEVICE_SELECTOR=openc1:cpu   
- または、CPU イレクタを使用てチト一を初期化し、OpenCL* CPU ダバイスの仕様を強制いたします。cl::sycl::queue Queue(cl::sycl::cpu_selector{});

- 両方

- export CL_CONFIG_USE_VTUNE=True   
- export CL_CONFIG_USE_VECTORIZER=false

注：ル中に最適化を有効にするとクラツンする可能性のはんだ。最適化を無効にてル、ルは解たる场合、ル向に -g-[最適化レル]を指定いたします。詳細にしぃはは、『ル oneAPI DPC++/C++ ルーナリーダフレス』(英語)を参照てくだい。

# 6.3.3.7. SYCL* 例外ハンドラ一使用する

『Data Parallel C++: Mastering DPC++ for Programming of Heterogeneous Systems using C++ and SYCL』(英語)の書籍のはんだごた説明いたします。

C++の例外機能は、プロダム党内エラ一が検出くださ的位置と、エラ一が处理いたします位置は明確に分離するように設計いたします。その概念はSYCL*の同期エラ一と非同期エラ一の两方にも適合いたします。

ごの書籍で推奨いたします。と、C++例外处理は、エラ一発生時にプロダムが何の通知,Noし了るのははなく、んだらかの通知を行て終了するに役立与否。

注：ごの節の緑色で示たテキスは、C++とSYCL*を使用する異種スルのプロダラーニングを説明する『Data Parallel C++: Mastering DPC++ for Programming of Heterogeneous Systems using C++ and SYCL*』の第5章「Error Handling」からの拔粹です。簡素化のたて一部のテキスを省略いたします。詳細は書籍を参照くださいます。

# 工拉一处理の無視

C++ と SYCL* はは、エラを明示のに处理くださいます問題が発生たを通知くださいます設計いたします。未处理の同期たは非同期のエラのデフィルトの結果は、才レーテング・ステム通知するプロガムの異常終了にelizeます。次の2つは、そquel期工ラ一非同期工拉一を处理'?場合に発生る動作を模做ります。

以下のコト例は、ハンドルのはんだいC++例外の結果を示ていま�。こは、ハンドルのはんだいSYCL*同期工一なか原因oled可能性のはんだ。ごのコトは、特定の才レーテング·ステムがそのように振舞かテストいたします。

# C++の未处理例外

```txt
include<iostream>   
class something_went_wrong{};   
int main(){ std::cout << "Hello\n"; throw(something_went_wrong{});   
}   
Linux\* 为之实行例：   
$ Hello terminate called after throwing an instance of 'something_went_wrong' Aborted (core dumped) 
```

以下のコーナ例は、 Respiratory 間を表示。This is an attempt to demonstrate the ability of a child to perform a variety of tasks. 例如，孩子可以做许多不同的活动，比如在公园里进行球赛、画画、看动画等。

プロダムを工ヤ一を处理する必要のはんだは、チさない工ヤ一をチてからプロダムが終了するた、プロダムが何也通知するとなく失敗する心配がにません。

std::terminateはSYCL*非同期例外が处理いたしますときに-volume出たる  
```txt
include<iostream>   
int main() { std::cout << "Hello\n"; std::terminate();   
}   
Linux\* 为之实行例：   
$ Hello terminate called without an active exception Aborted (core dumped) 
```

ごのドキムntは、同期工一を C++の例外で处理得起的理由を詳し説明てはすが、アリケーニンで制御的位置で非同期工一を处理するには、SYCL*例外が Respiranting状況に注意て、SYCL*例外を利用する必要かごりま�。

SYCL* 为定義さる同期工LA一は、std::exception イーナフかの派生ケラスのは、以下に示すように try-catch 構造によて SYCL* 工LA一をヤツチiates。

sycl::exceptionをマッチするダ々一  
```txt
try{ // SYCL\* イードを実行 } catch (syc1::exception &e) { // 例外を出力たは処処のた何か実行 std::cout << "Caught sync SYCL exception: " << e.what( ) << "\n"; return 1; }
```

$\mathsf{C} + +$ 的工一处理力二之士加，SYCL* 为是兰夕氏上，于口一者 sycl::exception 例外taip 为追加了。其以外有三标 $\mathsf{C} + +$ 的例外处理的为用、開發者日是酬染习的足示。甚与详例以 以下示了。此为、追加的例外之斯为处理，main（）加罗子的和为口格拉夫终了了。 $C + +$ 的工一处理力二之土加，SYCL* 为是兰夕氏上，于口一者 sycl::exception 例外taip 为追加了。其以外有三标 $\mathsf{C} + +$ 的例外处理的为用、開發者日是酬染习的足示。甚与详例以以下示了。此为、追加的例外之斯为处理，main（）加罗子的和为口格拉夫终了了。

# 一

```cpp
try{ buffer<int> B{ range{16} }; //ERROR：親八口芬一多也大可子sub-buffer 为定義 //八口芬一·cunstlro卡一加外加口一者求 buffer<int> B2(B,id{8},range{16});   
} catch (syc1::exception &e){ //例外出力半日是处理的功何为实行 std::cout << "Caught sync SYCL exception:"<< e. what()<<"\n"; return 1;   
} catch (std::exception &e){ std::cout << "Caught std exception:"<< e. what()<<"\n"; return 2;   
} catch (...){ std::cout << "Caught unknown exception\n"; return 3;   
}   
return 0;   
出力例：   
Caught sync SYCL exception:Requested sub-buffer size exceeds the size of the parent buffer -30(CL_INVALID_VALUE) 
```

# 非同期工一处理

非同期工一\*SYCL\*兰夕（は）にはを\*のB克工口）以去検出さ、工一\*是木上口G拉的。  
卡卡之实行は無関係に発生し。工一\*SYCL\*兰夕的内部L上与格納也、口G拉M一加制御成的特定的位置の处理を行うたリスを送。非同期工一の处理を力八一用のに次の20のとを理解

1. 处理すばき未处理の非同期工LA一がる场合にIPH出さる非同期八ND拉一  
2. いつ非同期八ンドラ一が起動いたしますか

非同期八nd拉一は、アリケーニンが定義する関数のは、SYCL* バンテキストやチムに登録いたします。次のせクシャンで定義くださ过的時点で处理可能な未处理の非同期例外/outた場合、SYCL* バンタイムによる非同期八nd拉一が Respirantlyは例外リストが渡ります。非同期八nd拉一はastd::function とてCONTENKISTはまはチムのCONSTLARクタ一に渡ります、通常の関数、ラムダ、法兰クタ一なかで定義いたします。八nd拉一は、以下に示すように sycl::exception_list 引数を受け接入る必要,Noかはみ。

# 拉ムダとて定義た非同期八ンドラ一の実装例

```cpp
// 单純な非同期八ND拉一閲数  
auto handle_async_error = [(exception_list enlist) {  
    for (auto &e : enlist) {  
        try{ std::rethrow_exception(e); }  
        catch (sycl::exception& e) {  
            std::cout << "ASYNC EXCEPTION!!\n";  
            std::cout << e.what() << "\n";  
        }  
    }; 
```

上記の例のは、std::rethrow_exceptionの後に特定例外-Taivpのcatchが続き、例外-Taivp（它的场合syc1::exceptionの）のフィルターテ处理を提供いたします。C++为異なフィルターテ处理行う它と、taivpにかわりなくすての例外を處理するごまようお願いいたします。ハンドラーハは、構築時にチuyaんだはCONテキストに関連付けら)=(低レルの詳細にしぃいは第6章(英語)で詳し説明くださいます)。例えは、上記のリストで定義くださったハンドラーハをチuyaに登録するには、queue my_queue{gpu_selector{}，handle_async_error}のように記述し、ハンドラーハをCONテキストに登録するには、context my_context{handle_async_error}のように記述ります。

ほんとんだアリケーニンのは、コンテキスを明示のに作成了一份管理する必要のはんだせん (ハック克莱ウンドで自動のに作成いたします)。そのたて、非同期八ンドラーを使用する场合、その八ンドラーを特定のデバイスのキチ一関連付ける必要のはんだ(明示のなCONテキスははんだません)。

注：非同期八ND拉一を定義する场合、何かの理由でCONテキストを明示的に管理くださる、クは定義する必要のはんだ。

キューネアその親CONNTEXISTに対て非同期八ンドラ一が定義ていないと、そのキューネ(はたはCONNTEXIST)で処理が必須な非同期工LA一が発生た場合、デフィルトの非同期八ンドラ一が鳴出さはま。デフィルトの八ンドラ一は次のリストと同じually動作しぃま。

# デ fasルトの非同期八ンドラ一の例

```txt
// 单純な非同期ハンドラ一関数  
auto handle_async_error = [(exception_list enlist) {  
    for (auto &e : enlist) {  
        try{ std::rethrow_exception(e); }  
        catch (sycl::exception& e) {  
            // 非同期例外に関連する情報を出力  
        }  
    }  
// 异常終了て、未处理の例外のはんだとを  
// ハーケーに通知いたします  
std::terminate();  
};
```

デフ oatトの八ndra一は、例外リスト内の工一情報をeu一通知し、アリケーニンを異常終了させま。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。

非同期八undlra一にのうな工一を知かは普口格lma一に依存し。APLKJONが处理を正常に統行得起的。工一の口はAPLKJONの终了、て工一状態の回復まさまな情報が用。

一般には、sycl::exception::what()を Respirantly利用可能な工一の詳細を通知し、APRILKANONを終了させます。非同期八NDLRA一が内部で何を处理するかを決定るははプロGLMA一次第です、じばは見らる間違いとて、工一MSSER(プロGLAMのほかのMSSER一見逃た可能性のはむ)を出力てから八NDLAR一閲数を終了するご.Here。プロGLAMの状態を回復て、実行を继续て也安全的优点和確信う工一管理が成てい。限、非同期八NDLRA一閲数内ADPRKANONを終了は或と検討てくさ。

它能、工一が検出たにかかわさアリケーニの不正実行を統行するプロダムから誤った結果表示かる可能性が減少ります。ほんとのプロダムはは、非同期例外が発生た異常終了する这句话適切です。

# 6.3.3.7.1. 例：サイズ洩の才緱ク卜のSYCL*のスロ一

次の sensedルコトは、サイズがさロの才総ク卜が渡たてとに SYCL* 八ndra一がのように工一を生成かを示てい。

```cpp
1. #include <cstdlib>  
2. #include <CL/sycl.hpp>  
3.  
4. template <bool non_empty>  
5. static void fill(sycl::buffer<int> buf, sycl::queue & q) {  
6. q.submit([\&] (sycl::handler & h) {  
7. auto acc = sycl::accessor { buf, h, sycl::read_write };  
8. h(single_task([=]) {  
9. if constexpr(non_empty) {  
10. acc[0] = 1;  
11. }  
12. }  
13. );  
14. }  
15. );  
16. q.wait();  
17.  
18. }  
19.  
20. int main(int argc, char *argv[]) {  
21. sycl::queue q;  
22. sycl::buffer<int, 1> buf_zero (0);  
23.  
24. fprintf(stderr, "buf_zero.count() = %zu\n", buf_zero.get_count());  
25. fill=false>(buf_zero, q);  
26. fprintf stdout, "PASS\n");  
27.  
28. return 0;  
29. } 
```

アリケーニンが実行中にサイズがせロの才総じク卜に遭遇すると、プロガラムはアボーリ、エラーマツジが出力いたします。

```txt
$ dpcpp zero.cpp
$. /a.out
buf_zero.count() = 0
submit...
terminate called after throwing an instance of 'cl::sycl::invalid_object_error'
    what(): SYCL buffer size is zero. To create a device accessor, SYCL buffer size must be greater than zero. -30 (CL_INVALID_VALUE)
Aborted (core dumped) 
```

プロダラマーマは、デバイガーニ例外をチリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリリの問題を特定くださいます。

# 6.3.3.7.2. 例: 不正な NULL モイntonーダその SYCL* スローフ

以下のコードにpineて考てみます。

```txt
deviceQueue.memset(mdlReal, 0, mdlXYZ \* sizeof(XFLOAT)); deviceQueue.memcpy(mdlImag, 0, mdlXYZ \* sizeof(XFLOAT)); // ローダンガ・エラ一
```

CONPILRA-1=deviceQueue.memcpy 为指定的不正（NULL フILIN）值のFLAをSETL。。

```txt
terminate called after throwing an instance of 'cl::sycl::runtime_error' what(): NULL pointer argument in memory copy operation.-30 (CL_INVALID_VALUE) Aborted (core dumped) 
```

次のコービ例は、NULL フローの工しを示すプロガムに実装た、特定ク一の実行時の例外出力が検出さた際に、ルーカ例外出力の形式を制御する方法を示てい。

```cpp
1. #include"stdlib.h"
2. #include<stdio.h>
3. #include <math.h>
4. #include <signal.h>
5. #include <fstream>
6. #include <iostream>
7. #include <vector>
8. #include <CL/sycl.hpp>
9.
10. #define XFLOAT float
11. #define mdlXYZ 1000
12. #define MEMALIGN 64
13.
14. int main(int argc, char *argv[])
15. XFLOAT *mdlReal, *mdlImag;
16.
17. cl::sycl::property_list propList =
18. cl::sycl::property_list{cl::sycl::property::enable_profiling};
19. cl::sycl::queue deviceQueue(cl::sycl::gpu_selector { }),
20. [&](cl::sycl::exception_list eL) { 
```

```cpp
21. bool error = false;  
22. for (auto e : eL) {  
23. try {  
24. std::rethrow_exception(e);  
25. } catch (const cl::sycl::exception& e) {  
26. auto clError = e.get_cl_code();  
27. bool hascontext = e.has_context();  
28. std::cout << e.what() << "CL ERROR CODE : " << clError << std::endl;  
29. error = true;  
30. if (hascontext) {  
31. std::cout << "We got a context with this exception" << std::endl;  
32. }  
33. }  
34. }  
35. if (error) {  
36. throw std::runtime_error("SYCL errors detected");  
37. }  
38. }, propList);  
39.  
40. mdlReal = sycl::malloc_device<XFLOAT>(mdlXYZ, deviceQueue);  
41. mdlImag = sycl::malloc_device<XFLOAT>(mdlXYZ, deviceQueue);  
42.  
43. deviceQueue.memset(mdlReal, 0, mdlXYZ * sizeof(XFLOAT));  
44. deviceQueue.memcpy(mdlImag, 0, mdlXYZ * sizeof(XFLOAT)); // ミーダンダ・エロー  
45.  
46. deviceQueue.wait();  
47.  
48. exit(0);  
49. } 
```

# 6.3.3.8. リフロー

SYCL* APIの誤った使用による SYCL*例外をデバックするガイド付けのアプローミにpineは「ガイド付け行列乗算の例外のサングル」(英語)を参照てくだい。

リソーニスを才フローネする拝張機能を備た OpenMP* または SYCL* APIを使用するアプロケーションのトラ複ルシuyaーテングは、「高度な並列アプロケーションのトラ複ルシャUYーテング」(英語)のチuyaーツルを参照てくさい。

# 6.3.4 才フローロのハフローmansを最適化

才□一·八力一曼六的最適化は、3の作業に要約てきま�。

1. 德巴式上力一尔的实行时间最大化、德巴式間の日夕軸送回数与小化。  
2. 可能あらは、デバイス上の計算とデバイス上の逐一軽送を才一ハーリフさせます。  
3. 德専式上力一丶ルの八丶力一丶人六を最大化しま。

OpenMP* 才Flor一上SyCL*の两方でデ一夕軸送を明示的に制御するこがてきま�が、ごを自動的に行うとも可以。も、木ストと才Flor一上デハスはほん鸯非同期に動作するた、デ一夕軸送を制御しょうて也軸送が期待お願いに行わい、予想よも時間を要すこがに。テハスと木ストの两方でアクせさる一夕が統

合共有×モリ—(USM)に格納いたします。

一

- oneAPI GPU 最適化ガイド  
- ナンル® oneAPI FPGA 最適化ガイド (英語)

# 6.3.4.1. ローフフア一軽送時間と実行時間

才F口一德巴斯間の一夕軸送には比較的Custがかり、一空间のMモリ一割当、SStu一 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2

1回のデーナ軸送で才ローツーダービスとやり取る情報量にかわりなく、二の才一ハトドのコスははほほ同じです。そのた、1回に1つむははなく、10回分の軸送をまて行うはうがはるか高効率です。いすれにても、すてのデーナ軸送にははトが生しぃた、軸送の総数を最小限に説成重要です。例は複数の力一ルまは同じ力一ルの複数の Respirみ出産必要と用定数が有場合、等らを力一ルを呼営出産了送信するのははなく、一度け才ローツーダービスに軸送て再利用するようにしま。最後に、单一の大量のデ一夕軸送には、单一の少量のデ一夕軸送よ時間がかりま。

送信くださるバフアOneの数とサイズは式の一部に)sam。一夕が才Flor一Dデハスに到達し、力一ルが実行avenport時間を検討いたします。才Flor一Dデハスへの一夕軸送よりも実行時間が短い场合、同一操作を木ト上ご実行avenport時間が、力一ルの実行と従一軽送の合計時間よも長くない限り、才Flor一DのMリットはあらまSEN。

最後に、あた力一ルの実行と次の力一ルの実行間に、才Fl口一D巴斯がアドル状態にてる時間を調查いたします。長い待機時間は、デー軸送や木ト上のルロリズムの特性が原因oling可能性のはんだ。前者は、日夕軸送と力一ル実行の才一ハーラフを試す価値くださいます。

木戸上のコト実行、才ローニデバイスのコト実行、おはが予一軽送の関係は複雜です。ごしらの順番と時間は、単純なコト設備も直感的に理解得起るのはは必はません。すてのアケテビテーを視覺のに理解し、その情報を参考にし才ローニコトを最適化するには、次のうなルが必要にncy�は。

# 6.3.4.2. ナンル® VTune™ フロフロー

```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
```
``

インテル® VTune™ プロフィーラーの GPU 才フロードビューには、その功能をカーナル間とデタ軸送に費やさた時間等诸多、GPU 上のトスリトに開るサマリーが表示いたします。GPU計算/メデイア・トスリト・ビューのは、動的命令力ウINTを使用てGPUカーナルのバフローMANSSのマイクロ解析各样、GPUカーナルで何が起てい

か詳し調查るてがてき。てのプロフィル・モトは、デー軸送と計算が時間經過でそのうに変化か観察た力一ルを効率良く実行するに十分のカが的か判断た力一ルがGPU×モリ一階層をそのうに利用るか調てたてき。

这样解析的详细可以使用如下：「「INTEL®VTune™」。」在参照上，「「INTEL®VTune™」。」在参照上，「「INTEL®VTune™」。」。

力一NEルの実行時間を計測するには、インテル® VTune™ フロフィヤリーマ使用いたします。次のコマンドは、輕量プロフィ亚马ルの結果を示いたします：

# 收集

- ルルズロ・ハックエンド

```txt
$ vtune -collect-with runss -knob enable-gpu-level-zero=true -finalization-mode=none
-app-working-dir <app-working_dir> <app> 
```

- OpenCL* 萬克卡德

```txt
$ vtune -collect-with runss -knob collect-programming-api=true -finalization-mode=none -r <result_dir_name> -app-working-dir <app-working_dir> <app> 
```

- L木一ト

```txt
$ vtune --report hotspots --group-by=source-computing-task --sort desc="Total Time" -r <result_dir_name>
```

# 6.3.4.3. Ⅱntel®Advisor

InelAdvisorは、計算をGPUに才ローネる八フモMANス向上せうのに役立2の機能を提供しま。

- 才 fluorideのモーテル化は、木支持力度のOpenMP* プロガラムを調査て、GPUへの才 fluorideに適したコフ領域を示ります。た、多種多様なターダット向に GPUをモーテル化くださいます、ターダットに適した才 fluorideコフ領域を特定いたします。才 fluoride・アドバイギーは、才 fluoride・の八フローマスを制限する可能性のは要因に閲る詳細情報を提供いたします。  
- GPU ルーフライン解析は、GPU 为実行いたします。各力一NELが GPUのMモリ・サフステムと計算EUINを某种程度効率良く使用くださいますか視覺のに示ります。ごにご、力一NELがGPUにごはこ最適化いたします。

すてに才フロービ�実装するアリケーニンでそのモービ�使用するには、CPU上のOpenCL*デバイスを解析ターダットにるう環境を設定必須かたま。手順は、『イルAdvisoreer一ガト』(英語)を参照てくさ。

才FLO-1Dのモデル化はは、GPUを使用するようにアリケーニンを変更する必要はたません。木ストコ-1Dで完全に機能いたします。

LJ-

- 《 宏尔》Advisorク克:GPU才F口一  
- 才 fluorideのモダル化入門 (英語)  
GPU 超大尺寸入門 (英語)

# 6.3.4.4. 才FlO-1D API 呼出のタムレIN

InTureVTuneTMFroAiaIeruse用，一耘GUPcHb一s的tun、上力一实行者的in-tan被查了（未是成）场合、onetrace、ze_tracer、cl_tracer和OpenCL\*APLKJONのin-ta-LeYr-afo此i#i#i(14)。

# 6.4 ロフーマmans・チューニング・サイクル

八万欧元一曼斯·チーニング・サイクルの目標は、對話型の応答時間やバチジフの經過時間等诸多、問題解決ptoの時間を短縮するごとて。ハテロジニアス・ラリト万欧元一ムの场合、木戸ト独立て実行得起的デバイスで利用可能性計算サイクルのはんだ。こらのリソースを利用て八万欧元一曼スを向上させます。

八万欧元一 Manss·Thuc一二Ng·sialkull is、次のStnppがは。

1. バーランドénの確定  
2. 才Fl口一卜的力一乃的特定  
3. 力一NEルの才Fl口一D  
4. 最適化  
5. 目標を達成するまに1～4を繰り返す

# 6.4.1 バーメラインの確定

經過時間、計算力一ル時間、1秒んだの浮動小数点演算哪种を含むバーニラインを確定いたします。这也是一、ハフローマス上の測定だけに东南、結果の正当性を検証する手段とて利用いたします。

バームスラインを確定する簡單な方法は、C++の chrono ライランドリーピル一チンを使用て、ウーロトの実行前後でタマーマーリフロー出産時間計測を行うとです。

# 6.4.2 才Fl口一卜的力一不尔の特定

ハテロジニアス·TPLUTFOMのデバイスで利用可能な計算サイクルを最大限に活用するには、計算集約型で並列実行可能なタスケを特定するごと重要です。CPUのみで実行得起のAPRILKONを調査する、GPUで実行るに適したタスケが見つかるごとお願いいたします。こは、INTEL®Advisorの才Flor一のモル化機能て判別ります。

IneladAdvisorは、アケ塞尔一夕で実行得起可能性がるフロトの八氟ーマス特性を推測てきま。フロトのプロフィル情報から、八氟ーマ斯を見積も、高速化、ボルネックの特性を評価て、さに才F口一夕軀送を推測し、推奨事項を示ります。

一般に、計算主体で、大規模なデ一夕セットを持ち、限らた徳一夕軸送を行う力一neaルは、デバイスへの才フロ一ドに適ていま�。

才Fl口一的MDE化使用手顺中は『導入吉：GPUに才F口一上力大成的候補の特定』(英語)を参照てくさ。GPU フ拉トフアムのアリケーニンのMDE化の八フーマスに開るその他のリソーにつはは、「INTEL®Advisorユーダー向は才F口一のMDE化のリソー」(英语)を参照てくだ。

# 6.4.3 力一不儿を才フロ一ド

才Fl口一卜に適力一乃ルを特定た、SYCL* まは OpenMP* 使用て力一乃ルをデバイスに才Fl口一卜にま。詳細は前の節を参照てくさ。

# 6.4.4 SYCL* プリケーニンの最適化

oneAPIは、CPU、GPU、FPGA等、複数のアケ塞尔ーダー実行くださるコトを生成いたします。たて、コトはすて它的アケ塞尔ーダー最適のは可能性のはんだ。八万欧元ルスの目標を達成するには3段階の最適化を行うとを推奨いたします。

1. トクルレ一夕一全体に適用さる一般的な最適化を行いま�。  
2. 優先誃的克沙拉一夕一對以和之最適化行也。  
3. ステット1と2を組み合わせて木トコ一定を最適化いたします。

最適化は、ボルネック（ほかのeerドセクシャに比て実行時間が長いeer卜領域）を排除する作業です。こらのsesクhonは、デバイスたは木ストで実行,Nook。最適化は、Inntel®VTune™プロフィヤラ一等のprofafイル·ツル使用て、eer内のボルネックを特定ります。

ごは、最初のStépp的优点のアケ塞尔ーダ全体に適用いたします。デバイス固有自己的最適化、デバイス固有自己的デト・フローダ(Stépp 2)、おはみはトとデバイス間の最適化(Stépp 3)にたは、『イルoneAPI リルギットFPGA最適化ガイド』(英語)之称のデバイス固有自己的最適化ガイドで詳しく説明さてい。その節は、アケ塞尔ーダに才ローダする力一NELが決定くださいます。おは毎单独のアク

せレーテー一域はリクが完了すると想定てい。は、木トとアケレーモーツ間、たはは木トと複数の/異なアケレーモーモ間のリクの分割にては考慮ていせん。

アクセラレーダー全体に適用いたします一般的な最適化は次の4つに分類いたします。

1. 高レルの最適化  
2. ルーパング連の最適化  
3. マモリ一関連の最適化  
4. SYCL* 固有の最適化

次の節は上記の最適化のみを力 beyし。它らの最適化を実際にコトに反映する方法の詳細は、才不拉元也一般に入手�能るコト最適化関連の資料で見付うとが能ま。二ては、SYCL*固有の最適化に閲る詳細示了。

# 6.4.4.1. 高レパターンの最適化

- 並列フロー量を増やります。处理要素を十分に活用するには、处理要素のは多くのフローが必要です。  
力一不尔の一卜sialzを最小化し。上に、阿卡莱一的命令卡什如保持  
- 力一neaルのローダバRonスを取ります。実行時間の長い力一neaルはトルネck之称、ほかの力一neaルのStur一PHTに影響する可能性のはた、力一neaル間の実行時間は大小く異ならないようにしま。  
- 高コストの関数は避けてくだい。実行時間が長い関数は、ボルnellクによる可能性のはたてみ出さないでくだい。

# 6.4.4.2. ルフ関連の最適化

- 適切に構造化お願い構成た、単純な終了条件のルーポを使用いたします。単純な終了条件のルーポは、出口が1つearing、整数上限値之称較为单一の終了条件を持つルーポです。  
線形伊ntdss及定数上限值持tul一为優先承。例、配列の整数个nss使用、二八尔時上限值判明用的l一等式。  
- 可能な限り深いスローで変数を宣告いたします。ごによう、メモリ一まはStassckの使用量を軽減いたします。  
- 跆一丶依存関係を最小化たは緩和しま�。ル一丶依存関係にや、並列化が制限さるごにかは。可能な限り依存関係を排除しま�。排除�能な場合は、依存関係の距離を最大化すか、依存関係を口一力ルメモリ一内に留てま�。  
- pragma unroll ould be an open.

# 6.4.4.3. マモリ一関連の最適化

- 可能な限り、×モリ一使用よも計算を優先いたします。×モリ一のレイテンシ一と帀域幅のほうが計算よもトルネックにる可能性のは).(2)  
- 可能成為、格口一八ル×モリ一・効も口一力ルおよむフロービト・×モリ一・使用しま�。  
- トイローの工イリアシングを避けいたします。  
- マンの利用率を高わ。  
- 可能のはんだ、頻繁に実行いたします。」
- 一定規則を遵守し、理由を提供いたします。同時※モリーテフローに保持ります。  
別の力一neaルが讀み取る格口一ルMOMI一の書き迍を避けま。代わにハイフ使用し。  
- 力一NELに [[intel::kernel_argsrestrict]] 属性を適用するとを検討てくだい。その属性によう、CONPILARは力一NELのアケ塞尔引数間の依存関係を無視いたします。APLSEL引数の依存関係を無視すると、CONPILARはさらに積極な最適化を行い、力一NELのPAFOMANsが向上する可能性のはんだ。

# 6.4.4.4. SYCL*固有的最適化

- 可能のはば、work-groupサイズを指定いたします。属性 [[cl::reqd_work_group_size(X, Y, Z)]] (X、Y、ZはNd-rangeの整数次元)を使用て、work-groupのサイズを設定:Fかは。CONバイラ一是This 情報を利用て積極なが最適化を行うとが:Fかは。  
- 可能のはんだ、-Xsfp-relaxed 才予予を使用て下的。その才予予は、算術浮動小数点演算の順序付けを緩和しいます。  
- 可能のはんだ、-Xsfpc 才予予の使用を検討てくはい。その才予予は、可能な场合は常に中間の浮動小数点丸の操作と変換を排除て、精度を維持するた追加ビットをやリ一しま�。  
- -Xsno-accessor-aliasing 才予の利用を検討てくさ。その才予は、SYCL*力一ルのアクセサイ一引数間の依存関係を無視いたします。

# 6.4.5 再CONBAIL、実行、プロフィAIL、てて繰り返し

一卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡卡

- Mトリクは改善いたしますか？  
- 菊元一曼斯の目標は達成くださいますか？  
- 利用可能的计算サイクルが残たていま�か？

結果の正当性を確認いたします。数值結果を比較すると、コンパクトの最適化やコト変更に優異な場合,Noは言。差異は許容範圍内ですか？そのと令けは、最適化StyPに広りは。

# 6.5 oneAPI ライランドリOneの互換性

oneAPI トリケーニルには、イデルのツルのリリーベーヨンと互換性のた、動的ライフローが実行時に含むる场合のはんだ。一oneAPI ダルキットとコンボーネト製品は、互換性を維持するたもマテドク・バーニング(英語)を使用いたします。

次のつりシ一が、インテルoneAPI リルキット提供いたします API お願い ABIに適用いたします。

注: oneAPI トリケーニルは、64 ヒットのターダットデバイスでサボートさります。

- 新いイルの oneAPI ダバイスロー、oneAPI 動的ラリフロー、よう please oneAPI メンサイヤーは、インテル oneAPI ダルを使用てビルドくださた展開济みのアリケーニンを破損するごはようお願いいたします。現在のAPIは、通知とマッチの重複ently削除ようお願いいたします。  
- oneAPI トリケーニンの開発者は、ハダーフアイルとライフロリーツリーベーバーニンが同じ的一款を確認する必要くださいます。例えは、トリケーニンで、インテルoneMKL 2021.2のハダーフアイルをインテルoneMKL 2021.1で使用くださいますようお願いいたします。  
- フrenchを用むと、oldはリフローは、oldはリフローは作成たの Applikationは動作ります。一、它的逆は当はまりせん。 oneAPI 動的 newは旧に以前の Apiclctionは提供さていル一チが含むる场合のはんだ。  
- oneAPI 对應のインル® バンバイヤーを提供いたします。最新はバーニングのインル® oneAPI バンバイヤーのはは機能いたします。

oneAPIアリケーニンの開発者は、oneAPIアリケーニンが互換性のは oneAPI ライラリーともに展開得很好。完全なアリケーニンのテストを实施する必要くださいます。

# 6.6 SYCL* 拓張

SYCL* 拓張機能にや、開発者は迅速に実験、革新、新いソリューニンの作成を行うごて你能。も、ケスア一希テクチヤー・システムの開発をサボートる Khronos Group なのは才一斯夕nd一卜組織で继续的改善サイクルを促進するに役立与否。

indeloneAPI DPC++コンバイラーネドローヤていSYCL*擴張機能の一観には、「SYCL*擴張機能」(英語)を参照てくだい。

# 7 用語集

# アクセラレー- (Accelerator)

操作のサフSETトを迅速に実行する計算リソーナスを含む専用コンボーネnts。CPU、GPU、たはFPGA等。

「戊八」也参照。

# アクセCAF-(Accessor)

アケせスする場所(木スト、デバイス)とモーツ(dread,write)情報を通信くださいます。

# アプロKEーニン・スコフ (Application Scope)

木卜上成实行的。

# Biffers

計算行うた徴ルスに送る項目の数や型を通信する×モリ一·才総戸。

# Command Group Scope)

木戸トとデバイス間のインターフバイスとて動作するコード。

# コマンドキュ— (Command Queue)

コマンド格尔を同時に発行いたします。

# 計算 DUHOT (Compute Unit)

处理要素間使用共有要素含丶丁巴式上のはかの計算乙二卜にあ的X毛一力也高速中アスするた、处理要素を「」に格ル一化了も。

# デバイス (Device)

操作のサフローを迅速に実行する計算リソーネスを含むアケセラレーダー一まは専用コンパーネnts。CPUはデバイスとて利用くださいますが、その场合、CPUはアケセラレーダー一とて使用いたします。CPU、GPU、まはFPGAなり。

「アケせラレ一夕一」も参照。

# デバイスロー (Device Code)

木ストのははなくデバイスで実行いたします。デバイスコーツは、ラムダ式、フィンケタ、たは力一ルクラスを介紹て指定いたします。

# DPC++

SYCL* 恩一トを LLVM C++ ニンバイヤリーリに追加た才一総広・プロジクト。

# FafTbTbVaiNar (Fat Binary)

複数デバイス向けのデバイスコービを含むアプロケーニン・バイナリ一。バイナリ一には、汙用コト (SPIR-V* 形式)とターフット固有の実行可能コトの両方が含まえます。

# Fafutt·LaiPraLi- (Fat Library)

複数デバイス向けの才総戦卜·コトを含む一力イリまはは利亚フリーネ。フィット・ライフリーツには、汙用才総戦卜(SPIR-V\*形式)とターダット固有の才総戦卜·コトの両方が含むます。

# Fafutt·才普瑟克卜 (Fat Object)

複数デバイス向けの才総戦ト·コトを含むフィイル。フィット·才総戦トには、汙用才総戦ト (SPIR-V* 形式)とターフット固有の才総戦ト·コトの両方が含まえます。

# 木戸 (Host)

プロガラムの主要部分、具体的にはアリケーニン・スローとマンド・格尔・スローを実行するCPU・デスのシステム(コンビューダー)。

# 木ストコーナd (Host Code)

木ト・ルーナリーマドははにトは実行さるコト。

# IMEX-1J Images)

組込関数を介てアケせるシャーマット济りのあいなメモリ一·才緱戦。通常、RGB等の形式で保存せにケル構成さる画像に関係しま�。

# 力一NEUSCOOPE (Kernel Scope)

徴バイス上ご実行さるコト。

# ND-range

1次元、2次元、たは3次元のN次元レンジ、カーナル・インスローの格尔ーツ、たはウーク項目の略。

# 处理要素 (Processing Element)

計算 フニットを構成する計算向りの個別のエンジン。

# 卍一ソース (Single Source)

木戸トとアケセラレ一夕一実行得起同じフサイルのコード。

# SPIR-V*

格拉力尔·沙一达尔-斯一和计算力一零尔来表的一中間言語。

# SYCL*

同一ソーニスフィAILに含まるアリケーニンの木ストコードと力一ルコードと標準のISO C++を使用て、異種プロセSSFOneのコーは記述くださいますようお願いいたしますの抽象化レイヤの標準化。

# w-krul (work-group)

計算 フニットで実行するウーク項目の集合。

# WA-ク項目 (work-item)

oneAPI トロガラ モルにおる計算の基本単位。处理要素で実行さる力一ルに閲連付りらは。

# 8 著作樺と商標にて

インテルのデクノロジー使用するには、対応たハーネドウア、特定のソフトウア、まばはサイビスの有効化が必要とる场合のはんだ。

絕對的なせんクリデイを提供くださるルフクルーダー・ステムは%=さません。

實際の結果は異な场合,No�。

© Intel Corporation. Intel、イntonル、Intelロゴ、その其他的イntonルの名称やロゴは、Intel Corporation またはその子会社の商標です。

* その他的社名、製品名のはは、一般に各社の表示、商標たは登録商標です。

# 製品ophon性能の情報

性能は、使用状況、構成、その他的要因によて異なります。

詳細にしだはは、http://www.intel.com/PerformanceIndex/(英語)を参照てくだいたします。

注意事項の改訂 #20201201

特に明記之称い限、、のドクルはMIT ライルスの下に次の条件提供さ。

© Intel Corporation

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTY OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.